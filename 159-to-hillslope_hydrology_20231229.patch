diff --git a/Externals.cfg b/Externals.cfg
index a17f8e2ec..2e8d62309 100644
--- a/Externals.cfg
+++ b/Externals.cfg
@@ -59,7 +59,7 @@ tag = cdeps1.0.24
 protocol = git
 repo_url = https://github.com/ESCOMP/CDEPS.git
 local_path = components/cdeps
-externals =  Externals_CDEPS.cfg
+externals = Externals_CDEPS.cfg
 required = True
 
 [cpl7]
diff --git a/bld/CLMBuildNamelist.pm b/bld/CLMBuildNamelist.pm
index 17d64cd59..b26870841 100755
--- a/bld/CLMBuildNamelist.pm
+++ b/bld/CLMBuildNamelist.pm
@@ -1576,6 +1576,7 @@ sub process_namelist_inline_logic {
   setup_logic_glacier($opts, $nl_flags, $definition, $defaults, $nl,  $envxml_ref);
   setup_logic_dynamic_plant_nitrogen_alloc($opts, $nl_flags, $definition, $defaults, $nl, $physv);
   setup_logic_luna($opts, $nl_flags, $definition, $defaults, $nl, $physv);
+  setup_logic_hillslope($opts, $nl_flags, $definition, $defaults, $nl);
   setup_logic_o3_veg_stress_method($opts, $nl_flags, $definition, $defaults, $nl,$physv);
   setup_logic_hydrstress($opts,  $nl_flags, $definition, $defaults, $nl);
   setup_logic_dynamic_roots($opts,  $nl_flags, $definition, $defaults, $nl, $physv);
@@ -3223,12 +3224,8 @@ sub setup_logic_hydrology_switches {
   add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'use_subgrid_fluxes');
   add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'snow_cover_fraction_method');
   my $subgrid    = $nl->get_value('use_subgrid_fluxes' );
-  my $origflag   = $nl->get_value('origflag'    );
   my $h2osfcflag = $nl->get_value('h2osfcflag'  );
   my $scf_method = $nl->get_value('snow_cover_fraction_method');
-  if ( $origflag == 1 && &value_is_true($subgrid) ) {
-    $log->fatal_error("if origflag is ON, use_subgrid_fluxes can NOT also be on!");
-  }
   if ( $h2osfcflag == 1 && ! &value_is_true($subgrid) ) {
     $log->fatal_error("if h2osfcflag is ON, use_subgrid_fluxes can NOT be off!");
   }
@@ -3252,9 +3249,6 @@ sub setup_logic_hydrology_switches {
   if ( defined($use_vic) && defined($lower) && (&value_is_true($use_vic)) && $lower != 3 && $lower != 4) {
      $log->fatal_error( "If use_vichydro is on -- lower_boundary_condition can only be table or aquifer" );
   }
-  if ( defined($origflag) && defined($use_vic) && (&value_is_true($use_vic)) && $origflag == 1 ) {
-     $log->fatal_error( "If use_vichydro is on -- origflag can NOT be equal to 1" );
-  }
   if ( defined($h2osfcflag) && defined($lower) && $h2osfcflag == 0 && $lower != 4 ) {
      $log->fatal_error( "If h2osfcflag is 0 lower_boundary_condition can only be aquifer" );
   }
@@ -3436,6 +3430,32 @@ sub setup_logic_luna {
 
 #-------------------------------------------------------------------------------
 
+sub setup_logic_hillslope {
+  #
+  # Hillslope model
+  #
+  my ($opts, $nl_flags, $definition, $defaults, $nl) = @_;
+
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'use_hillslope' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'downscale_hillslope_meteorology' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'hillslope_head_gradient_method' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'hillslope_transmissivity_method' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'hillslope_pft_distribution_method' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'hillslope_soil_profile_method' );
+    add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'use_hillslope_routing', 'use_hillslope'=>$nl_flags->{'use_hillslope'} );
+  my $use_hillslope = $nl->get_value('use_hillslope');
+  my $use_hillslope_routing = $nl->get_value('use_hillslope_routing');
+   if ( (! &value_is_true($use_hillslope)) && &value_is_true($use_hillslope_routing) ) {
+       $log->fatal_error("Cannot turn on use_hillslope_routing when use_hillslope is off\n" );
+   }
+  my $downscale_hillslope_meteorology = $nl->get_value('use_hillslope_routing');
+   if ( (! &value_is_true($use_hillslope)) && &value_is_true($downscale_hillslope_meteorology) ) {
+      $log->fatal_error("Cannot turn on downscale_hillslope_meteorology when use_hillslope is off\n" );
+   }
+}
+
+#-------------------------------------------------------------------------------
+
 sub setup_logic_hydrstress {
   #
   # Plant hydraulic stress model
@@ -4164,7 +4184,6 @@ sub setup_logic_soil_resis {
 
   add_default($opts, $nl_flags->{'inputdata_rootdir'}, $definition, $defaults, $nl, 'soil_resis_method' );
 }
-#-------------------------------------------------------------------------------
 
 sub setup_logic_canopyfluxes {
   #
@@ -4527,6 +4546,7 @@ sub write_output_files {
 
   # CLM component
   my @groups;
+
   @groups = qw(clm_inparm ndepdyn_nml popd_streams urbantv_streams light_streams
                soil_moisture_streams lai_streams atm2lnd_inparm lnd2atm_inparm clm_canopyhydrology_inparm cnphenology
                cropcal_streams
@@ -4536,7 +4556,7 @@ sub write_output_files {
                soilhydrology_inparm luna friction_velocity mineral_nitrogen_dynamics
                soilwater_movement_inparm rooting_profile_inparm
                soil_resis_inparm  bgc_shared canopyfluxes_inparm aerosol
-               clmu_inparm clm_soilstate_inparm clm_nitrogen clm_snowhydrology_inparm
+               clmu_inparm clm_soilstate_inparm clm_nitrogen clm_snowhydrology_inparm hillslope_hydrology_inparm hillslope_properties_inparm
                cnprecision_inparm clm_glacier_behavior crop_inparm irrigation_inparm
                surfacealbedo_inparm water_tracers_inparm);
 
diff --git a/bld/namelist_files/namelist_defaults_ctsm.xml b/bld/namelist_files/namelist_defaults_ctsm.xml
index 3997066a0..288d22204 100644
--- a/bld/namelist_files/namelist_defaults_ctsm.xml
+++ b/bld/namelist_files/namelist_defaults_ctsm.xml
@@ -607,6 +607,18 @@ attributes from the config_cache.xml file (with keys converted to upper-case).
 <cnegcrit phys="clm4_5"  use_cn=".true.">-6.d+2</cnegcrit>
 <nnegcrit phys="clm4_5"  use_cn=".true.">-6.d+1</nnegcrit>
 
+
+<!-- Hillslope hydrology -->
+<use_hillslope                               >.false.</use_hillslope>
+<use_hillslope phys="clm4_5"                 >.false.</use_hillslope>
+<use_hillslope phys="clm5_0"                 >.false.</use_hillslope>
+<use_hillslope_routing                       >.false.</use_hillslope_routing>
+<hillslope_head_gradient_method              >Darcy</hillslope_head_gradient_method>
+<hillslope_transmissivity_method             >LayerSum</hillslope_transmissivity_method>
+<hillslope_pft_distribution_method           >Standard</hillslope_pft_distribution_method>
+<hillslope_soil_profile_method               >Uniform</hillslope_soil_profile_method>
+<downscale_hillslope_meteorology             >.true.</downscale_hillslope_meteorology>
+
 <!-- Plant hydraulic stress -->
 <use_hydrstress                                                       >.false.</use_hydrstress>
 <use_hydrstress phys="clm5_0"  use_fates=".false." configuration="clm">.true.</use_hydrstress>
diff --git a/bld/namelist_files/namelist_definition_ctsm.xml b/bld/namelist_files/namelist_definition_ctsm.xml
index 97310ebe8..22d21e8e0 100644
--- a/bld/namelist_files/namelist_definition_ctsm.xml
+++ b/bld/namelist_files/namelist_definition_ctsm.xml
@@ -784,6 +784,41 @@ LUNA operates on C3 and non-crop vegetation (see vcmax_opt for how other veg is
 LUNA: Leaf Utilization of Nitrogen for Assimilation
 </entry>
 
+<entry id="use_hillslope" type="logical" category="physics"
+        group="clm_inparm" valid_values="" value=".false.">
+Toggle to turn on the hillslope model
+</entry>
+
+<entry id="downscale_hillslope_meteorology" type="logical" category="physics"
+        group="clm_inparm" valid_values="" value=".false.">
+Toggle to turn on meteorological downscaling in hillslope model
+</entry>
+
+<entry id="use_hillslope_routing" type="logical" category="physics"
+        group="clm_inparm" valid_values="" value=".false.">
+Toggle to turn on surface water routing in the hillslope hydrology model
+</entry>
+
+<entry id="hillslope_head_gradient_method" type="char*256" category="physics"
+        group="hillslope_hydrology_inparm" valid_values="Kinematic,Darcy">
+Method for calculating hillslope saturated head gradient
+</entry>
+
+<entry id="hillslope_transmissivity_method" type="char*256" category="physics"
+        group="hillslope_hydrology_inparm" valid_values="LayerSum,Uniform">
+Method for calculating transmissivity of hillslope columns
+</entry>
+
+<entry id="hillslope_pft_distribution_method" type="char*256" category="physics"
+        group="hillslope_properties_inparm" valid_values="Standard,FromFile,DominantPftUniform,DominantPftLowland,PftLowlandUpland">
+Method for distributing pfts across hillslope columns
+</entry>
+
+<entry id="hillslope_soil_profile_method" type="char*256" category="physics"
+        group="hillslope_properties_inparm" valid_values="Uniform,FromFile,SetLowlandUpland,Linear">
+Method for distributing soil thickness across hillslope columns
+</entry>
+
 <entry id="use_hydrstress" type="logical" category="physics"
         group="clm_inparm" valid_values="" value=".false.">
 Toggle to turn on the plant hydraulic stress model
@@ -2476,12 +2511,6 @@ If surface water is active or not
 (deprecated -- will be removed)
 </entry>
 
-<entry id="origflag" type="integer" category="clm_physics"
-       group="clm_soilhydrology_inparm" valid_values="0,1" >
-Use original CLM4 soil hydraulic properties
-(deprecated -- will be removed)
-</entry>
-
 <!-- ========================================================================================  -->
 <!-- namelist elements associated with the CH4 Model                                           -->
 <!-- ========================================================================================  -->
diff --git a/bld/unit_testers/build-namelist_test.pl b/bld/unit_testers/build-namelist_test.pl
index 4d0312411..052efac87 100755
--- a/bld/unit_testers/build-namelist_test.pl
+++ b/bld/unit_testers/build-namelist_test.pl
@@ -811,21 +811,6 @@ my %failtest = (
                                      GLC_TWO_WAY_COUPLING=>"FALSE",
                                      phys=>"clm4_5",
                                    },
-     "-vic with origflag=1"      =>{ options=>"-vichydro -envxml_dir .",
-                                     namelst=>"origflag=1",
-                                     GLC_TWO_WAY_COUPLING=>"FALSE",
-                                     phys=>"clm4_5",
-                                   },
-     "l_bnd=flux with origflag=0"=>{ options=>"-envxml_dir .",
-                                     namelst=>"origflag=0, lower_boundary_condition=1",
-                                     GLC_TWO_WAY_COUPLING=>"FALSE",
-                                     phys=>"clm4_5",
-                                   },
-     "l_bnd=zflux with origflag=0"=>{ options=>"-envxml_dir .",
-                                     namelst=>"origflag=0, lower_boundary_condition=2",
-                                     GLC_TWO_WAY_COUPLING=>"FALSE",
-                                     phys=>"clm4_5",
-                                   },
      "bedrock with l_bnc=flux"   =>{ options=>"-envxml_dir .",
                                      namelst=>"use_bedrock=.true., lower_boundary_condition=1",
                                      GLC_TWO_WAY_COUPLING=>"FALSE",
diff --git a/cime_config/testdefs/testmods_dirs/clm/oldhyd/user_nl_clm b/cime_config/testdefs/testmods_dirs/clm/oldhyd/user_nl_clm
index 351bce0a8..5ef1fc660 100644
--- a/cime_config/testdefs/testmods_dirs/clm/oldhyd/user_nl_clm
+++ b/cime_config/testdefs/testmods_dirs/clm/oldhyd/user_nl_clm
@@ -1,4 +1,3 @@
  snow_cover_fraction_method = 'NiuYang2007'
  h2osfcflag  = 0
- origflag    = 1
  use_subgrid_fluxes = .false.
diff --git a/src/biogeochem/DryDepVelocity.F90 b/src/biogeochem/DryDepVelocity.F90
index f5968c9aa..d55366790 100644
--- a/src/biogeochem/DryDepVelocity.F90
+++ b/src/biogeochem/DryDepVelocity.F90
@@ -284,13 +284,13 @@ CONTAINS
 
     if ( n_drydep == 0 ) return
 
-    associate(                                                    &
-         forc_solad =>    atm2lnd_inst%forc_solad_grc           , & ! Input:  [real(r8) (:,:) ] direct beam radiation (visible only)
-         forc_t     =>    atm2lnd_inst%forc_t_downscaled_col    , & ! Input:  [real(r8) (:)   ] downscaled atmospheric temperature (Kelvin)
-         forc_q     =>    wateratm2lndbulk_inst%forc_q_downscaled_col    , & ! Input:  [real(r8) (:)   ] downscaled atmospheric specific humidity (kg/kg)
-         forc_pbot  =>    atm2lnd_inst%forc_pbot_downscaled_col , & ! Input:  [real(r8) (:)   ] downscaled surface pressure (Pa)
-         forc_rain  =>    wateratm2lndbulk_inst%forc_rain_downscaled_col , & ! Input:  [real(r8) (:)   ] downscaled rain rate [mm/s]
-
+    associate(                                                    & 
+         forc_solai =>    atm2lnd_inst%forc_solai_grc           , & ! Input:  [real(r8) (:,:) ] direct beam radiation (visible only)             
+         forc_solad =>    atm2lnd_inst%forc_solad_downscaled_col, & ! Input:  [real(r8) (:,:) ] direct beam radiation (visible only)             
+         forc_t     =>    atm2lnd_inst%forc_t_downscaled_col    , & ! Input:  [real(r8) (:)   ] downscaled atmospheric temperature (Kelvin)                   
+         forc_q     =>    wateratm2lndbulk_inst%forc_q_downscaled_col    , & ! Input:  [real(r8) (:)   ] downscaled atmospheric specific humidity (kg/kg)              
+         forc_pbot  =>    atm2lnd_inst%forc_pbot_downscaled_col , & ! Input:  [real(r8) (:)   ] downscaled surface pressure (Pa)                              
+         forc_rain  =>    wateratm2lndbulk_inst%forc_rain_downscaled_col , & ! Input:  [real(r8) (:)   ] downscaled rain rate [mm/s]                                   
          h2osoi_vol =>    waterstatebulk_inst%h2osoi_vol_col        , & ! Input:  [real(r8) (:,:) ] volumetric soil water (0<=h2osoi_vol<=watsat)
          snow_depth =>    waterdiagnosticbulk_inst%snow_depth_col        , & ! Input:  [real(r8) (:)   ] snow height (m)
 
@@ -322,12 +322,12 @@ CONTAINS
             g = patch%gridcell(pi)
             pg         = forc_pbot(c)
             spec_hum   = forc_q(c)
-            rain       = forc_rain(c)
-            sfc_temp   = forc_t(c)
-            solar_flux = forc_solad(g,1)
-            lat        = grc%latdeg(g)
-            lon        = grc%londeg(g)
-            clmveg     = patch%itype(pi)
+            rain       = forc_rain(c) 
+            sfc_temp   = forc_t(c) 
+            solar_flux = forc_solad(c,1) 
+            lat        = grc%latdeg(g) 
+            lon        = grc%londeg(g) 
+            clmveg     = patch%itype(pi) 
             soilw      = h2osoi_vol(c,1)
 
             !map CLM veg type into Wesely veg type
diff --git a/src/biogeochem/VOCEmissionMod.F90 b/src/biogeochem/VOCEmissionMod.F90
index f1865af3b..a4bd9dc4d 100644
--- a/src/biogeochem/VOCEmissionMod.F90
+++ b/src/biogeochem/VOCEmissionMod.F90
@@ -485,7 +485,7 @@ contains
          !h2osoi_vol   => waterstate_inst%h2osoi_vol_col        , & ! Input:  [real(r8) (:,:) ]  volumetric soil water (m3/m3)                   
          !h2osoi_ice   => waterstate_inst%h2osoi_ice_col        , & ! Input:  [real(r8) (:,:) ]  ice soil content (kg/m3)                        
          
-         forc_solad    => atm2lnd_inst%forc_solad_grc           , & ! Input:  [real(r8) (:,:) ]  direct beam radiation (visible only)            
+         forc_solad    => atm2lnd_inst%forc_solad_downscaled_col, & ! Input:  [real(r8) (:,:) ]  direct beam radiation (visible only)            
          forc_solai    => atm2lnd_inst%forc_solai_grc           , & ! Input:  [real(r8) (:,:) ]  diffuse radiation     (visible only)            
          forc_pbot     => atm2lnd_inst%forc_pbot_downscaled_col , & ! Input:  [real(r8) (:)   ]  downscaled atmospheric pressure (Pa)                          
          forc_pco2     => atm2lnd_inst%forc_pco2_grc            , & ! Input:  [real(r8) (:)   ]  partial pressure co2 (Pa)                                             
@@ -557,7 +557,7 @@ contains
           ! Calculate PAR: multiply w/m2 by 4.6 to get umol/m2/s for par (added 8/14/02)
           !------------------------
           ! SUN:
-          par_sun    = (forc_solad(g,1)  + fsun(p)    * forc_solai(g,1))  * 4.6_r8
+          par_sun    = (forc_solad(c,1)  + fsun(p)    * forc_solai(g,1))  * 4.6_r8
           par24_sun  = (forc_solad24(p)  + fsun24(p)  * forc_solai24(p))  * 4.6_r8
           par240_sun = (forc_solad240(p) + fsun240(p) * forc_solai240(p)) * 4.6_r8
 
diff --git a/src/biogeophys/BalanceCheckMod.F90 b/src/biogeophys/BalanceCheckMod.F90
index ff72bcb30..8e761b5d0 100644
--- a/src/biogeophys/BalanceCheckMod.F90
+++ b/src/biogeophys/BalanceCheckMod.F90
@@ -35,6 +35,8 @@ module BalanceCheckMod
   use landunit_varcon    , only : istdlak, istsoil,istcrop,istwet,istice
   use column_varcon      , only : icol_roof, icol_sunwall, icol_shadewall
   use column_varcon      , only : icol_road_perv, icol_road_imperv
+  use clm_varctl         , only : use_hillslope_routing
+
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -215,6 +217,7 @@ contains
     !
     ! !USES:
     use subgridAveMod, only: c2g
+    use LandunitType , only : lun                
     !
     ! !ARGUMENTS:
     type(bounds_type)          , intent(in)    :: bounds
@@ -231,8 +234,8 @@ contains
     character(len=5)           , intent(in)    :: flag  ! specifies begwb or endwb
     !
     ! !LOCAL VARIABLES:
-    integer :: g  ! indices
-    integer :: begc, endc, begg, endg  ! bounds
+    integer :: g, l  ! indices
+    integer :: begc, endc, begl, endl, begg, endg  ! bounds
     real(r8) :: wb_col(bounds%begc:bounds%endc)  ! temporary column-level water mass
     real(r8) :: wb_grc(bounds%begg:bounds%endg)  ! temporary grid cell-level water mass
     real(r8) :: qflx_liq_dynbal_left_to_dribble(bounds%begg:bounds%endg)  ! grc liq dynamic land cover change conversion runoff flux
@@ -250,6 +253,8 @@ contains
 
     begc = bounds%begc
     endc = bounds%endc
+    begl = bounds%begl
+    endl = bounds%endl
     begg = bounds%begg
     endg = bounds%endg
 
@@ -266,6 +271,15 @@ contains
     call c2g(bounds, wb_col(begc:endc), wb_grc(begg:endg), &
              c2l_scale_type='urbanf', l2g_scale_type='unity')
 
+    ! add landunit level state variable, convert from (m3) to (kg m-2)
+    if (use_hillslope_routing) then
+       do l = begl, endl
+          g = lun%gridcell(l)
+          wb_grc(g) = wb_grc(g) +  waterstate_inst%stream_water_volume_lun(l) &
+               *1e3_r8/(grc%area(g)*1.e6_r8)
+       enddo
+    endif
+    
     ! Call the beginning or ending version of the subroutine according
     ! to flag value
     if (flag == 'begwb') then
@@ -500,8 +514,9 @@ contains
      !-----------------------------------------------------------------------
 
      associate(                                                                   & 
-          forc_solad              =>    atm2lnd_inst%forc_solad_grc             , & ! Input:  [real(r8) (:,:) ]  direct beam radiation (vis=forc_sols , nir=forc_soll )
-          forc_solai              =>    atm2lnd_inst%forc_solai_grc             , & ! Input:  [real(r8) (:,:) ]  diffuse radiation     (vis=forc_solsd, nir=forc_solld)
+          forc_solad_col    =>    atm2lnd_inst%forc_solad_downscaled_col        , & ! Input:  [real(r8) (:,:) ]  direct beam radiation (vis=forc_sols , nir=forc_soll )
+          forc_solad        =>    atm2lnd_inst%forc_solad_not_downscaled_grc    , & ! Input:  [real(r8) (:,:) ]  direct beam radiation (vis=forc_sols , nir=forc_soll )
+          forc_solai        =>    atm2lnd_inst%forc_solai_grc                   , & ! Input:  [real(r8) (:,:) ]  diffuse radiation     (vis=forc_solsd, nir=forc_solld)
           forc_rain         =>    wateratm2lnd_inst%forc_rain_downscaled_col    , & ! Input:  [real(r8) (:)   ]  column level rain rate [mm/s]
           forc_rain_grc     =>    wateratm2lnd_inst%forc_rain_not_downscaled_grc, & ! Input:  [real(r8) (:)   ]  grid cell-level rain rate [mm/s]
           forc_snow         =>    wateratm2lnd_inst%forc_snow_downscaled_col    , & ! Input:  [real(r8) (:)   ]  column level snow rate [mm/s]
@@ -546,6 +561,7 @@ contains
           qflx_qrgwl_grc          =>    waterlnd2atm_inst%qflx_rofliq_qgwl_grc  , & ! Input:  [real(r8) (:)   ]  grid cell-level qflx_surf at glaciers, wetlands, lakes
           qflx_drain_col          =>    waterflux_inst%qflx_drain_col           , & ! Input:  [real(r8) (:)   ]  column level sub-surface runoff (mm H2O /s)
           qflx_drain_grc          =>    waterlnd2atm_inst%qflx_rofliq_qsub_grc  , & ! Input:  [real(r8) (:)   ]  grid cell-level drainage (mm H20 /s)
+          qflx_streamflow_grc     =>    waterlnd2atm_inst%qflx_rofliq_stream_grc, & ! Input: [real(r8) (:)   ] streamflow [mm H2O/s]             
           qflx_ice_runoff_col     =>    waterlnd2atm_inst%qflx_ice_runoff_col   , & ! Input:  [real(r8) (:)   ] column level solid runoff from snow capping and from excess ice in soil (mm H2O /s)
           qflx_ice_runoff_grc     =>    waterlnd2atm_inst%qflx_rofice_grc       , & ! Input:  [real(r8) (:)   ] grid cell-level solid runoff from snow capping and from excess ice in soil (mm H2O /s)
           qflx_sl_top_soil        =>    waterflux_inst%qflx_sl_top_soil_col     , & ! Input:  [real(r8) (:)   ]  liquid water + ice from layer above soil to top soil layer or sent to qflx_qrgwl (mm H2O/s)
@@ -635,7 +651,6 @@ contains
                   - qflx_ice_runoff_col(c)   &
                   - qflx_snwcp_discarded_liq_col(c) &
                   - qflx_snwcp_discarded_ice_col(c)) * dtime
-
           else
 
              errh2o_col(c) = 0.0_r8
@@ -655,7 +670,7 @@ contains
              ' local indexc= ',indexc,&
              ' global indexc= ',global_index, &
              ' errh2o= ',errh2o_col(indexc)
-         if ((errh2o_max_val > error_thresh) .and. (DAnstep > skip_steps)) then
+           if ((errh2o_max_val > error_thresh) .and. (DAnstep > skip_steps)) then
               
               write(iulog,*)'CTSM is stopping because errh2o > ', error_thresh, ' mm'
               write(iulog,*)'nstep                     = ',nstep
@@ -725,12 +740,20 @@ contains
                - qflx_snwcp_discarded_ice_grc(g)) * dtime
        end do
 
+       ! add landunit level flux variable, convert from (m3/s) to (kg m-2 s-1)
+       if (use_hillslope_routing) then
+          ! output water flux from streamflow (+)
+          do g = bounds%begg, bounds%endg
+             errh2o_grc(g) = errh2o_grc(g) &
+                  +  qflx_streamflow_grc(g) * dtime
+          enddo
+       endif
+
        errh2o_max_val = maxval(abs(errh2o_grc(bounds%begg:bounds%endg)))
 
        ! BUG(rgk, 2021-04-13, ESCOMP/CTSM#1314) Temporarily bypassing gridcell-level check with use_fates_planthydro until issue 1314 is resolved
        
        if (errh2o_max_val > h2o_warning_thresh .and. .not.use_fates_planthydro) then
-
           indexg = maxloc( abs(errh2o_grc(bounds%begg:bounds%endg)), 1 ) + bounds%begg - 1
           write(iulog,*)'WARNING:  grid cell-level water balance error ',&
              ' nstep= ',nstep, &
@@ -805,6 +828,7 @@ contains
                  if (col%itype(c) == icol_road_perv .or. lun%itype(l) == istsoil .or. &
                       lun%itype(l) == istcrop .or. lun%itype(l) == istwet .or. &
                       lun%itype(l) == istice) then
+
                    snow_sources(c) = (qflx_snow_grnd_col(c) - qflx_snow_h2osfc(c) ) &
                           + frac_sno_eff(c) * (qflx_liq_grnd_col(c) &
                           + qflx_soliddew_to_top_layer(c) + qflx_liqdew_to_top_layer(c) ) &
@@ -883,8 +907,8 @@ contains
              ! level because of interactions between columns and since a separate check is done
              ! in the urban radiation module
              if (.not. lun%urbpoi(l)) then
-                errsol(p) = fsa(p) + fsr(p) &
-                     - (forc_solad(g,1) + forc_solad(g,2) + forc_solai(g,1) + forc_solai(g,2))
+                   errsol(p) = fsa(p) + fsr(p) &
+                        - (forc_solad_col(c,1) + forc_solad_col(c,2) + forc_solai(g,1) + forc_solai(g,2))
              else
                 errsol(p) = spval
              end if
@@ -949,7 +973,6 @@ contains
                write(iulog,*)'CTSM is stopping'
                call endrun(subgrid_index=indexp, subgrid_level=subgrid_level_patch, msg=errmsg(sourcefile, __LINE__))
            end if
-
        end if
        
        ! Longwave radiation energy balance check
diff --git a/src/biogeophys/HillslopeHydrologyMod.F90 b/src/biogeophys/HillslopeHydrologyMod.F90
new file mode 100644
index 000000000..ed7e6fa54
--- /dev/null
+++ b/src/biogeophys/HillslopeHydrologyMod.F90
@@ -0,0 +1,1213 @@
+module HillslopeHydrologyMod
+
+  !-----------------------------------------------------------------------
+  ! !DESCRIPTION:
+  ! Read geomorphological parameters for hillslope columns 
+  !
+  ! !USES:
+#include "shr_assert.h"
+  use shr_kind_mod   , only : r8 => shr_kind_r8
+  use shr_log_mod    , only : errMsg => shr_log_errMsg
+  use spmdMod        , only : masterproc, iam
+  use abortutils     , only : endrun
+  use clm_varctl     , only : iulog
+  use clm_varctl     , only : use_hillslope_routing
+  use decompMod      , only : bounds_type
+  use clm_varcon     , only : rpi
+
+  ! !PUBLIC TYPES:
+  implicit none
+
+  private   
+  save
+
+  ! !PUBLIC MEMBER FUNCTIONS:
+  public hillslope_properties_init
+  public InitHillslope
+  public SetHillslopeSoilThickness
+  public HillslopeSoilThicknessProfile
+  public HillslopeSetLowlandUplandPfts
+  public HillslopeDominantLowlandPft
+  public HillslopePftFromFile
+  public HillslopeStreamOutflow
+  public HillslopeUpdateStreamWater
+  
+  integer, public :: pft_distribution_method ! Method for distributing pfts across hillslope columns
+  integer, public :: soil_profile_method     ! Method for varying soil thickness across hillslope columns
+  
+  ! Streamflow methods
+  integer, public, parameter :: streamflow_manning = 0
+  ! Pft distribution methods
+  integer, public, parameter :: pft_standard  = 0
+  integer, public, parameter :: pft_from_file = 1
+  integer, public, parameter :: pft_uniform_dominant_pft = 2
+  integer, public, parameter :: pft_lowland_dominant_pft = 3
+  integer, public, parameter :: pft_lowland_upland = 4
+
+  ! PRIVATE 
+  character(len=*), parameter, private :: sourcefile = &
+       __FILE__
+  integer, private, parameter :: soil_profile_uniform               = 0 
+  integer, private, parameter :: soil_profile_from_file             = 1
+  integer, private, parameter :: soil_profile_set_lowland_upland    = 2 
+  integer, private, parameter :: soil_profile_linear                = 3
+
+  !-----------------------------------------------------------------------
+
+contains
+
+  !-----------------------------------------------------------------------
+  subroutine hillslope_properties_init(NLFilename)
+    !
+    ! DESCRIPTION
+    ! read in hillslope hydrology veg/soil properties namelist variables
+    !
+    ! !USES:
+    use abortutils      , only : endrun
+    use fileutils       , only : getavu, relavu
+    use spmdMod         , only : mpicom, masterproc
+    use shr_mpi_mod     , only : shr_mpi_bcast
+    use clm_varctl      , only : iulog
+    use clm_nlUtilsMod  , only : find_nlgroup_name
+
+    ! !ARGUMENTS:
+    implicit none
+    character(len=*), intent(in) :: NLFilename ! Namelist filename
+    !----------------------------------------------------------------------
+    integer            :: nu_nml                     ! unit for namelist file
+    integer            :: nml_error                  ! namelist i/o error flag
+    character(len=*), parameter :: nmlname = 'hillslope_properties_inparm'
+    character(*), parameter    :: subName = "('read_hillslope_properties_namelist')"
+    ! Default values for namelist
+    character(len=50) :: hillslope_pft_distribution_method = 'Standard'      ! pft distribution method string
+    character(len=50) :: hillslope_soil_profile_method     = 'Uniform'       ! soil thickness distribution method string
+    !-----------------------------------------------------------------------
+
+! MUST agree with name in namelist and read statement
+    namelist /hillslope_properties_inparm/  &
+         hillslope_pft_distribution_method, &
+         hillslope_soil_profile_method
+    
+    ! Read hillslope hydrology namelist
+    if (masterproc) then
+       nu_nml = getavu()
+       open( nu_nml, file=trim(NLFilename), status='old', iostat=nml_error )
+       call find_nlgroup_name(nu_nml, 'hillslope_properties_inparm', status=nml_error)
+       if (nml_error == 0) then
+          read(nu_nml, nml=hillslope_properties_inparm,iostat=nml_error)
+          if (nml_error /= 0) then
+             call endrun(subname // ':: ERROR reading hillslope properties namelist')
+          end if
+       else
+          call endrun(subname // ':: ERROR reading hillslope properties namelist')
+       end if
+       close(nu_nml)
+       call relavu( nu_nml )
+
+       if (      trim(hillslope_pft_distribution_method) == 'Standard' ) then
+          pft_distribution_method = pft_standard
+       else if ( trim(hillslope_pft_distribution_method) == 'FromFile' ) then
+          pft_distribution_method = pft_from_file
+       else if ( trim(hillslope_pft_distribution_method) == 'DominantPftUniform') then
+          pft_distribution_method = pft_uniform_dominant_pft
+       else if ( trim(hillslope_pft_distribution_method) == 'DominantPftLowland') then
+          pft_distribution_method = pft_lowland_dominant_pft
+       else if ( trim(hillslope_pft_distribution_method) == 'PftLowlandUpland') then
+          pft_distribution_method = pft_lowland_upland
+       else
+          call endrun(msg="ERROR bad value for hillslope_pft_distribution_method in "//nmlname//"namelist"//errmsg(sourcefile, __LINE__))
+       end if
+
+       if (      trim(hillslope_soil_profile_method) == 'Uniform' ) then
+          soil_profile_method = soil_profile_uniform
+       else if ( trim(hillslope_soil_profile_method) == 'FromFile' ) then
+          soil_profile_method = soil_profile_from_file
+       else if ( trim(hillslope_soil_profile_method) == 'SetLowlandUpland' ) then
+          soil_profile_method = soil_profile_set_lowland_upland
+       else if ( trim(hillslope_soil_profile_method) == 'Linear') then
+          soil_profile_method = soil_profile_linear
+       else
+          call endrun(msg="ERROR bad value for hillslope_soil_profile_method in "//nmlname//"namelist"//errmsg(sourcefile, __LINE__))
+       end if
+
+    endif
+
+    call shr_mpi_bcast(pft_distribution_method, mpicom)
+    call shr_mpi_bcast(soil_profile_method, mpicom)
+
+    if (masterproc) then
+
+       write(iulog,*) ' '
+       write(iulog,*) 'hillslope_properties settings:'
+       write(iulog,*) '  hillslope_pft_distribution_method = ',hillslope_pft_distribution_method
+       write(iulog,*) '  hillslope_soil_profile_method     = ',hillslope_soil_profile_method
+
+    endif
+
+  end subroutine hillslope_properties_init
+
+  !-----------------------------------------------------------------------
+  subroutine check_aquifer_layer()
+    !
+    ! !DESCRIPTION:
+    ! Check whether use_hillslope and use_aquifer_layer are both set
+    ! The use of use_hillslope is implied by the call to this function
+    ! in InitHillslope, but explicitly compare here for clarity.
+    !
+    ! !USES:
+    use clm_varctl              , only : use_hillslope
+    use SoilWaterMovementMod    , only : use_aquifer_layer
+    if(use_hillslope .and. use_aquifer_layer()) then
+       write(iulog,*) ' ERROR: use_hillslope and use_aquifer_layer may not be used simultaneously'
+       call endrun(msg=' ERROR: use_hillslope and use_aquifer_layer cannot both be set to true' // &
+            errMsg(sourcefile, __LINE__))
+    end if
+
+  end subroutine check_aquifer_layer
+
+  !-----------------------------------------------------------------------
+
+  subroutine InitHillslope(bounds,fsurdat)
+    !
+    ! !DESCRIPTION:
+    ! Initialize hillslope geomorphology from input dataset
+    !
+    ! !USES:
+    use LandunitType    , only : lun                
+    use GridcellType    , only : grc                
+    use ColumnType      , only : col                
+    use clm_varctl      , only : nhillslope, max_columns_hillslope
+    use spmdMod         , only : masterproc
+    use fileutils       , only : getfil
+    use clm_varcon      , only : spval, ispval, grlnd 
+    use landunit_varcon , only : istsoil
+    use subgridWeightsMod , only : compute_higher_order_weights
+    use ncdio_pio
+    
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    character(len=*) , intent(in) :: fsurdat    ! surface data file name
+    integer,  pointer     :: ihillslope_in(:,:) ! read in - integer
+    integer,  pointer     :: ncolumns_hillslope_in(:) ! read in number of columns
+    integer,  allocatable :: ncolumns_hillslope(:)    ! number of hillslope columns
+    integer,  allocatable :: hill_ndx(:,:)      ! hillslope index
+    integer,  allocatable :: col_ndx(:,:)       ! column index
+    integer,  allocatable :: col_dndx(:,:)      ! downhill column index
+    integer,  allocatable :: hill_pftndx(:,:)   ! hillslope pft index []
+    integer,  allocatable :: col_pftndx(:)      ! hillslope column pft index []
+    real(r8), pointer     :: fhillslope_in(:,:) ! read in - float
+    real(r8), allocatable :: pct_hillslope(:,:) ! percent of landunit occupied by hillslope
+    real(r8), allocatable :: hill_slope(:,:)    ! hillslope slope  [m/m]
+    real(r8), allocatable :: hill_aspect(:,:)   ! hillslope azimuth [radians]
+    real(r8), allocatable :: hill_area(:,:)     ! hillslope area   [m2]
+    real(r8), allocatable :: hill_length(:,:)   ! hillslope length [m]
+    real(r8), allocatable :: hill_width(:,:)    ! hillslope width  [m]
+    real(r8), allocatable :: hill_height(:,:)   ! hillslope height [m]
+    real(r8), allocatable :: hill_bedrock(:,:)  ! hillslope bedrock depth [m]
+    real(r8), pointer     :: fstream_in(:)      ! read in - 1D - float
+
+    type(file_desc_t)     :: ncid                 ! netcdf id
+    logical               :: readvar              ! check whether variable on file    
+    character(len=256)    :: locfn                ! local filename
+    integer               :: ierr                 ! error code
+    integer               :: c, l, g, i, j, ci, nh       ! indices
+
+    real(r8)              :: ncol_per_hillslope(nhillslope) ! number of columns per hillslope        
+    real(r8)              :: hillslope_area(nhillslope)     ! area of hillslope
+    real(r8)              :: nhill_per_landunit(nhillslope) ! total number of each representative hillslope per landunit
+    
+    character(len=*), parameter :: subname = 'InitHillslope'
+
+    !-----------------------------------------------------------------------
+
+    ! consistency check
+    call check_aquifer_layer()
+
+    ! Open surface dataset to read in data below 
+
+    call getfil (fsurdat, locfn, 0)
+    call ncd_pio_openfile (ncid, locfn, 0)
+    
+    allocate( &
+         ncolumns_hillslope(bounds%begl:bounds%endl),  &
+         pct_hillslope(bounds%begl:bounds%endl,nhillslope),  &
+         hill_ndx     (bounds%begl:bounds%endl,max_columns_hillslope), &
+         col_ndx      (bounds%begl:bounds%endl,max_columns_hillslope), &
+         col_dndx     (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_slope   (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_aspect  (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_area    (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_length  (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_width   (bounds%begl:bounds%endl,max_columns_hillslope), &
+         hill_height  (bounds%begl:bounds%endl,max_columns_hillslope), &
+         col_pftndx   (bounds%begc:bounds%endc), &
+         stat=ierr)
+
+    allocate(ncolumns_hillslope_in(bounds%begg:bounds%endg))
+    
+    call ncd_io(ncid=ncid, varname='nhillcolumns', flag='read', data=ncolumns_hillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: nhillcolumns not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       ncolumns_hillslope(l) = ncolumns_hillslope_in(g)
+       ! vegetated landunits having nonzero hillslope columns and nonzero weight
+       if(lun%wtgcell(l) > 0._r8 .and. lun%itype(l) == istsoil .and. ncolumns_hillslope_in(g) > 0) then
+          do c = lun%coli(l), lun%colf(l)
+             col%is_hillslope_column(c) = .true.
+          enddo
+       endif
+    enddo
+    deallocate(ncolumns_hillslope_in)
+
+    allocate(fhillslope_in(bounds%begg:bounds%endg,nhillslope))
+    
+    call ncd_io(ncid=ncid, varname='pct_hillslope', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: pct_hillslope not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       pct_hillslope(l,:) = fhillslope_in(g,:)
+    enddo
+    deallocate(fhillslope_in)
+    
+    allocate(ihillslope_in(bounds%begg:bounds%endg,max_columns_hillslope))
+    
+    call ncd_io(ncid=ncid, varname='hillslope_index', flag='read', data=ihillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: hillslope_index not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_ndx(l,:) = ihillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='column_index', flag='read', data=ihillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: column_index not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       col_ndx(l,:) = ihillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='downhill_column_index', flag='read', data=ihillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: downhill_column_index not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       col_dndx(l,:) = ihillslope_in(g,:)
+    enddo
+    deallocate(ihillslope_in)
+    
+    allocate(fhillslope_in(bounds%begg:bounds%endg,max_columns_hillslope))
+    call ncd_io(ncid=ncid, varname='h_slope', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_slope not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_slope(l,:) = fhillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='h_aspect', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_aspect not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_aspect(l,:) = fhillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='h_area', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_area not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_area(l,:) = fhillslope_in(g,:)
+    enddo
+    call ncd_io(ncid=ncid, varname='h_length', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_length not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_length(l,:) = fhillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='h_width', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_width not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_width(l,:) = fhillslope_in(g,:)
+    enddo
+    
+    call ncd_io(ncid=ncid, varname='h_height', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       if (masterproc) then
+          call endrun( 'ERROR:: h_height not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+       end if
+    end if
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       hill_height(l,:) = fhillslope_in(g,:)
+    enddo
+
+    deallocate(fhillslope_in)
+    
+    allocate(ihillslope_in(bounds%begg:bounds%endg,max_columns_hillslope))
+    call ncd_io(ncid=ncid, varname='h_pftndx', flag='read', data=ihillslope_in, dim1name=grlnd, readvar=readvar)
+    if (readvar) then
+       allocate(hill_pftndx (bounds%begl:bounds%endl,max_columns_hillslope), stat=ierr)
+       if (masterproc) then
+          write(iulog,*) 'h_pftndx found on surface data set'
+       end if
+       do l = bounds%begl,bounds%endl
+          g = lun%gridcell(l)
+          hill_pftndx(l,:) = ihillslope_in(g,:)
+       enddo
+    end if
+
+    deallocate(ihillslope_in)
+
+    if (use_hillslope_routing) then 
+       allocate(fstream_in(bounds%begg:bounds%endg))
+       call ncd_io(ncid=ncid, varname='h_stream_depth', flag='read', data=fstream_in, dim1name=grlnd, readvar=readvar)
+       if (readvar) then
+          if (masterproc) then
+             write(iulog,*) 'h_stream_depth found on surface data set'
+          end if
+          do l = bounds%begl,bounds%endl
+             g = lun%gridcell(l)
+             lun%stream_channel_depth(l) = fstream_in(g)
+          enddo
+       else
+          if (masterproc) then
+             call endrun( 'ERROR:: h_stream_depth not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+          end if
+       endif
+       call ncd_io(ncid=ncid, varname='h_stream_width', flag='read', data=fstream_in, dim1name=grlnd, readvar=readvar)
+       if (readvar) then
+          if (masterproc) then
+             write(iulog,*) 'h_stream_width found on surface data set'
+          end if
+          do l = bounds%begl,bounds%endl
+             g = lun%gridcell(l)
+             lun%stream_channel_width(l) = fstream_in(g)
+          enddo
+       else
+          if (masterproc) then
+             call endrun( 'ERROR:: h_stream_width not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+          end if
+       end if
+       call ncd_io(ncid=ncid, varname='h_stream_slope', flag='read', data=fstream_in, dim1name=grlnd, readvar=readvar)
+       if (readvar) then
+          if (masterproc) then
+             write(iulog,*) 'h_stream_slope found on surface data set'
+          end if
+          do l = bounds%begl,bounds%endl
+             g = lun%gridcell(l)
+             lun%stream_channel_slope(l) = fstream_in(g)
+          enddo
+       else
+          if (masterproc) then
+             call endrun( 'ERROR:: h_stream_slope not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+          end if
+       end if
+
+       deallocate(fstream_in)
+    endif
+       
+    !  Set hillslope hydrology column level variables
+    !  This needs to match how columns set up in subgridMod
+    do l = bounds%begl,bounds%endl
+       g = lun%gridcell(l)
+       if(lun%itype(l) == istsoil) then
+
+          ! map external column index to internal column index
+          do c = lun%coli(l), lun%colf(l)
+             ! ci should span [1:nhillcolumns(l)]
+             ci = c-lun%coli(l)+1
+
+             if (col_dndx(l,ci) <= -999) then
+                ! lowermost column of hillslope has no downstream neighbor
+                col%cold(c) = ispval
+             else
+                ! relative separation should be the same
+                col%cold(c) = c + (col_dndx(l,ci) - col_ndx(l,ci))
+             endif
+          enddo
+          
+          do c = lun%coli(l), lun%colf(l)
+             ci = c-lun%coli(l)+1
+             
+             col%hillslope_ndx(c) = hill_ndx(l,ci)
+
+             ! Find uphill neighbors (this may not actually be useful...)
+             col%colu(c) = ispval
+             do i = lun%coli(l), lun%colf(l)
+                if(c == col%cold(i)) then
+                   col%colu(c) = i
+                endif
+             enddo
+             
+             ! distance of lower edge of column from hillslope bottom
+             col%hill_distance(c) = hill_length(l,ci)
+             ! width of lower edge of column 
+             col%hill_width(c) = hill_width(l,ci)
+             ! mean elevation of column relative to gridcell mean elevation
+             col%hill_elev(c) = hill_height(l,ci)
+             ! mean along-hill slope of column
+             col%hill_slope(c) = hill_slope(l,ci)
+             ! area of column
+             col%hill_area(c) = hill_area(l,ci)
+             ! azimuth of column
+             col%hill_aspect(c) = hill_aspect(l,ci)
+             ! pft index of column
+             if ( allocated(hill_pftndx) ) then
+                col_pftndx(c) = hill_pftndx(l,ci)
+             endif
+             
+          enddo
+
+          ! Calculate total hillslope area on landunit and
+          ! number of columns in each hillslope
+          ncol_per_hillslope(:)= 0._r8
+          hillslope_area(:)    = 0._r8
+          do c = lun%coli(l), lun%colf(l)
+             nh = col%hillslope_ndx(c)
+             if (nh > 0) then
+                ncol_per_hillslope(nh) = ncol_per_hillslope(nh) + 1
+                hillslope_area(nh) = hillslope_area(nh) + col%hill_area(c)
+             endif
+          enddo
+
+          if (use_hillslope_routing) then 
+                       
+             ! Total area occupied by each hillslope (m2) is
+             ! grc%area(g)*1.e6*lun%wtgcell(l)*pct_hillslope(l,nh)*0.01
+             ! Number of representative hillslopes per landunit
+             ! is the total area divided by individual area
+             ! include factor of 0.5 because a channel is shared by ~2 hillslopes
+
+             lun%stream_channel_number(l) = 0._r8
+             do nh = 1, nhillslope
+                if(hillslope_area(nh) > 0._r8) then
+                   nhill_per_landunit(nh) = grc%area(g)*1.e6_r8*lun%wtgcell(l) &
+                        *pct_hillslope(l,nh)*0.01/hillslope_area(nh)
+
+                   lun%stream_channel_number(l) = lun%stream_channel_number(l) &
+                        + 0.5_r8 * nhill_per_landunit(nh)
+                endif
+             enddo
+             
+             ! Calculate steam channel length
+             ! Total length of stream banks is individual widths
+             ! times number of hillslopes per landunit 
+             ! include factor of 0.5 because a channel is shared by ~2 hillslopes
+             lun%stream_channel_length(l) = 0._r8
+             do c = lun%coli(l), lun%colf(l)
+                if(col%cold(c) == ispval) then
+                   lun%stream_channel_length(l) = lun%stream_channel_length(l) &
+                        + col%hill_width(c) * 0.5_r8 * nhill_per_landunit(col%hillslope_ndx(c))
+                endif
+             enddo
+          endif
+                       
+          ! if missing hillslope information on surface dataset,
+          ! call endrun
+          if (ncolumns_hillslope(l) > 0 .and. sum(hillslope_area) == 0._r8) then
+             if (masterproc) then
+                write(iulog,*) 'Problem with input data: nhillcolumns is non-zero, but hillslope area is zero'
+                write(iulog,*) 'Check surface data for gridcell at (lon/lat): ', grc%londeg(g),grc%latdeg(g)
+                call endrun( 'ERROR:: sum of hillslope areas is zero.'//errmsg(sourcefile, __LINE__) )
+             end if
+          endif
+          
+          ! Recalculate column weights using input areas
+          ! The higher order weights will be updated in a subsequent reweight_wrapup call
+          do c = lun%coli(l), lun%colf(l)
+             nh = col%hillslope_ndx(c)
+             if (col%is_hillslope_column(c)) then
+                col%wtlunit(c) = (col%hill_area(c)/hillslope_area(nh)) &
+                     * (pct_hillslope(l,nh)*0.01_r8)
+             endif
+          enddo
+       endif
+    enddo ! end of landunit loop
+    
+    deallocate(ncolumns_hillslope,pct_hillslope,hill_ndx,col_ndx,col_dndx, &
+         hill_slope,hill_area,hill_length, &
+         hill_width,hill_height,hill_aspect)
+
+    ! Modify pft distributions
+    ! this may require modifying subgridMod/natveg_patch_exists
+    ! to ensure patch exists in every gridcell
+    if (pft_distribution_method == pft_from_file) then
+       call HillslopePftFromFile(bounds,col_pftndx)
+    else if (pft_distribution_method == pft_lowland_dominant_pft) then
+       ! Specify different pfts for uplands / lowlands
+       call HillslopeDominantLowlandPft(bounds)
+    else if (pft_distribution_method == pft_lowland_upland) then
+       ! example usage: 
+       ! upland_ivt  = 13 ! c3 non-arctic grass
+       ! lowland_ivt = 7  ! broadleaf deciduous tree
+       call HillslopeSetLowlandUplandPfts(bounds,lowland_ivt=7,upland_ivt=13)
+    endif
+    
+    if ( allocated(hill_pftndx) ) then
+       deallocate(hill_pftndx)
+       deallocate(col_pftndx)
+    endif
+    
+    ! Update higher order weights and check that weights sum to 1
+    call compute_higher_order_weights(bounds)
+    
+    call ncd_pio_closefile(ncid)
+    
+  end subroutine InitHillslope
+
+  !-----------------------------------------------------------------------
+
+  subroutine SetHillslopeSoilThickness(bounds,fsurdat,soil_depth_lowland_in,soil_depth_upland_in)
+    !
+    ! !DESCRIPTION:
+    ! Set hillslope column nbedrock values
+    !
+    ! !USES:
+    use LandunitType    , only : lun
+    use GridcellType    , only : grc
+    use ColumnType      , only : col
+    use clm_varctl      , only : nhillslope, max_columns_hillslope
+    use clm_varcon      , only : zmin_bedrock, zisoi
+    use clm_varpar      , only : nlevsoi
+    use spmdMod         , only : masterproc
+    use fileutils       , only : getfil
+    use clm_varcon      , only : spval, ispval, grlnd
+    use ncdio_pio
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    character(len=*) , intent(in) :: fsurdat    ! surface data file name
+    real(r8), intent(in), optional  :: soil_depth_lowland_in
+    real(r8), intent(in), optional  :: soil_depth_upland_in
+    real(r8), pointer     :: fhillslope_in(:,:) ! read in - float
+
+    type(file_desc_t)     :: ncid                 ! netcdf id
+    logical               :: readvar              ! check whether variable on file
+    character(len=256)    :: locfn                ! local filename
+    integer               :: ierr                 ! error code
+    integer               :: c, l, g, j, ci       ! indices
+
+    real(r8)              :: soil_depth_lowland
+    real(r8)              :: soil_depth_upland
+    real(r8), parameter   :: soil_depth_lowland_default = 8.0
+    real(r8), parameter   :: soil_depth_upland_default  = 8.0
+    character(len=*), parameter :: subname = 'SetHillslopeSoilThickness'
+
+    !-----------------------------------------------------------------------
+
+    if(soil_profile_method==soil_profile_from_file) then
+
+       ! Open surface dataset to read in data below
+       call getfil (fsurdat, locfn, 0)
+       call ncd_pio_openfile (ncid, locfn, 0)
+
+       allocate(fhillslope_in(bounds%begg:bounds%endg,max_columns_hillslope))
+       call ncd_io(ncid=ncid, varname='h_bedrock', flag='read', data=fhillslope_in, dim1name=grlnd, readvar=readvar)
+       if (readvar) then
+          if (masterproc) then
+             write(iulog,*) 'h_bedrock found on surface data set'
+           else
+             if (masterproc) then
+                call endrun( 'ERROR:: soil_profile_method = "FromFile", but h_bedrock not found on surface data set.'//errmsg(sourcefile, __LINE__) )
+             end if
+          end if
+          do l = bounds%begl,bounds%endl
+             g = lun%gridcell(l)
+             do c = lun%coli(l), lun%colf(l)
+                if (col%is_hillslope_column(c) .and. col%active(c)) then
+                   ci = c-lun%coli(l)+1
+                   do j = 1,nlevsoi
+                      if(zisoi(j-1) > zmin_bedrock) then
+                         if (zisoi(j-1) < fhillslope_in(g,ci) &
+                              .and. zisoi(j) >= fhillslope_in(g,ci)) then
+                            col%nbedrock(c) = j
+                         end if
+                      endif
+                   enddo
+                endif
+             enddo
+          enddo
+          deallocate(fhillslope_in)
+       end if
+       call ncd_pio_closefile(ncid)
+
+    else if (soil_profile_method==soil_profile_set_lowland_upland &
+         .or. soil_profile_method==soil_profile_linear) then
+
+       if(present(soil_depth_lowland_in)) then
+          soil_depth_lowland = soil_depth_lowland_in
+       else
+          soil_depth_lowland = soil_depth_lowland_default
+       endif
+
+       if(present(soil_depth_upland_in)) then
+          soil_depth_upland = soil_depth_upland_in
+       else
+          soil_depth_upland = soil_depth_upland_default
+       endif
+
+       ! Modify hillslope soil thickness profile
+       call HillslopeSoilThicknessProfile(bounds,&
+            soil_profile_method=soil_profile_method,&
+            soil_depth_lowland_in=soil_depth_lowland,&
+            soil_depth_upland_in=soil_depth_upland)
+    endif
+
+  end subroutine SetHillslopeSoilThickness
+
+  !-----------------------------------------------------------------------
+  subroutine HillslopeSoilThicknessProfile(bounds,&
+       soil_profile_method,soil_depth_lowland_in,soil_depth_upland_in)
+    !
+    ! !DESCRIPTION:
+    ! Modify soil thickness across hillslope by changing
+    ! col%nbedrock
+    !
+    ! !USES:
+    use LandunitType    , only : lun                
+    use GridcellType    , only : grc                
+    use ColumnType      , only : col                
+    use clm_varcon      , only : zmin_bedrock, zisoi
+    use clm_varpar      , only : nlevsoi
+    use spmdMod         , only : masterproc
+    use fileutils       , only : getfil
+    use clm_varcon      , only : spval, ispval, grlnd 
+    use ncdio_pio
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    integer,  intent(in)  :: soil_profile_method
+    real(r8), intent(in), optional  :: soil_depth_lowland_in
+    real(r8), intent(in), optional  :: soil_depth_upland_in
+
+    integer               :: c, l, g, i, j
+    real(r8)              :: min_hill_dist, max_hill_dist
+    real(r8)              :: m, b           ! linear soil thickness slope/intercept
+    real(r8)              :: soil_depth_col
+    real(r8)              :: soil_depth_lowland
+    real(r8)              :: soil_depth_upland
+    real(r8), parameter   :: soil_depth_lowland_default = 8.0
+    real(r8), parameter   :: soil_depth_upland_default  = 8.0
+    real(r8), parameter   :: toosmall_distance  = 1e-6
+
+    character(len=*), parameter :: subname = 'HillslopeSoilThicknessProfile'
+
+    !-----------------------------------------------------------------------
+
+    if(present(soil_depth_lowland_in)) then
+       soil_depth_lowland = soil_depth_lowland_in
+    else
+       soil_depth_lowland = soil_depth_lowland_default
+    endif
+    
+    if(present(soil_depth_upland_in)) then
+       soil_depth_upland = soil_depth_upland_in
+    else
+       soil_depth_upland = soil_depth_upland_default
+    endif
+
+    ! Specify lowland/upland soil thicknesses separately
+    if(soil_profile_method == soil_profile_set_lowland_upland) then
+       do c = bounds%begc,bounds%endc
+          if (col%is_hillslope_column(c) .and. col%active(c)) then
+             if(col%cold(c) /= ispval) then 
+                do j = 1,nlevsoi
+                   if(zisoi(j-1) > zmin_bedrock) then
+                      if (zisoi(j-1) < soil_depth_upland .and. zisoi(j) >= soil_depth_upland) then
+                         col%nbedrock(c) = j
+                      end if
+                   end if
+                enddo
+             else 
+                do j = 1,nlevsoi 
+                   if(zisoi(j-1) > zmin_bedrock) then
+                      if (zisoi(j-1) < soil_depth_lowland .and. zisoi(j) >= soil_depth_lowland) then
+                         col%nbedrock(c) = j
+                      end if
+                   end if
+                enddo
+             endif
+          endif
+       end do
+    ! Linear soil thickness profile
+    else if(soil_profile_method == soil_profile_linear) then
+       do l = bounds%begl,bounds%endl
+          min_hill_dist = minval(col%hill_distance(lun%coli(l):lun%colf(l)))
+          max_hill_dist = maxval(col%hill_distance(lun%coli(l):lun%colf(l)))
+
+          if(abs(max_hill_dist - min_hill_dist) > toosmall_distance) then
+             m = (soil_depth_lowland - soil_depth_upland)/ &
+                  (max_hill_dist - min_hill_dist)
+          else
+             m = 0._r8
+          endif
+          b = soil_depth_upland
+          
+          do c =  lun%coli(l), lun%colf(l)
+             if (col%is_hillslope_column(c) .and. col%active(c)) then
+                soil_depth_col = m*(max_hill_dist - col%hill_distance(c)) + b
+
+                do j = 1,nlevsoi
+                   if ((zisoi(j-1) <  soil_depth_col) .and. (zisoi(j) >= soil_depth_col)) then
+                      col%nbedrock(c) = j
+                   end if
+                enddo
+             endif
+          enddo
+       enddo
+    else
+       if (masterproc) then
+          call endrun( 'ERROR:: invalid soil_profile_method.'//errmsg(sourcefile, __LINE__) )
+       end if
+    endif
+       
+  end subroutine HillslopeSoilThicknessProfile
+
+  !------------------------------------------------------------------------
+  subroutine HillslopeSetLowlandUplandPfts(bounds,lowland_ivt,upland_ivt)
+    !
+    ! !DESCRIPTION: 
+    ! Reassign patch type of each column based on whether a column
+    ! is identified as a lowland or an upland.
+    ! Assumes each column has a single pft.
+    ! In preparation for this reassignment of patch type, only the 
+    ! first patch was given a non-zero weight in surfrd_hillslope
+
+    !
+    ! !USES
+    use LandunitType    , only : lun                
+    use ColumnType      , only : col                
+    use clm_varcon      , only : ispval
+    use clm_varpar      , only : natpft_lb
+    use PatchType       , only : patch
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    integer, intent(in) :: upland_ivt
+    integer, intent(in) :: lowland_ivt
+    !
+    ! !LOCAL VARIABLES:
+    integer :: p,c    ! indices
+    integer :: npatches_per_column
+    logical :: check_npatches = .true.
+
+    !------------------------------------------------------------------------
+
+    do c = bounds%begc, bounds%endc
+       if (col%is_hillslope_column(c)) then
+          npatches_per_column = 0
+          do p = col%patchi(c), col%patchf(c)
+             if(col%cold(c) == ispval) then
+                ! lowland
+                patch%itype(p) = lowland_ivt
+             else
+                ! upland
+                patch%itype(p) = upland_ivt
+             endif
+             ! update mxy as is done in initSubgridMod.add_patch
+             patch%mxy(p) = patch%itype(p) + (1 - natpft_lb)
+             
+             npatches_per_column = npatches_per_column + 1
+          enddo
+          if (check_npatches) then
+             if ((npatches_per_column /= 1) .and. masterproc) then
+                call endrun( 'ERROR:: number of patches per hillslope column not equal to 1'//errmsg(sourcefile, __LINE__) )
+             end if
+          endif
+       endif
+    enddo
+
+  end subroutine HillslopeSetLowlandUplandPfts
+
+  !------------------------------------------------------------------------
+  subroutine HillslopeDominantLowlandPft(bounds)
+    !
+    ! !DESCRIPTION: 
+    ! Reassign patch weights of each column based on each gridcell's
+    ! two most dominant pfts on the input dataset.
+    ! HillslopeTwoLargestPftIndices is called in surfrd_hillslope to
+    ! prepare the patch weights for this routine.
+    ! Assumes each column has a single pft.
+    ! Use largest weight for lowland, 2nd largest weight for uplands
+
+    !
+    ! !USES
+    use LandunitType    , only : lun                
+    use ColumnType      , only : col                
+    use decompMod       , only : get_clump_bounds, get_proc_clumps
+    use clm_varcon      , only : ispval
+    use PatchType       , only : patch
+    use pftconMod       , only : pftcon, ndllf_evr_tmp_tree, nc3_nonarctic_grass, nc4_grass
+    use array_utils     , only : find_k_max_indices
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    !
+    ! !LOCAL VARIABLES:
+    integer :: p,c    ! indices
+    integer :: plow, phigh
+    integer :: max_index(1)
+    integer, allocatable  :: max_indices(:)    ! largest weight pft indices
+    real(r8) :: sum_wtcol, sum_wtlun, sum_wtgrc
+
+    !------------------------------------------------------------------------
+
+    allocate(max_indices(2))
+    do c = bounds%begc,bounds%endc
+       if (col%is_hillslope_column(c)) then
+
+          ! if only one pft exists, find dominant pft index and set 2nd index to the same value
+          
+          if (size(patch%wtcol(col%patchi(c):col%patchf(c))) == 1) then
+             call find_k_max_indices(patch%wtcol(col%patchi(c):col%patchf(c)),1,1,max_index)
+             max_indices(1) = max_index(1) + (col%patchi(c) - 1)
+             max_indices(2) = max_indices(1)
+          else
+             call find_k_max_indices(patch%wtcol(col%patchi(c):col%patchf(c)),1,2,max_indices)
+             max_indices = max_indices + (col%patchi(c) - 1)
+          endif
+
+          sum_wtcol = sum(patch%wtcol(col%patchi(c):col%patchf(c)))
+          sum_wtlun = sum(patch%wtlunit(col%patchi(c):col%patchf(c)))
+          sum_wtgrc = sum(patch%wtgcell(col%patchi(c):col%patchf(c)))
+
+          patch%wtcol(col%patchi(c):col%patchf(c)) = 0._r8
+          patch%wtlunit(col%patchi(c):col%patchf(c)) = 0._r8
+          patch%wtgcell(col%patchi(c):col%patchf(c)) = 0._r8
+          
+          ! Put the highest stature vegetation on the lowland column
+          ! non-tree and tree       ; place tree on lowland
+          ! grass and shrub         ; place shrub on lowland
+          ! bare soil and vegetation; place vegetation on lowland
+          if ((.not. pftcon%is_tree(patch%itype(max_indices(1))) .and. pftcon%is_tree(patch%itype(max_indices(2)))) &
+               .or. (pftcon%is_grass(patch%itype(max_indices(1))) .and. pftcon%is_shrub(patch%itype(max_indices(2)))) &
+               .or. (patch%itype(max_indices(1)) == 0)) then
+             plow = max_indices(2)
+             phigh = max_indices(1)
+          else
+             plow = max_indices(1)
+             phigh = max_indices(2)
+          endif
+
+          ! Special cases (subjective)
+
+          ! if NET/BDT assign BDT to lowland
+          if ((patch%itype(max_indices(1)) == ndllf_evr_tmp_tree) .and. pftcon%is_tree(patch%itype(max_indices(2)))) then
+             plow = max_indices(2)        
+             phigh = max_indices(1)
+          endif
+          ! if C3/C4 assign C4 to lowland
+          if ((patch%itype(max_indices(1)) == nc4_grass) .and. (patch%itype(max_indices(2)) == nc3_nonarctic_grass)) then
+             plow = max_indices(1)        
+             phigh = max_indices(2)
+          endif
+          if ((patch%itype(max_indices(1)) == nc3_nonarctic_grass) .and. (patch%itype(max_indices(2)) == nc4_grass)) then
+             plow = max_indices(2)        
+             phigh = max_indices(1)
+          endif
+
+          if(col%cold(c) == ispval) then
+             ! lowland column
+             patch%wtcol(plow)   = sum_wtcol
+             patch%wtlunit(plow) = sum_wtlun
+             patch%wtgcell(plow) = sum_wtgrc
+          else
+             ! upland columns
+             patch%wtcol(phigh)   = sum_wtcol
+             patch%wtlunit(phigh) = sum_wtlun
+             patch%wtgcell(phigh) = sum_wtgrc
+          endif
+       endif
+    enddo    ! end loop c
+    deallocate(max_indices)
+    
+  end subroutine HillslopeDominantLowlandPft
+
+  !------------------------------------------------------------------------
+  subroutine HillslopePftFromFile(bounds,col_pftndx)
+    !
+    ! !DESCRIPTION: 
+    ! Reassign patch type using indices from surface data file
+    ! Assumes one patch per hillslope column
+    ! In preparation for this reassignment of patch type, only the
+    ! first patch was given a non-zero weight in surfrd_hillslope.
+    !
+    ! !USES
+    use ColumnType      , only : col                
+    use PatchType       , only : patch
+    use clm_varpar      , only : natpft_lb
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    integer, intent(in)           :: col_pftndx(:)
+    !
+    ! !LOCAL VARIABLES:
+    integer :: p,c    ! indices
+    integer :: npatches_per_column
+    logical :: check_npatches = .true.
+    
+    !------------------------------------------------------------------------
+
+    do c = bounds%begc, bounds%endc
+       if (col%is_hillslope_column(c)) then
+          ! In preparation for this re-weighting of patch type
+          ! only first patch was given a non-zero weight in surfrd_hillslope
+          npatches_per_column = 0
+          do p = col%patchi(c), col%patchf(c)
+             patch%itype(p) = col_pftndx(c)
+             ! update mxy as is done in initSubgridMod.add_patch
+             patch%mxy(p) = patch%itype(p) + (1 - natpft_lb)
+             npatches_per_column = npatches_per_column + 1
+          enddo
+          if (check_npatches) then
+             if ((npatches_per_column /= 1) .and. masterproc) then
+                call endrun( 'ERROR:: number of patches per hillslope column not equal to 1'//errmsg(sourcefile, __LINE__) )
+             end if
+          endif
+       endif
+    enddo
+
+  end subroutine HillslopePftFromFile
+
+  !-----------------------------------------------------------------------
+  subroutine HillslopeStreamOutflow(bounds, &
+       waterstatebulk_inst, waterfluxbulk_inst,streamflow_method)
+    !
+    ! !DESCRIPTION:
+    ! Calculate discharge from stream channel
+    !
+    ! !USES:
+    use LandunitType    , only : lun                
+    use GridcellType    , only : grc                
+    use ColumnType      , only : col                
+    use WaterFluxBulkType   , only : waterfluxbulk_type
+    use WaterStateBulkType  , only : waterstatebulk_type
+    use spmdMod         , only : masterproc
+    use clm_varcon      , only : spval, ispval, grlnd 
+    use landunit_varcon , only : istsoil
+    use ncdio_pio
+    use clm_time_manager , only : get_step_size_real
+     
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    integer,  intent(in)  :: streamflow_method
+    type(waterstatebulk_type), intent(inout) :: waterstatebulk_inst
+    type(waterfluxbulk_type),  intent(inout) :: waterfluxbulk_inst
+
+    integer               :: c, l, g, i, j
+    integer               :: nstep
+    real(r8) :: dtime                                     ! land model time step (sec)
+    real(r8)              :: cross_sectional_area         ! cross sectional area of stream water (m2)
+    real(r8)              :: stream_depth                 ! depth of stream water (m)
+    real(r8)              :: hydraulic_radius             ! cross sectional area divided by wetted perimeter (m)
+    real(r8)              :: flow_velocity                ! flow velocity (m/s)
+    real(r8)              :: overbank_area                ! area of water above bankfull (m2)
+    real(r8), parameter   :: manning_roughness = 0.03_r8  ! manning roughness
+    real(r8), parameter   :: manning_exponent  = 0.667_r8 ! manning exponent
+
+    integer, parameter    :: overbank_method = 1          ! method to treat overbank stream storage; 1 = increase dynamic slope, 2 = increase flow area cross section, 3 = remove instantaneously
+    character(len=*), parameter :: subname = 'HillslopeStreamOutflow'
+
+    !-----------------------------------------------------------------------
+    associate(                                                            & 
+         stream_water_volume     =>    waterstatebulk_inst%stream_water_volume_lun            , & ! Input:  [real(r8) (:)   ] stream water volume (m3)
+         volumetric_streamflow             =>    waterfluxbulk_inst%volumetric_streamflow_lun               &  ! Input:  [real(r8) (:)   ] stream water discharge (m3/s)
+         )
+
+      ! Get time step
+      dtime = get_step_size_real()
+
+      do l = bounds%begl,bounds%endl
+         volumetric_streamflow(l) = 0._r8
+         if(lun%itype(l) == istsoil .and. lun%active(l)) then
+            ! Streamflow calculated from Manning equation
+            if(streamflow_method == streamflow_manning) then
+               cross_sectional_area = stream_water_volume(l) &
+                    /lun%stream_channel_length(l)
+               stream_depth =  cross_sectional_area &
+                    /lun%stream_channel_width(l)
+               hydraulic_radius = cross_sectional_area &
+                    /(lun%stream_channel_width(l) + 2*stream_depth)
+
+               if(hydraulic_radius <= 0._r8) then
+                  volumetric_streamflow(l) = 0._r8
+               else
+                  flow_velocity = (hydraulic_radius)**manning_exponent &
+                       * sqrt(lun%stream_channel_slope(l)) &
+                       / manning_roughness
+                  ! overbank flow
+                  if (stream_depth > lun%stream_channel_depth(l)) then
+                     if (overbank_method  == 1) then
+                        ! try increasing dynamic slope
+                        volumetric_streamflow(l) = cross_sectional_area * flow_velocity &
+                             *(stream_depth/lun%stream_channel_depth(l))
+                     else if (overbank_method  == 2) then
+                        ! try increasing flow area cross section
+                        overbank_area = (stream_depth -lun%stream_channel_depth(l)) * 30._r8 * lun%stream_channel_width(l)
+                        volumetric_streamflow(l) = (cross_sectional_area + overbank_area) * flow_velocity
+                     else if (overbank_method  == 3) then
+                        ! try removing all overbank flow instantly
+                        volumetric_streamflow(l) = cross_sectional_area * flow_velocity &
+                             + (stream_depth-lun%stream_channel_depth(l)) &
+                             *lun%stream_channel_width(l)*lun%stream_channel_length(l)/dtime
+                     else
+                        if (masterproc) then
+                           call endrun( 'ERROR:: invalid overbank_method.'//errmsg(sourcefile, __LINE__) )
+                        end if
+                     endif
+                    
+                  else
+                     volumetric_streamflow(l) = cross_sectional_area * flow_velocity
+                  endif
+
+                  ! scale streamflow by number of channel reaches
+                  volumetric_streamflow(l) = volumetric_streamflow(l) * lun%stream_channel_number(l)
+
+                  volumetric_streamflow(l) = max(0._r8,min(volumetric_streamflow(l),stream_water_volume(l)/dtime))
+               endif
+            else
+               if (masterproc) then
+                  call endrun( 'ERROR:: invalid streamflow_method'//errmsg(sourcefile, __LINE__) )
+               end if
+            endif
+         endif ! end of istsoil
+      enddo    ! end of loop over landunits
+
+  end associate
+
+  end subroutine HillslopeStreamOutflow
+  
+  !-----------------------------------------------------------------------
+  subroutine HillslopeUpdateStreamWater(bounds, waterstatebulk_inst, &
+       waterfluxbulk_inst,waterdiagnosticbulk_inst)
+    !
+    ! !DESCRIPTION:
+    ! Calculate discharge from stream channel
+    !
+    ! !USES:
+    use LandunitType    , only : lun                
+    use GridcellType    , only : grc                
+    use ColumnType      , only : col                
+    use WaterFluxBulkType   , only : waterfluxbulk_type
+    use WaterStateBulkType  , only : waterstatebulk_type
+    use WaterDiagnosticBulkType  , only : waterdiagnosticbulk_type
+    use spmdMod         , only : masterproc
+    use clm_varcon      , only : spval, ispval, grlnd 
+    use landunit_varcon , only : istsoil
+    use clm_time_manager, only : get_step_size_real
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    type(waterstatebulk_type), intent(inout) :: waterstatebulk_inst
+    type(waterfluxbulk_type),  intent(inout) :: waterfluxbulk_inst
+    type(waterdiagnosticbulk_type), intent(out) :: waterdiagnosticbulk_inst
+    
+    integer               :: c, l, g, i, j
+    real(r8) :: qflx_surf_vol                           ! volumetric surface runoff (m3/s)
+    real(r8) :: qflx_drain_perched_vol                  ! volumetric perched saturated drainage (m3/s)
+    real(r8) :: qflx_drain_vol                          ! volumetric saturated drainage (m3/s)
+    real(r8) :: dtime                                   ! land model time step (sec)
+
+    character(len=*), parameter :: subname = 'HillslopeUpdateStreamWater'
+
+    !-----------------------------------------------------------------------
+    associate( & 
+         stream_water_volume     =>    waterstatebulk_inst%stream_water_volume_lun, & ! Input/Output:  [real(r8) (:)   ] stream water volume (m3)
+         volumetric_streamflow             =>    waterfluxbulk_inst%volumetric_streamflow_lun      ,    & ! Input:  [real(r8) (:)   ] stream water discharge (m3/s)
+         qflx_drain              =>    waterfluxbulk_inst%qflx_drain_col,           & ! Input:  [real(r8) (:)   ]  column level sub-surface runoff (mm H2O /s)
+         qflx_drain_perched      =>    waterfluxbulk_inst%qflx_drain_perched_col,   & ! Input:  [real(r8) (:)   ]  column level sub-surface runoff (mm H2O /s)
+         qflx_surf               =>    waterfluxbulk_inst%qflx_surf_col        ,    & ! Input: [real(r8) (:)   ]  total surface runoff (mm H2O /s)
+         stream_water_depth      =>    waterdiagnosticbulk_inst%stream_water_depth_lun   & ! Output:  [real(r8) (:)   ] stream water depth (m)
+         )
+
+       ! Get time step
+       dtime = get_step_size_real()
+
+       do l = bounds%begl,bounds%endl
+          if(lun%itype(l) == istsoil) then
+             g = lun%gridcell(l)
+             ! the drainage terms are 'net' quantities, so summing over
+             ! all columns in a hillslope is equivalent to the outflow
+             ! from the lowland column 
+             do c = lun%coli(l), lun%colf(l)
+                if (col%is_hillslope_column(c) .and. col%active(c)) then
+                   qflx_surf_vol = qflx_surf(c)*1.e-3_r8 &
+                        *(grc%area(g)*1.e6_r8*col%wtgcell(c))
+                   qflx_drain_perched_vol = qflx_drain_perched(c)*1.e-3_r8 &
+                        *(grc%area(g)*1.e6_r8*col%wtgcell(c))
+                   qflx_drain_vol = qflx_drain(c)*1.e-3_r8 &
+                        *(grc%area(g)*1.e6_r8*col%wtgcell(c))
+
+                   stream_water_volume(l) = stream_water_volume(l) &
+                        + (qflx_drain_perched_vol &
+                         + qflx_drain_vol + qflx_surf_vol) * dtime
+                endif
+             enddo
+             stream_water_volume(l) = stream_water_volume(l) &
+                  - volumetric_streamflow(l) * dtime
+             
+             ! account for negative drainage (via searchforwater in soilhydrology)
+             if(stream_water_volume(l) < 0._r8) then
+                volumetric_streamflow(l) = volumetric_streamflow(l) + stream_water_volume(l)/dtime
+                stream_water_volume(l) = 0._r8
+             endif
+
+             stream_water_depth(l) = stream_water_volume(l) &
+                  /lun%stream_channel_length(l) &
+                  /lun%stream_channel_width(l)
+
+          endif
+       enddo
+      
+    end associate
+
+  end subroutine HillslopeUpdateStreamWater
+  
+end module HillslopeHydrologyMod
diff --git a/src/biogeophys/HydrologyDrainageMod.F90 b/src/biogeophys/HydrologyDrainageMod.F90
index 31ffc817a..ec7c7c76e 100644
--- a/src/biogeophys/HydrologyDrainageMod.F90
+++ b/src/biogeophys/HydrologyDrainageMod.F90
@@ -22,7 +22,7 @@ module HydrologyDrainageMod
   use GlacierSurfaceMassBalanceMod, only : glacier_smb_type
   use TotalWaterAndHeatMod, only : ComputeWaterMassNonLake
   use LandunitType      , only : lun                
-  use ColumnType        , only : col                
+  use ColumnType        , only : col   
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -35,12 +35,13 @@ module HydrologyDrainageMod
 contains
 
   !-----------------------------------------------------------------------
+
   subroutine HydrologyDrainage(bounds,               &
        num_nolakec, filter_nolakec,                  &
        num_hydrologyc, filter_hydrologyc,            &
        num_urbanc, filter_urbanc,                    &
        num_do_smb_c, filter_do_smb_c,                &
-       atm2lnd_inst, glc2lnd_inst, temperature_inst, &
+       glc2lnd_inst, temperature_inst, &
        soilhydrology_inst, soilstate_inst, waterstatebulk_inst, &
        waterdiagnosticbulk_inst, waterbalancebulk_inst, waterfluxbulk_inst, &
        wateratm2lndbulk_inst, glacier_smb_inst)
@@ -52,11 +53,14 @@ contains
     use landunit_varcon  , only : istwet, istsoil, istice, istcrop
     use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv, icol_sunwall, icol_shadewall
     use clm_varcon       , only : denh2o, denice
-    use clm_varctl       , only : use_vichydro
+    use clm_varctl       , only : use_vichydro, use_hillslope, use_hillslope_routing
+
     use clm_varpar       , only : nlevgrnd, nlevurb
     use clm_time_manager , only : get_step_size_real, get_nstep
-    use SoilHydrologyMod , only : CLMVICMap, Drainage, PerchedLateralFlow, LateralFlowPowerLaw
+    use SoilHydrologyMod , only : CLMVICMap, Drainage, PerchedLateralFlow, SubsurfaceLateralFlow
     use SoilWaterMovementMod , only : use_aquifer_layer
+    use HillslopeHydrologyMod, only : streamflow_manning, HillslopeStreamOutflow, HillslopeUpdateStreamWater
+    
     !
     ! !ARGUMENTS:
     type(bounds_type)        , intent(in)    :: bounds               
@@ -66,23 +70,24 @@ contains
     integer                  , intent(in)    :: filter_hydrologyc(:) ! column filter for soil points
     integer                  , intent(in)    :: num_urbanc           ! number of column urban points in column filter
     integer                  , intent(in)    :: filter_urbanc(:)     ! column filter for urban points
-    integer                  , intent(in)    :: num_do_smb_c         ! number of columns in which SMB is calculated, in column filter    
-    integer                  , intent(in)    :: filter_do_smb_c(:)   ! column filter for bare landwhere SMB is calculated
-    type(atm2lnd_type)       , intent(in)    :: atm2lnd_inst
+    integer                  , intent(in)    :: num_do_smb_c         ! number of bareland columns in which SMB is calculated, in column filter    
+    integer                  , intent(in)    :: filter_do_smb_c(:)   ! column filter for bare land SMB columns      
+
     type(glc2lnd_type)       , intent(in)    :: glc2lnd_inst
     type(temperature_type)   , intent(in)    :: temperature_inst
     type(soilhydrology_type) , intent(inout) :: soilhydrology_inst
     type(soilstate_type)     , intent(inout) :: soilstate_inst
     type(waterstatebulk_type)    , intent(inout) :: waterstatebulk_inst
     type(waterdiagnosticbulk_type)    , intent(inout) :: waterdiagnosticbulk_inst
-    type(waterbalance_type)    , intent(inout) :: waterbalancebulk_inst
+    type(waterbalance_type)      , intent(inout) :: waterbalancebulk_inst
     type(waterfluxbulk_type)     , intent(inout) :: waterfluxbulk_inst
-    type(wateratm2lndbulk_type)     , intent(inout) :: wateratm2lndbulk_inst
+    type(wateratm2lndbulk_type)  , intent(inout) :: wateratm2lndbulk_inst
     type(glacier_smb_type)   , intent(in)    :: glacier_smb_inst
     !
     ! !LOCAL VARIABLES:
     integer  :: g,l,c,j,fc                 ! indices
     real(r8) :: dtime                      ! land model time step (sec)
+
     !-----------------------------------------------------------------------
 
     associate(                                                            & ! Input: layer thickness depth (m)  
@@ -112,6 +117,7 @@ contains
          qflx_surf          => waterfluxbulk_inst%qflx_surf_col          , & ! surface runoff (mm H2O /s)      
          qflx_infl          => waterfluxbulk_inst%qflx_infl_col          , & ! infiltration (mm H2O /s)   
          qflx_qrgwl         => waterfluxbulk_inst%qflx_qrgwl_col         , & ! qflx_surf at glaciers, wetlands, lakes
+         qflx_latflow_out   => waterfluxbulk_inst%qflx_latflow_out_col   , & ! lateral subsurface flow
          qflx_runoff        => waterfluxbulk_inst%qflx_runoff_col        , & ! total runoff (qflx_drain+qflx_surf+qflx_qrgwl) (mm H2O /s)
          qflx_runoff_u      => waterfluxbulk_inst%qflx_runoff_u_col      , & ! Urban total runoff (qflx_drain+qflx_surf) (mm H2O /s)
          qflx_runoff_r      => waterfluxbulk_inst%qflx_runoff_r_col      , & ! Rural total runoff (qflx_drain+qflx_surf+qflx_qrgwl) (mm H2O /s)
@@ -135,16 +141,26 @@ contains
       else
          
          call PerchedLateralFlow(bounds, num_hydrologyc, filter_hydrologyc, &
-              num_urbanc, filter_urbanc,&
-              soilhydrology_inst, soilstate_inst, &
-              waterstatebulk_inst, waterfluxbulk_inst)
-
+                 soilhydrology_inst, soilstate_inst, &
+                 waterstatebulk_inst, waterfluxbulk_inst, &
+                 wateratm2lndbulk_inst)
+         call SubsurfaceLateralFlow(bounds, &
+                 num_hydrologyc, filter_hydrologyc, &
+                 num_urbanc, filter_urbanc,&
+                 soilhydrology_inst, soilstate_inst, &
+                 waterstatebulk_inst, waterfluxbulk_inst, &
+                 wateratm2lndbulk_inst)
+
+         if(use_hillslope_routing) then 
+            call HillslopeStreamOutflow(bounds,&
+                 waterstatebulk_inst, waterfluxbulk_inst, &
+                 streamflow_method=streamflow_manning)
+            
+            call HillslopeUpdateStreamWater(bounds, &
+                 waterstatebulk_inst, waterfluxbulk_inst, &
+                 waterdiagnosticbulk_inst)
+         endif
          
-         call LateralFlowPowerLaw(bounds, num_hydrologyc, filter_hydrologyc, &
-              num_urbanc, filter_urbanc,&
-              soilhydrology_inst, soilstate_inst, &
-              waterstatebulk_inst, waterfluxbulk_inst)
-
       endif
 
       do j = 1, nlevgrnd
@@ -175,6 +191,7 @@ contains
       ! Determine wetland and land ice hydrology (must be placed here
       ! since need snow updated from CombineSnowLayers)
 
+
       do fc = 1,num_nolakec
          c = filter_nolakec(fc)
          l = col%landunit(c)
@@ -182,6 +199,7 @@ contains
 
          if (lun%itype(l)==istwet .or. lun%itype(l)==istice) then
 
+            qflx_latflow_out(c)   = 0._r8
             qflx_drain(c)         = 0._r8
             qflx_drain_perched(c) = 0._r8
             qflx_surf(c)          = 0._r8
diff --git a/src/biogeophys/HydrologyNoDrainageMod.F90 b/src/biogeophys/HydrologyNoDrainageMod.F90
index 8f294c652..c7086d847 100644
--- a/src/biogeophys/HydrologyNoDrainageMod.F90
+++ b/src/biogeophys/HydrologyNoDrainageMod.F90
@@ -36,7 +36,7 @@ Module HydrologyNoDrainageMod
   !
   ! !PUBLIC TYPES:
   implicit none
-  save
+  save 
   !
   ! !PUBLIC MEMBER FUNCTIONS:
   public  :: CalcAndWithdrawIrrigationFluxes  ! Calculates irrigation withdrawal fluxes and withdraws from groundwater
@@ -131,6 +131,7 @@ contains
   end subroutine HandleNewSnow
 
   !-----------------------------------------------------------------------
+
   subroutine HydrologyNoDrainage(bounds, &
        num_nolakec, filter_nolakec, &
        num_hydrologyc, filter_hydrologyc, &
@@ -164,7 +165,7 @@ contains
     use SoilWaterMovementMod , only : SoilWater
     use SoilWaterRetentionCurveMod, only : soil_water_retention_curve_type
     use SoilWaterMovementMod , only : use_aquifer_layer
-    use SoilWaterPlantSinkMod , only : Compute_EffecRootFrac_And_VertTranSink
+    use SoilWaterPlantSinkMod, only : Compute_EffecRootFrac_And_VertTranSink
     use SurfaceWaterMod      , only : UpdateH2osfc
 
     !
@@ -181,6 +182,7 @@ contains
     integer                  , intent(inout) :: num_nosnowc          ! number of column non-snow points
     integer                  , intent(inout) :: filter_nosnowc(:)    ! column filter for non-snow points
     type(hlm_fates_interface_type), intent(inout) :: clm_fates
+
     type(atm2lnd_type)       , intent(in)    :: atm2lnd_inst
     type(soilstate_type)     , intent(inout) :: soilstate_inst
     type(energyflux_type)    , intent(in)    :: energyflux_inst
diff --git a/src/biogeophys/IrrigationMod.F90 b/src/biogeophys/IrrigationMod.F90
index 27cf050dd..faea42561 100644
--- a/src/biogeophys/IrrigationMod.F90
+++ b/src/biogeophys/IrrigationMod.F90
@@ -362,6 +362,7 @@ contains
     use spmdMod        , only : masterproc, mpicom
     use shr_mpi_mod    , only : shr_mpi_bcast
     use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
+
     !
     ! !ARGUMENTS:
     class(irrigation_type) , intent(inout) :: this
diff --git a/src/biogeophys/SaturatedExcessRunoffMod.F90 b/src/biogeophys/SaturatedExcessRunoffMod.F90
index 309d25146..5643a9539 100644
--- a/src/biogeophys/SaturatedExcessRunoffMod.F90
+++ b/src/biogeophys/SaturatedExcessRunoffMod.F90
@@ -233,10 +233,8 @@ contains
 
          qflx_sat_excess_surf   =>    waterfluxbulk_inst%qflx_sat_excess_surf_col, & ! Output: [real(r8) (:)   ]  surface runoff due to saturated surface (mm H2O /s)
          qflx_floodc            =>    waterfluxbulk_inst%qflx_floodc_col         , & ! Input:  [real(r8) (:)   ]  column flux of flood water from RTM
-         qflx_rain_plus_snomelt => waterfluxbulk_inst%qflx_rain_plus_snomelt_col , & ! Input: [real(r8) (:)   ] rain plus snow melt falling on the soil (mm/s)
+         qflx_rain_plus_snomelt => waterfluxbulk_inst%qflx_rain_plus_snomelt_col   & ! Input: [real(r8) (:)   ] rain plus snow melt falling on the soil (mm/s)
 
-         origflag               =>    soilhydrology_inst%origflag            , & ! Input:  logical
-         fracice                =>    soilhydrology_inst%fracice_col           & ! Input:  [real(r8) (:,:) ]  fractional impermeability (-)
          )
 
     ! ------------------------------------------------------------------------
@@ -275,29 +273,14 @@ contains
     ! qflx_rain_plus_snomelt in control
     ! ------------------------------------------------------------------------
     
-    if (origflag == 1) then
-       if (this%fsat_method == FSAT_METHOD_VIC) then
-          ! NOTE(wjs, 2017-07-12) I'm not sure if it's the VIC fsat method per se that
-          ! is incompatible with origflag, or some other aspect of VIC: The original
-          ! check was for origflag == 1 and use_vichydro, which also appears in error
-          ! checks elsewhere.
-          call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(sourcefile, __LINE__))
-       end if
-       do fc = 1, num_hydrologyc
-          c = filter_hydrologyc(fc)
-          fcov(c) = (1._r8 - fracice(c,1)) * fsat(c) + fracice(c,1)
-          qflx_sat_excess_surf(c) = fcov(c) * qflx_rain_plus_snomelt(c)
-       end do
-    else
-       do fc = 1, num_hydrologyc
-          c = filter_hydrologyc(fc)
-          ! only send fast runoff directly to streams
-          qflx_sat_excess_surf(c) = fsat(c) * qflx_rain_plus_snomelt(c)
-
-          ! Set fcov just to have it on the history file
-          fcov(c) = fsat(c)
-       end do
-    end if
+    do fc = 1, num_hydrologyc
+       c = filter_hydrologyc(fc)
+       ! only send fast runoff directly to streams
+       qflx_sat_excess_surf(c) = fsat(c) * qflx_rain_plus_snomelt(c)
+       
+       ! Set fcov just to have it on the history file
+       fcov(c) = fsat(c)
+    end do
 
     ! ------------------------------------------------------------------------
     ! For urban columns, send flood water flux to runoff
diff --git a/src/biogeophys/SoilHydrologyMod.F90 b/src/biogeophys/SoilHydrologyMod.F90
index 4bc6a784d..7d131d2cf 100644
--- a/src/biogeophys/SoilHydrologyMod.F90
+++ b/src/biogeophys/SoilHydrologyMod.F90
@@ -10,6 +10,7 @@ module SoilHydrologyMod
   use abortutils        , only : endrun
   use decompMod         , only : bounds_type, subgrid_level_column
   use clm_varctl        , only : iulog, use_vichydro
+  use clm_varcon        , only : ispval
   use clm_varcon        , only : denh2o, denice, rpi
   use clm_varcon        , only : pondmx_urban
   use clm_varpar        , only : nlevsoi, nlevgrnd, nlayer, nlayert
@@ -31,7 +32,8 @@ module SoilHydrologyMod
   use TemperatureType   , only : temperature_type
   use LandunitType      , only : lun                
   use ColumnType        , only : column_type, col
-  use PatchType         , only : patch                
+  use PatchType         , only : patch
+
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -51,7 +53,7 @@ module SoilHydrologyMod
   public :: PerchedWaterTable    ! Calculate perched water table
   public :: PerchedLateralFlow   ! Calculate lateral flow from perched saturated zone
   public :: ThetaBasedWaterTable ! Calculate water table from soil moisture state
-  public :: LateralFlowPowerLaw  ! Calculate lateral flow based on power law drainage function
+  public :: SubsurfaceLateralFlow ! Calculate subsurface lateral flow from saturated zone
   public :: RenewCondensation    ! Misc. corrections
   public :: CalcIrrigWithdrawals ! Calculate irrigation withdrawals from groundwater by layer
   public :: WithdrawGroundwaterIrrigation   ! Remove groundwater irrigation from unconfined and confined aquifers
@@ -63,17 +65,112 @@ module SoilHydrologyMod
      real(r8) :: perched_baseflow_scalar ! Scalar multiplier for perched base flow rate (kg/m2/s)
      real(r8) :: e_ice                   ! Soil ice impedance factor (unitless)
   end type params_type
-  type(params_type), private ::  params_inst
+  type(params_type), public ::  params_inst
   
   !-----------------------------------------------------------------------
   real(r8), private   :: baseflow_scalar = 1.e-2_r8
   real(r8), parameter :: tolerance = 1.e-12_r8                   ! tolerance for checking whether sublimation is greater than ice in top soil layer
 
+  integer, private :: head_gradient_method    ! Method for calculating hillslope saturated head gradient
+  integer, private :: transmissivity_method   ! Method for calculating transmissivity of hillslope columns
+
+  ! Head gradient methods
+  integer, parameter, private :: kinematic = 0
+  integer, parameter, private :: darcy     = 1
+  ! Transmissivity methods
+  integer, parameter, private :: uniform_transmissivity = 0
+  integer, parameter, private :: layersum = 1
+
   character(len=*), parameter, private :: sourcefile = &
        __FILE__
 
 contains
 
+  !-----------------------------------------------------------------------
+  subroutine hillslope_hydrology_ReadNML(NLFilename)
+    !
+    ! DESCRIPTION
+    ! read in hillslope hydrology namelist variables related to
+    ! subsurface lateral flow
+    !
+    ! !USES:
+    use abortutils      , only : endrun
+    use fileutils       , only : getavu, relavu
+    use spmdMod         , only : mpicom, masterproc
+    use shr_mpi_mod     , only : shr_mpi_bcast
+    use clm_varctl      , only : iulog
+    use clm_nlUtilsMod  , only : find_nlgroup_name
+
+    ! !ARGUMENTS:
+    implicit none
+    character(len=*), intent(in) :: NLFilename ! Namelist filename
+    !--------------------------------------------------------------------
+    integer            :: nu_nml                     ! unit for namelist file
+    integer            :: nml_error                  ! namelist i/o error flag
+    character(len=*), parameter :: nmlname = 'hillslope_hydrology_inparm'
+    character(*), parameter    :: subName = "('hillslope_hydrology_ReadNML')"
+    character(len=50) :: hillslope_head_gradient_method  = 'Darcy'    ! head gradient method string
+    character(len=50) :: hillslope_transmissivity_method = 'LayerSum' ! transmissivity method string
+    !-----------------------------------------------------------------------
+
+! MUST agree with name in namelist and read statement
+    namelist /hillslope_hydrology_inparm/ &
+         hillslope_head_gradient_method,  &
+         hillslope_transmissivity_method
+    
+    ! Default values for namelist
+    head_gradient_method    = darcy
+    transmissivity_method   = layersum
+    
+    ! Read hillslope hydrology namelist
+    if (masterproc) then
+       nu_nml = getavu()
+       open( nu_nml, file=trim(NLFilename), status='old', iostat=nml_error )
+       call find_nlgroup_name(nu_nml, 'hillslope_hydrology_inparm', status=nml_error)
+       if (nml_error == 0) then
+          read(nu_nml, nml=hillslope_hydrology_inparm,iostat=nml_error)
+          if (nml_error /= 0) then
+             call endrun(subname // ':: ERROR reading hillslope hydrology namelist')
+          end if
+       else
+          call endrun(subname // ':: ERROR reading hillslope hydrology namelist')
+       end if
+       close(nu_nml)
+       call relavu( nu_nml )
+
+       ! Convert namelist strings to numerical values
+       if (      trim(hillslope_head_gradient_method) == 'Kinematic' ) then
+          head_gradient_method = kinematic
+       else if ( trim(hillslope_head_gradient_method) == 'Darcy'     ) then
+          head_gradient_method = darcy
+       else
+          call endrun(msg="ERROR bad value for hillslope_head_gradient_method in "//nmlname//"namelist"//errmsg(sourcefile, __LINE__))
+       end if
+
+       if (      trim(hillslope_transmissivity_method) == 'Uniform' ) then
+          transmissivity_method = uniform_transmissivity
+       else if ( trim(hillslope_transmissivity_method) == 'LayerSum') then
+          transmissivity_method = layersum
+       else
+          call endrun(msg="ERROR bad value for hillslope_transmissivity_method in "//nmlname//"namelist"//errmsg(sourcefile, __LINE__))
+       end if
+
+    endif
+
+    call shr_mpi_bcast(head_gradient_method, mpicom)
+    call shr_mpi_bcast(transmissivity_method, mpicom)
+
+    if (masterproc) then
+
+       write(iulog,*) ' '
+       write(iulog,*) 'hillslope_hydrology lateral flow settings:'
+       write(iulog,*) '  hillslope_head_gradient_method  = ',hillslope_head_gradient_method
+       write(iulog,*) '  hillslope_transmissivity_method = ',hillslope_transmissivity_method
+
+    endif
+
+  end subroutine hillslope_hydrology_ReadNML
+
   !-----------------------------------------------------------------------
   subroutine readParams( ncid )
     !
@@ -157,6 +254,8 @@ contains
 
   end subroutine soilhydReadNML
 
+
+  
   !-----------------------------------------------------------------------
   subroutine SetSoilWaterFractions(bounds, num_hydrologyc, filter_hydrologyc, &
        soilhydrology_inst, soilstate_inst, waterstatebulk_inst)
@@ -193,10 +292,7 @@ contains
          h2osoi_liq       =>    waterstatebulk_inst%h2osoi_liq_col  , & ! Input:  [real(r8) (:,:) ]  liquid water (kg/m2)
          h2osoi_ice       =>    waterstatebulk_inst%h2osoi_ice_col  , & ! Input:  [real(r8) (:,:) ]  ice water (kg/m2)
          excess_ice       =>    waterstatebulk_inst%excess_ice_col  , & ! Input:  [real(r8) (:,:) ]  excess ice (kg/m2)
-
-         origflag         =>    soilhydrology_inst%origflag         , & ! Input:  logical
-         icefrac          =>    soilhydrology_inst%icefrac_col      , & ! Output: [real(r8) (:,:) ]                                                  
-         fracice          =>    soilhydrology_inst%fracice_col        & ! Output: [real(r8) (:,:) ]  fractional impermeability (-)                    
+         icefrac          =>    soilhydrology_inst%icefrac_col        & ! Output: [real(r8) (:,:) ]                                                  
          )
 
     do j = 1,nlevsoi
@@ -210,15 +306,6 @@ contains
           eff_porosity(c,j) = max(0.01_r8,watsat(c,j)-vol_ice(c,j))
           icefrac(c,j) = min(1._r8,vol_ice(c,j)/watsat(c,j))
 
-          ! fracice is only used in code with origflag == 1. For this calculation, we use
-          ! the version of icefrac that was used in this original hydrology code.
-          if (h2osoi_ice(c,j) == 0._r8) then
-             ! Avoid possible divide by zero (in case h2osoi_liq(c,j) is also 0)
-             icefrac_orig = 0._r8
-          else
-             icefrac_orig = min(1._r8,h2osoi_ice(c,j)/(h2osoi_ice(c,j)+h2osoi_liq(c,j)))
-          end if
-          fracice(c,j) = max(0._r8,exp(-3._r8*(1._r8-icefrac_orig))- exp(-3._r8))/(1.0_r8-exp(-3._r8))
        end do
     end do
 
@@ -601,7 +688,6 @@ contains
      real(r8) :: xs(bounds%begc:bounds%endc)             ! water needed to bring soil moisture to watmin (mm)
      real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevsoi) ! layer thickness (mm)
      integer  :: jwt(bounds%begc:bounds%endc)            ! index of the soil layer right above the water table (-)
-     real(r8) :: rsub_bot(bounds%begc:bounds%endc)       ! subsurface runoff - bottom drainage (mm/s)
      real(r8) :: rsub_top(bounds%begc:bounds%endc)       ! subsurface runoff - topographic control (mm/s)
      real(r8) :: xsi(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer i (mm)
      real(r8) :: rous                                    ! aquifer yield (-)
@@ -610,7 +696,6 @@ contains
      real(r8) :: s_node                                  ! soil wetness (-)
      real(r8) :: dzsum                                   ! summation of dzmm of layers below water table (mm)
      real(r8) :: icefracsum                              ! summation of icefrac*dzmm of layers below water table (-)
-     real(r8) :: fracice_rsub(bounds%begc:bounds%endc)   ! fractional impermeability of soil layers (-)
      real(r8) :: ka                                      ! hydraulic conductivity of the aquifer (mm/s)
      real(r8) :: available_h2osoi_liq                    ! available soil liquid water in a layer
      real(r8) :: imped
@@ -657,7 +742,6 @@ contains
           frost_table        =>    soilhydrology_inst%frost_table_col    , & ! Output: [real(r8) (:)   ]  frost table depth (m)                             
           wa                 =>    waterstatebulk_inst%wa_col             , & ! Output: [real(r8) (:)   ]  water in the unconfined aquifer (mm)              
           qcharge            =>    soilhydrology_inst%qcharge_col        , & ! Input:  [real(r8) (:)   ]  aquifer recharge rate (mm/s)                      
-          origflag           =>    soilhydrology_inst%origflag           , & ! Input:  logical  
           
           qflx_drain         =>    waterfluxbulk_inst%qflx_drain_col         , & ! Output: [real(r8) (:)   ]  sub-surface runoff (mm H2O /s)
           qflx_drain_perched =>    waterfluxbulk_inst%qflx_drain_perched_col , & ! Output: [real(r8) (:)   ]  perched wt sub-surface runoff (mm H2O /s)         
@@ -792,8 +876,7 @@ contains
 
           !===================  water table above frost table  =============================
           ! if water table is above frost table, do not use topmodel baseflow formulation
-          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz &
-               .and. origflag == 0) then
+          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz) then
           else 
              !===================  water table below frost table  =============================
              !--  compute possible perched water table *and* groundwater table afterwards
@@ -865,7 +948,6 @@ contains
      real(r8) :: xs(bounds%begc:bounds%endc)             ! water needed to bring soil moisture to watmin (mm)
      real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevsoi) ! layer thickness (mm)
      integer  :: jwt(bounds%begc:bounds%endc)            ! index of the soil layer right above the water table (-)
-     real(r8) :: rsub_bot(bounds%begc:bounds%endc)       ! subsurface runoff - bottom drainage (mm/s)
      real(r8) :: rsub_top(bounds%begc:bounds%endc)       ! subsurface runoff - topographic control (mm/s)
      real(r8) :: fff(bounds%begc:bounds%endc)            ! decay factor (m-1)
      real(r8) :: xsi(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer i (mm)
@@ -880,7 +962,6 @@ contains
      real(r8) :: s_node                                  ! soil wetness (-)
      real(r8) :: dzsum                                   ! summation of dzmm of layers below water table (mm)
      real(r8) :: icefracsum                              ! summation of icefrac*dzmm of layers below water table (-)
-     real(r8) :: fracice_rsub(bounds%begc:bounds%endc)   ! fractional impermeability of soil layers (-)
      real(r8) :: ka                                      ! hydraulic conductivity of the aquifer (mm/s)
      real(r8) :: dza                                     ! fff*(zwt-z(jwt)) (-)
      real(r8) :: available_h2osoi_liq                    ! available soil liquid water in a layer
@@ -943,7 +1024,6 @@ contains
           wa                 =>    waterstatebulk_inst%wa_col             , & ! Input:  [real(r8) (:)   ] water in the unconfined aquifer (mm)              
           ice                =>    soilhydrology_inst%ice_col            , & ! Input:  [real(r8) (:,:) ] soil layer moisture (mm)                         
           qcharge            =>    soilhydrology_inst%qcharge_col        , & ! Input:  [real(r8) (:)   ] aquifer recharge rate (mm/s)                      
-          origflag           =>    soilhydrology_inst%origflag           , & ! Input:  logical
           h2osfcflag         =>    soilhydrology_inst%h2osfcflag         , & ! Input:  integer
           
           qflx_snwcp_liq     =>    waterfluxbulk_inst%qflx_snwcp_liq_col     , & ! Output: [real(r8) (:)   ] excess liquid h2o due to snow capping (outgoing) (mm H2O /s) [+]
@@ -981,11 +1061,8 @@ contains
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           qflx_drain(c)    = 0._r8 
-          rsub_bot(c)      = 0._r8
           qflx_rsub_sat(c) = 0._r8
           rsub_top(c)      = 0._r8
-          fracice_rsub(c)  = 0._r8
-
        end do
 
        ! The layer index of the first unsaturated layer, i.e., the layer right above
@@ -1039,8 +1116,7 @@ contains
           !===================  water table above frost table  =============================
           ! if water table is above frost table, do not use topmodel baseflow formulation
 
-          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz &
-               .and. origflag == 0) then
+          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz) then
              ! compute drainage from perched saturated region
              wtsub = 0._r8
              q_perch = 0._r8
@@ -1130,9 +1206,6 @@ contains
                 qflx_drain_perched(c) = q_perch_max * q_perch &
                      *(frost_table(c) - zwt_perched(c))
 
-                ! no perched water table drainage if using original formulation
-                if(origflag == 1) qflx_drain_perched(c) = 0._r8
-
                 ! remove drainage from perched saturated layers
                 rsub_top_tot = -  qflx_drain_perched(c) * dtime
                 do k = k_perch+1, k_frz
@@ -1168,25 +1241,15 @@ contains
                 icefracsum = icefracsum + icefrac(c,j) * dzmm(c,j)
              end do
              ! add ice impedance factor to baseflow
-             if(origflag == 1) then 
-                if (use_vichydro) then
-                   call endrun(msg="VICHYDRO is not available for origflag=1"//errmsg(sourcefile, __LINE__))
-                else
-                   fracice_rsub(c) = max(0._r8,exp(-3._r8*(1._r8-(icefracsum/dzsum))) &
-                        - exp(-3._r8))/(1.0_r8-exp(-3._r8))
-                   imped=(1._r8 - fracice_rsub(c))
-                   rsub_top_max = 5.5e-3_r8
-                end if
+             if (use_vichydro) then
+                imped=10._r8**(-params_inst%e_ice*min(1.0_r8,ice(c,nlayer)/max_moist(c,nlayer)))
+                dsmax_tmp(c) = Dsmax(c) * dtime/ secspday !mm/day->mm/dtime
+                rsub_top_max = dsmax_tmp(c)
              else
-                if (use_vichydro) then
-                   imped=10._r8**(-params_inst%e_ice*min(1.0_r8,ice(c,nlayer)/max_moist(c,nlayer)))
-                   dsmax_tmp(c) = Dsmax(c) * dtime/ secspday !mm/day->mm/dtime
-                   rsub_top_max = dsmax_tmp(c)
-                else
-                   imped=10._r8**(-params_inst%e_ice*(icefracsum/dzsum))
-                   rsub_top_max = 10._r8 * sin((rpi/180.) * col%topo_slope(c))
-                end if
-             endif
+                imped=10._r8**(-params_inst%e_ice*(icefracsum/dzsum))
+                rsub_top_max = 10._r8 * sin((rpi/180.) * col%topo_slope(c))
+             end if
+
              if (use_vichydro) then
                 ! ARNO model for the bottom soil layer (based on bottom soil layer 
                 ! moisture from previous time step
@@ -1525,7 +1588,7 @@ contains
      ! Calculate watertable, considering aquifer recharge but no drainage.
      !
      ! !USES:
-     use clm_varcon       , only : pondmx, tfrz, watmin,denice,denh2o
+     use clm_varcon       , only : tfrz, denice, denh2o
      use column_varcon    , only : icol_roof, icol_road_imperv
      !
      ! !ARGUMENTS:
@@ -1537,25 +1600,21 @@ contains
      type(soilhydrology_type) , intent(inout) :: soilhydrology_inst
      type(soilstate_type)     , intent(in)    :: soilstate_inst
      type(temperature_type)   , intent(in)    :: temperature_inst
-     type(waterstatebulk_type)    , intent(inout) :: waterstatebulk_inst
-     type(waterfluxbulk_type)     , intent(inout) :: waterfluxbulk_inst
+     type(waterstatebulk_type), intent(inout) :: waterstatebulk_inst
+     type(waterfluxbulk_type) , intent(inout) :: waterfluxbulk_inst
      !
      ! !LOCAL VARIABLES:
-     integer  :: c,j,fc,i                                ! indices
-     real(r8) :: s_y
-     integer  :: k,k_frz,k_perch,k_zwt
-     real(r8) :: sat_lev
-     real(r8) :: s1
-     real(r8) :: s2
-     real(r8) :: m
-     real(r8) :: b
-     integer  :: sat_flag
+     integer  :: c,j,fc,i                       ! indices
+     integer  :: k,k_frz,k_perch,k_zwt          ! indices
+     real(r8) :: s1, s2                         ! temporary moisture values
+     real(r8) :: m, b                           ! slope and intercept
+     real(r8), parameter :: sat_lev = 0.9       ! saturation value used to identify saturated layers
      !-----------------------------------------------------------------------
 
      associate(                                                            & 
           dz                 =>    col%dz                                , & ! Input:  [real(r8) (:,:) ]  layer depth (m)                                 
           z                  =>    col%z                                 , & ! Input:  [real(r8) (:,:) ]  layer depth (m)                                 
-          zi                 =>    col%zi                                , & ! Input:  [real(r8) (:,:) ] interface level below a "z" level (m)
+          zi                 =>    col%zi                                , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)
           t_soisno           =>    temperature_inst%t_soisno_col         , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)                       
 
           h2osoi_liq         =>    waterstatebulk_inst%h2osoi_liq_col        , & ! Output: [real(r8) (:,:) ]  liquid water (kg/m2)                            
@@ -1564,8 +1623,7 @@ contains
           watsat             =>    soilstate_inst%watsat_col             , & ! Input:  [real(r8) (:,:) ] volumetric soil water at saturation (porosity)  
           zwt                =>    soilhydrology_inst%zwt_col            , & ! Output: [real(r8) (:)   ]  water table depth (m)                             
           zwt_perched        =>    soilhydrology_inst%zwt_perched_col    , & ! Output: [real(r8) (:)   ]  perched water table depth (m)                     
-          frost_table        =>    soilhydrology_inst%frost_table_col    , & ! Output: [real(r8) (:)   ]  frost table depth (m)                             
-          origflag           =>    soilhydrology_inst%origflag            & ! Input:  logical  
+          frost_table        =>    soilhydrology_inst%frost_table_col      & ! Output: [real(r8) (:)   ]  frost table depth (m)                             
           )
 
        ! calculate perched water table location 
@@ -1574,14 +1632,14 @@ contains
 
           ! define frost table as first frozen layer with unfrozen layer above it
           if(t_soisno(c,1) > tfrz) then 
-             k_frz=nlevsoi
+             k_frz = nlevsoi
           else
-             k_frz=1
+             k_frz = 1
           endif
 
-          do k=2, nlevsoi
+          do k=2,nlevsoi
              if (t_soisno(c,k-1) > tfrz .and. t_soisno(c,k) <= tfrz) then
-                k_frz=k
+                k_frz = k
                 exit
              endif
           enddo
@@ -1594,17 +1652,14 @@ contains
 
           !=======  water table above frost table  ===================
           ! if water table is above frost table, do nothing 
-          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz &
-               .and. origflag == 0) then
+          if (zwt(c) < frost_table(c) .and. t_soisno(c,k_frz) <= tfrz) then
           else if (k_frz > 1) then
              !==========  water table below frost table  ============
              ! locate perched water table from bottom up starting at 
              ! frost table sat_lev is an arbitrary saturation level 
              ! used to determine perched water table
 
-             sat_lev = 0.9
-
-             k_perch = 1
+             k_perch=1
              do k=k_frz,1,-1
                 h2osoi_vol(c,k) = h2osoi_liq(c,k)/(dz(c,k)*denh2o) &
                      + h2osoi_ice(c,k)/(dz(c,k)*denice)
@@ -1617,9 +1672,9 @@ contains
 
              ! if frost_table = nlevsoi, check temperature of layer, 
              ! and only compute perched water table if frozen
-             if (t_soisno(c,k_frz) > tfrz) k_perch=k_frz
+             if (t_soisno(c,k_frz) > tfrz) k_perch = k_frz
 
-             ! if perched water table exists
+             ! if perched water table exists above frost table, 
              ! interpolate between k_perch and k_perch+1 to find 
              ! perched water table height
              if (k_frz > k_perch) then
@@ -1635,8 +1690,7 @@ contains
                    b=z(c,k_perch+1)-m*s2
                    zwt_perched(c)=max(0._r8,m*sat_lev+b)
                 endif
-
-             endif !k_frz > k_perch 
+             endif
           endif
        end do
 
@@ -1644,51 +1698,56 @@ contains
 
    end subroutine PerchedWaterTable
 
-!#4
+!#4   
    !-----------------------------------------------------------------------
-   subroutine PerchedLateralFlow(bounds, num_hydrologyc, filter_hydrologyc, &
-        num_urbanc, filter_urbanc, soilhydrology_inst, soilstate_inst, &
-        waterstatebulk_inst, waterfluxbulk_inst)
+   subroutine PerchedLateralFlow(bounds, num_hydrologyc, &
+        filter_hydrologyc, soilhydrology_inst, soilstate_inst, &
+        waterstatebulk_inst, waterfluxbulk_inst, wateratm2lndbulk_inst)
      !
      ! !DESCRIPTION:
      ! Calculate subsurface drainage from perched saturated zone
      !
      ! !USES:
      use clm_varcon       , only : pondmx, tfrz, watmin,rpi, secspday, nlvic
-     use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv
+     use LandunitType     , only : lun                
+     use landunit_varcon  , only : istsoil
+     use clm_varctl       , only : use_hillslope_routing
 
      !
      ! !ARGUMENTS:
-     type(bounds_type)        , intent(in)    :: bounds               
-     integer                  , intent(in)    :: num_hydrologyc       ! number of column soil points in column filter
-     integer                  , intent(in)    :: num_urbanc           ! number of column urban points in column filter
-     integer                  , intent(in)    :: filter_urbanc(:)     ! column filter for urban points
-     integer                  , intent(in)    :: filter_hydrologyc(:) ! column filter for soil points
-     type(soilstate_type)     , intent(in)    :: soilstate_inst
-     type(soilhydrology_type) , intent(inout) :: soilhydrology_inst
-     type(waterstatebulk_type)    , intent(inout) :: waterstatebulk_inst
-     type(waterfluxbulk_type)     , intent(inout) :: waterfluxbulk_inst
+     type(bounds_type)        , intent(in)      :: bounds               
+     integer                  , intent(in)      :: num_hydrologyc       ! number of column soil points in column filter
+     integer                  , intent(in)      :: filter_hydrologyc(:) ! column filter for soil points
+     type(soilstate_type)       , intent(in)    :: soilstate_inst
+     type(soilhydrology_type)   , intent(inout) :: soilhydrology_inst
+     type(waterstatebulk_type)  , intent(inout) :: waterstatebulk_inst
+     type(waterfluxbulk_type)   , intent(inout) :: waterfluxbulk_inst
+     type(wateratm2lndbulk_type), intent(in)    :: wateratm2lndbulk_inst
      !
      ! !LOCAL VARIABLES:
-     character(len=32) :: subname = 'PerchedLateralFlow' ! subroutine name
-     integer  :: c,j,fc,i                                ! indices
-     real(r8) :: dtime                                   ! land model time step (sec)
-     real(r8) :: wtsub                                   ! summation of hk*dzmm for layers below water table (mm**2/s)
-     real(r8) :: h2osoi_vol
-     real(r8) :: drainage_tot
-     real(r8) :: drainage_layer
-     real(r8) :: s_y
-     integer  :: k
-     integer  :: k_frost(bounds%begc:bounds%endc)
-     integer  :: k_perch(bounds%begc:bounds%endc)
-     real(r8) :: sat_lev
-     real(r8) :: s1, s2, m, b
-     real(r8) :: q_perch
-     real(r8) :: q_perch_max
-     !-----------------------------------------------------------------------
+     character(len=32) :: subname = 'PerchedLateralFlowHillslope' ! subroutine name
+     integer  :: c,fc,k,l,g                       ! indices
+     real(r8) :: dtime                            ! land model time step (sec)
+     real(r8) :: drainage_tot                     ! total amount of drainage to be removed from the column (mm/s)
+     real(r8) :: drainage_layer                   ! amount of drainage to be removed from current layer (mm/s)
+     real(r8) :: s_y                              ! specific yield (unitless)
+     integer  :: k_frost(bounds%begc:bounds%endc) ! indices identifying frost table layer
+     integer  :: k_perch(bounds%begc:bounds%endc) ! indices identifying perched water table layer
+     real(r8) :: wtsub                            ! temporary variable
+     real(r8) :: q_perch                          ! transmissivity (mm2/s)
+     real(r8) :: q_perch_max                      ! baseflow coefficient
+     real(r8) :: stream_water_depth               ! depth of water in stream channel (m)
+     real(r8) :: stream_channel_depth             ! depth of stream channel (m)
+
+     real(r8) :: transmis                         ! transmissivity (m2/s)
+     real(r8) :: head_gradient                    ! head gradient (m/m)
+     real(r8), parameter :: k_anisotropic = 1._r8 ! anisotropy factor
+     integer  :: c0, c_src, c_dst                 ! indices
+     real(r8) :: qflx_drain_perched_vol(bounds%begc:bounds%endc)   ! volumetric lateral subsurface flow through active layer [m3/s]
+     real(r8) :: qflx_drain_perched_out(bounds%begc:bounds%endc)   ! lateral subsurface flow through active layer [mm/s]
 
      associate(                                                            & 
-          nbedrock           =>    col%nbedrock                          , & ! Input:  [real(r8) (:,:) ]  depth to bedrock (m)
+          nbedrock           =>    col%nbedrock                          , & ! Input:  [real(r8) (:,:) ]  depth to bedrock (m)           
           z                  =>    col%z                                 , & ! Input:  [real(r8) (:,:) ] layer depth (m)                                 
           zi                 =>    col%zi                                , & ! Input:  [real(r8) (:,:) ] interface level below a "z" level (m)           
           dz                 =>    col%dz                                , & ! Input:  [real(r8) (:,:) ] layer depth (m)                                 
@@ -1700,7 +1759,11 @@ contains
           frost_table        =>    soilhydrology_inst%frost_table_col    , & ! Input:  [real(r8) (:)   ] frost table depth (m)                             
           zwt                =>    soilhydrology_inst%zwt_col            , & ! Input:  [real(r8) (:)   ] water table depth (m)                             
           zwt_perched        =>    soilhydrology_inst%zwt_perched_col    , & ! Input:  [real(r8) (:)   ] perched water table depth (m)                     
-          
+          tdepth             =>    wateratm2lndbulk_inst%tdepth_grc      , & ! Input:  [real(r8) (:)   ]  depth of water in tributary channels (m)
+          tdepth_bankfull    =>    wateratm2lndbulk_inst%tdepthmax_grc   , & ! Input:  [real(r8) (:)   ]  bankfull depth of tributary channels (m)
+          stream_water_volume =>    waterstatebulk_inst%stream_water_volume_lun , & ! Input:  [real(r8) (:)   ] stream water volume (m3)
+
+
           qflx_drain_perched =>    waterfluxbulk_inst%qflx_drain_perched_col , & ! Output: [real(r8) (:)   ] perched wt sub-surface runoff (mm H2O /s)         
 
           h2osoi_liq         =>    waterstatebulk_inst%h2osoi_liq_col        , & ! Output: [real(r8) (:,:) ] liquid water (kg/m2)                            
@@ -1711,21 +1774,21 @@ contains
 
        dtime = get_step_size_real()
 
-       ! locate frost table and perched water table
+       ! locate frost table and perched water table   
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           k_frost(c) = nbedrock(c)
           k_perch(c) = nbedrock(c)
-          do k = 1, nbedrock(c)
+          do k=1,nbedrock(c)
              if (frost_table(c) >= zi(c,k-1) .and. frost_table(c) < zi(c,k)) then
-                k_frost(c) = k
+                k_frost(c)=k
                 exit
              endif
           enddo
-
-          do k = 1, nbedrock(c)
+          
+          do k=1,nbedrock(c)
              if (zwt_perched(c) >= zi(c,k-1) .and. zwt_perched(c) < zi(c,k)) then
-                k_perch(c) = k
+                k_perch(c)=k
                 exit
              endif
           enddo
@@ -1734,52 +1797,187 @@ contains
        ! compute drainage from perched saturated region
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
+          l = col%landunit(c)
+          g = col%gridcell(c)
+          qflx_drain_perched(c)     = 0._r8
+          qflx_drain_perched_out(c) = 0._r8
+          qflx_drain_perched_vol(c) = 0._r8
 
-          qflx_drain_perched(c) = 0._r8
           if (frost_table(c) > zwt_perched(c)) then
+             ! Hillslope columns
+             if (col%is_hillslope_column(c) .and. col%active(c)) then 
+
+                ! calculate head gradient
+
+                if (head_gradient_method == kinematic) then
+                   ! kinematic wave approximation
+                   head_gradient = col%hill_slope(c)
+                else if (head_gradient_method == darcy) then
+                   ! darcy's law 
+                   if (col%cold(c) /= ispval) then
+                      head_gradient = (col%hill_elev(c)-zwt_perched(c)) &
+                           - (col%hill_elev(col%cold(c))-zwt_perched(col%cold(c)))
+                      head_gradient = head_gradient / (col%hill_distance(c) - col%hill_distance(col%cold(c)))
+                   else
+                      if(use_hillslope_routing) then
+                         stream_water_depth = stream_water_volume(l) &
+                              /lun%stream_channel_length(l)/lun%stream_channel_width(l)
+                         stream_channel_depth = lun%stream_channel_depth(l)
+                      else
+                         stream_water_depth = tdepth(g)
+                         stream_channel_depth = tdepth_bankfull(g)
+                      endif
+
+                      ! flow between channel and lowest column
+                      ! bankfull height is defined to be zero
+                      head_gradient = (col%hill_elev(c)-zwt_perched(c)) &
+                           ! ignore overbankfull storage
+                           - max(min((stream_water_depth - stream_channel_depth),0._r8), &
+                           (col%hill_elev(c)-frost_table(c)))
+
+                      head_gradient = head_gradient / (col%hill_distance(c))
+
+                      ! head_gradient cannot be negative when channel is empty
+                      if (stream_water_depth <= 0._r8) then
+                         head_gradient = max(head_gradient, 0._r8)
+                      endif
+                   endif
+                else                 
+                   call endrun(msg="head_gradient_method must be kinematic or darcy"//errmsg(sourcefile, __LINE__))
+                endif
 
-             ! specify maximum drainage rate
-             q_perch_max = params_inst%perched_baseflow_scalar &
-                  * sin(col%topo_slope(c) * (rpi/180._r8))
+                ! Determine source and destination columns
+                if (head_gradient >= 0._r8) then
+                   c_src = c
+                   c_dst = col%cold(c)
+                else
+                   c_src = col%cold(c)
+                   c_dst = c
+                endif
 
-             wtsub = 0._r8
-             q_perch = 0._r8
-             do k = k_perch(c), k_frost(c)-1
-                q_perch = q_perch + hksat(c,k)*dz(c,k)
-                wtsub = wtsub + dz(c,k)
-             end do
-             if (wtsub > 0._r8) q_perch = q_perch/wtsub
+                ! Calculate transmissivity of source column
+                transmis = 0._r8
+
+                if (transmissivity_method == layersum) then
+                   if (head_gradient_method == kinematic) then
+                      if(k_perch(c_src) < k_frost(c_src)) then
+                         do k = k_perch(c_src), k_frost(c_src)-1
+                            if(k == k_perch(c_src)) then
+                               transmis = transmis + 1.e-3_r8*hksat(c_src,k)*(zi(c_src,k) - zwt_perched(c_src))
+                            else
+                               transmis = transmis + 1.e-3_r8*hksat(c_src,k)*dz(c_src,k)
+                            endif
+                         enddo
+                      endif
+                   else if (head_gradient_method == darcy) then
+                      if(c_src == ispval) then
+                         ! lowland, losing stream (c_src == ispval)
+                         ! use hksat of c_dst for transmissivity
+                         transmis = (1.e-3_r8*hksat(c,k_perch(c_dst)))*stream_water_depth
+                      else
+                         ! if k_perch equals k_frost, no perched saturated zone exists
+                         if(k_perch(c_src) < k_frost(c_src)) then
+                            do k = k_perch(c_src), k_frost(c_src)-1
+                               if(k == k_perch(c_src)) then
+                                  transmis = transmis + 1.e-3_r8*hksat(c_src,k)*(zi(c_src,k) - zwt_perched(c_src))
+                               else
+                                  if(c_dst == ispval) then 
+                                     ! lowland, gaining stream
+                                     ! only include layers above stream channel bottom
+                                     if ((col%hill_elev(c_src)-z(c_src,k)) > (-stream_channel_depth)) then
+                                        
+                                        transmis = transmis + 1.e-3_r8*hksat(c_src,k)*dz(c_src,k)
+                                     endif
+                                  else
+                                     ! uplands
+                                     ! only include layers above dst water table elevation
+                                     if ((col%hill_elev(c_src)-z(c_src,k)) > (col%hill_elev(c_dst) - zwt_perched(c_dst))) then
+                                        
+                                        transmis = transmis + 1.e-3_r8*hksat(c_src,k)*dz(c_src,k)
+                                     endif
+                                  endif
+                               endif
+                            enddo
+                         endif
+                      endif
+                   endif
+                else if (transmissivity_method == uniform_transmissivity) then
+                   ! constant conductivity based on shallowest saturated layer hydraulic conductivity
+                   transmis = (1.e-3_r8*hksat(c_src,k_perch(c_src))) &
+                        *(zi(c_src,k_frost(c_src)) - zwt_perched(c_src) )
+                endif
 
-             qflx_drain_perched(c) = q_perch_max * q_perch &
-                  *(frost_table(c) - zwt_perched(c))
+                ! adjust by 'anisotropy factor'
+                transmis = k_anisotropic*transmis
+
+                qflx_drain_perched_vol(c) = transmis*col%hill_width(c)*head_gradient
+                qflx_drain_perched_out(c) = 1.e3_r8*(qflx_drain_perched_vol(c)/col%hill_area(c))
+ 
+             else
+                ! Non-hillslope columns
+                ! specify maximum drainage rate
+                q_perch_max = params_inst%perched_baseflow_scalar &
+                     * sin(col%topo_slope(c) * (rpi/180._r8))
+
+                wtsub = 0._r8
+                q_perch = 0._r8
+                ! this should be consistent with hillslope and k_perch=k_frost means no
+                ! saturated zone; should probably change q_perch to tranmis and change
+                ! units and q_perch_max
+                do k = k_perch(c), k_frost(c)-1
+                   q_perch = q_perch + hksat(c,k)*dz(c,k)
+                   wtsub = wtsub + dz(c,k)
+                end do
+                if (wtsub > 0._r8) q_perch = q_perch/wtsub
+                
+                qflx_drain_perched_out(c) = q_perch_max * q_perch &
+                     *(frost_table(c) - zwt_perched(c))
+             endif
           endif
+
        enddo
              
+       ! compute net drainage from perched saturated region
+       do fc = 1, num_hydrologyc
+          c = filter_hydrologyc(fc)
+          ! drainage-out
+          qflx_drain_perched(c) = qflx_drain_perched(c) + qflx_drain_perched_out(c)
+          if (col%is_hillslope_column(c) .and. col%active(c)) then
+             ! drainage-in
+             if (col%cold(c) /= ispval) then
+                qflx_drain_perched(col%cold(c)) = &
+                     qflx_drain_perched(col%cold(c)) - &
+                     1.e3_r8*(qflx_drain_perched_vol(c))/col%hill_area(col%cold(c))
+             endif
+          endif
+       enddo
+
        ! remove drainage from soil moisture storage
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           
           ! remove drainage from perched saturated layers
-          drainage_tot =  qflx_drain_perched(c) * dtime
-
+          drainage_tot = qflx_drain_perched(c) * dtime
+          ! ignore frozen layer (k_frost)
           do k = k_perch(c), k_frost(c)-1
+
              s_y = watsat(c,k) &
                   * ( 1. - (1.+1.e3*zwt_perched(c)/sucsat(c,k))**(-1./bsw(c,k)))
              s_y=max(s_y,params_inst%aq_sp_yield_min)
-
-             if (k == k_perch(c)) then
+             if (k==k_perch(c)) then
                 drainage_layer=min(drainage_tot,(s_y*(zi(c,k) - zwt_perched(c))*1.e3))
              else
                 drainage_layer=min(drainage_tot,(s_y*(dz(c,k))*1.e3))
              endif
-
+             
              drainage_layer=max(drainage_layer,0._r8)
              drainage_tot = drainage_tot - drainage_layer
              h2osoi_liq(c,k) = h2osoi_liq(c,k) - drainage_layer
+             
           enddo
 
-          ! if drainage_tot is greater than available water
-          ! (above frost table), then decrease qflx_drain_perched
+          ! if drainage_tot is greater than available water 
+          ! (above frost table), then decrease qflx_drain_perched 
           ! by residual amount for water balance
           qflx_drain_perched(c) = qflx_drain_perched(c) - drainage_tot/dtime
        enddo
@@ -1845,7 +2043,7 @@ contains
 
           ! locate water table from bottom up starting at bottom of soil column
           ! sat_lev is an arbitrary saturation level used to determine water table
-          sat_lev=0.9
+          sat_lev = 0.9
           
           k_zwt=nbedrock(c)
           sat_flag=1 !will remain unchanged if all layers at saturation
@@ -1886,17 +2084,24 @@ contains
 
 !#6
    !-----------------------------------------------------------------------
-   subroutine LateralFlowPowerLaw(bounds, num_hydrologyc, filter_hydrologyc, &
+   subroutine SubsurfaceLateralFlow(bounds,  & 
+        num_hydrologyc, filter_hydrologyc,  &
         num_urbanc, filter_urbanc,soilhydrology_inst, soilstate_inst, &
-        waterstatebulk_inst, waterfluxbulk_inst)
+        waterstatebulk_inst, waterfluxbulk_inst, wateratm2lndbulk_inst)
      !
      ! !DESCRIPTION:
      ! Calculate subsurface drainage
      !
      ! !USES:
-     use clm_varcon       , only : pondmx, watmin,rpi, secspday, nlvic
-     use column_varcon    , only : icol_roof, icol_road_imperv, icol_road_perv
-     use GridcellType     , only : grc                
+     use clm_time_manager , only : get_step_size
+     use clm_varpar       , only : nlevsoi, nlevgrnd, nlayer, nlayert
+     use clm_varctl       , only : nhillslope
+     use clm_varcon       , only : pondmx, watmin,rpi, secspday
+     use column_varcon    , only : icol_road_perv
+     use abortutils       , only : endrun
+     use GridcellType     , only : grc  
+     use landunit_varcon  , only : istsoil, istcrop
+     use clm_varctl       , only : use_hillslope_routing
 
      !
      ! !ARGUMENTS:
@@ -1906,47 +2111,46 @@ contains
      integer                  , intent(in)    :: filter_urbanc(:)     ! column filter for urban points
      integer                  , intent(in)    :: filter_hydrologyc(:) ! column filter for soil points
      type(soilstate_type)     , intent(in)    :: soilstate_inst
+     type(wateratm2lndbulk_type)       , intent(in)    :: wateratm2lndbulk_inst
      type(soilhydrology_type) , intent(inout) :: soilhydrology_inst
-     type(waterstatebulk_type)    , intent(inout) :: waterstatebulk_inst
-     type(waterfluxbulk_type)     , intent(inout) :: waterfluxbulk_inst
+     type(waterstatebulk_type), intent(inout) :: waterstatebulk_inst
+     type(waterfluxbulk_type) , intent(inout) :: waterfluxbulk_inst
+
      !
      ! !LOCAL VARIABLES:
-     character(len=32) :: subname = 'Drainage'           ! subroutine name
-     integer  :: c,j,fc,i                                ! indices
+     character(len=32) :: subname = 'SubsurfaceLateralFlow' ! subroutine name
+     integer  :: c,j,fc,i,l,g                            ! indices
      real(r8) :: dtime                                   ! land model time step (sec)
      real(r8) :: xs(bounds%begc:bounds%endc)             ! water needed to bring soil moisture to watmin (mm)
      real(r8) :: dzmm(bounds%begc:bounds%endc,1:nlevsoi) ! layer thickness (mm)
      integer  :: jwt(bounds%begc:bounds%endc)            ! index of the soil layer right above the water table (-)
-     real(r8) :: rsub_bot(bounds%begc:bounds%endc)       ! subsurface runoff - bottom drainage (mm/s)
-     real(r8) :: rsub_top(bounds%begc:bounds%endc)       ! subsurface runoff - topographic control (mm/s)
+     real(r8) :: drainage(bounds%begc:bounds%endc)       ! subsurface drainage (mm/s)
      real(r8) :: xsi(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer i (mm)
-     real(r8) :: xsia(bounds%begc:bounds%endc)           ! available pore space at layer i (mm)
      real(r8) :: xs1(bounds%begc:bounds%endc)            ! excess soil water above saturation at layer 1 (mm)
-     real(r8) :: smpfz(1:nlevsoi)                        ! matric potential of layer right above water table (mm)
-     real(r8) :: wtsub                                   ! summation of hk*dzmm for layers below water table (mm**2/s)
      real(r8) :: dzsum                                   ! summation of dzmm of layers below water table (mm)
      real(r8) :: icefracsum                              ! summation of icefrac*dzmm of layers below water table (-)
-     real(r8) :: fracice_rsub(bounds%begc:bounds%endc)   ! fractional impermeability of soil layers (-)
+     real(r8) :: ice_imped_col(bounds%begc:bounds%endc)  ! column average hydraulic conductivity reduction due to presence of soil ice (-)
+     real(r8) :: ice_imped(bounds%begc:bounds%endc,1:nlevsoi) ! hydraulic conductivity reduction due to presence of soil ice (-)
      real(r8) :: available_h2osoi_liq                    ! available soil liquid water in a layer
-     real(r8) :: h2osoi_vol
-     real(r8) :: imped
-     real(r8) :: rsub_top_tot
-     real(r8) :: rsub_top_layer
-     real(r8) :: theta_unsat
-     real(r8) :: f_unsat
-     real(r8) :: s_y
-     integer  :: k
-     real(r8) :: s1
-     real(r8) :: s2
-     real(r8) :: m
-     real(r8) :: b
-     real(r8) :: vol_ice
-     real(r8) :: dsmax_tmp(bounds%begc:bounds%endc)       ! temporary variable for ARNO subsurface runoff calculation
-     real(r8) :: rsub_tmp                 ! temporary variable for ARNO subsurface runoff calculation
-     real(r8) :: frac                     ! temporary variable for ARNO subsurface runoff calculation
-     real(r8) :: rel_moist                ! relative moisture, temporary variable
-     real(r8) :: wtsub_vic                ! summation of hk*dzmm for layers in the third VIC layer
-     integer :: g
+     real(r8) :: h2osoi_vol                              ! volumetric water content (mm3/mm3)
+     real(r8) :: drainage_tot                            ! total drainage to be removed from column (mm)
+     real(r8) :: drainage_layer                          ! drainage to be removed from current layer (mm)
+     real(r8) :: s_y                                     ! specific yield (unitless)
+     real(r8) :: vol_ice                          ! volumetric ice content (mm3/mm3)
+     logical, parameter :: no_lateral_flow = .false.    ! flag for testing
+     real(r8) :: transmis                         ! transmissivity (m2/s)
+     real(r8) :: head_gradient                    ! hydraulic head gradient (m/m)
+     real(r8) :: stream_water_depth               ! depth of water in stream channel (m)
+     real(r8) :: stream_channel_depth             ! depth of stream channel (m)
+     real(r8) :: available_stream_water           ! stream water (m3)
+     real(r8), parameter :: n_baseflow = 1        ! drainage power law exponent
+     real(r8), parameter :: k_anisotropic = 1._r8 ! anisotropy scalar
+     real(r8) :: qflx_latflow_out_vol(bounds%begc:bounds%endc) ! volumetric lateral flow (m3/s)
+     real(r8) :: qflx_net_latflow(bounds%begc:bounds%endc)     ! net lateral flow in column (mm/s)
+     real(r8) :: qflx_latflow_avg(bounds%begc:bounds%endc)     ! average lateral flow (mm/s)
+     real(r8) :: larea                            ! area of hillslope in landunit
+     integer  :: c0, c_src, c_dst                 ! indices
+     
      !-----------------------------------------------------------------------
 
      associate(                                                            & 
@@ -1962,28 +2166,21 @@ contains
           watsat             =>    soilstate_inst%watsat_col             , & ! Input:  [real(r8) (:,:) ] volumetric soil water at saturation (porosity)  
           eff_porosity       =>    soilstate_inst%eff_porosity_col       , & ! Input:  [real(r8) (:,:) ] effective porosity = porosity - vol_ice         
           hk_l               =>    soilstate_inst%hk_l_col               , & ! Input:  [real(r8) (:,:) ] hydraulic conductivity (mm/s)                    
+          qflx_latflow_out   =>    waterfluxbulk_inst%qflx_latflow_out_col, & ! Output: [real(r8) (:)   ] lateral saturated outflow (mm/s)
+          qflx_latflow_in    =>    waterfluxbulk_inst%qflx_latflow_in_col, & ! Output: [real(r8) (:)   ]  lateral saturated inflow (mm/s)
+          volumetric_discharge =>  waterfluxbulk_inst%volumetric_discharge_col , & ! Output: [real(r8) (:)   ]  discharge from column (m3/s)
+
+          tdepth             =>    wateratm2lndbulk_inst%tdepth_grc      , & ! Input:  [real(r8) (:)   ]  depth of water in tributary channels (m)
+          tdepth_bankfull    =>    wateratm2lndbulk_inst%tdepthmax_grc   , & ! Input:  [real(r8) (:)   ]  bankfull depth of tributary channels (m)
 
           depth              =>    soilhydrology_inst%depth_col          , & ! Input:  [real(r8) (:,:) ] VIC soil depth                                   
-          c_param            =>    soilhydrology_inst%c_param_col        , & ! Input:  [real(r8) (:)   ] baseflow exponent (Qb)                             
-          Dsmax              =>    soilhydrology_inst%dsmax_col          , & ! Input:  [real(r8) (:)   ] max. velocity of baseflow (mm/day)
-          max_moist          =>    soilhydrology_inst%max_moist_col      , & ! Input:  [real(r8) (:,:) ] maximum soil moisture (ice + liq)
-          moist              =>    soilhydrology_inst%moist_col          , & ! Input:  [real(r8) (:,:) ] soil layer moisture (mm)                         
-          Ds                 =>    soilhydrology_inst%ds_col             , & ! Input:  [real(r8) (:)   ] fracton of Dsmax where non-linear baseflow begins
-          Wsvic              =>    soilhydrology_inst%Wsvic_col          , & ! Input:  [real(r8) (:)   ] fraction of maximum soil moisutre where non-liear base flow occurs
           icefrac            =>    soilhydrology_inst%icefrac_col        , & ! Output: [real(r8) (:,:) ] fraction of ice in layer                         
           frost_table        =>    soilhydrology_inst%frost_table_col    , & ! Input:  [real(r8) (:)   ] frost table depth (m)                             
           zwt                =>    soilhydrology_inst%zwt_col            , & ! Input:  [real(r8) (:)   ] water table depth (m)                             
-          wa                 =>    waterstatebulk_inst%wa_col             , & ! Input:  [real(r8) (:)   ] water in the unconfined aquifer (mm)              
-          ice                =>    soilhydrology_inst%ice_col            , & ! Input:  [real(r8) (:,:) ] soil layer moisture (mm)                         
-          qcharge            =>    soilhydrology_inst%qcharge_col        , & ! Input:  [real(r8) (:)   ] aquifer recharge rate (mm/s)                      
-          origflag           =>    soilhydrology_inst%origflag           , & ! Input:  logical
-          h2osfcflag         =>    soilhydrology_inst%h2osfcflag         , & ! Input:  integer
+          stream_water_volume =>    waterstatebulk_inst%stream_water_volume_lun, & ! Input:  [real(r8) (:)   ] stream water volume (m3)
           
           qflx_snwcp_liq     =>    waterfluxbulk_inst%qflx_snwcp_liq_col     , & ! Output: [real(r8) (:)   ] excess rainfall due to snow capping (mm H2O /s) [+]
           qflx_ice_runoff_xs =>    waterfluxbulk_inst%qflx_ice_runoff_xs_col , & ! Output: [real(r8) (:)   ] solid runoff from excess ice in soil (mm H2O /s) [+]
-          qflx_liqdew_to_top_layer      => waterfluxbulk_inst%qflx_liqdew_to_top_layer_col     , & ! Output: [real(r8) (:)   ] rate of liquid water deposited on top soil or snow layer (dew) (mm H2O /s) [+]    
-          qflx_soliddew_to_top_layer    => waterfluxbulk_inst%qflx_soliddew_to_top_layer_col   , & ! Output: [real(r8) (:)   ] rate of solid water deposited on top soil or snow layer (frost) (mm H2O /s) [+]      
-          qflx_solidevap_from_top_layer => waterfluxbulk_inst%qflx_solidevap_from_top_layer_col, & ! Output: [real(r8) (:)   ] rate of ice evaporated from top soil or snow layer (sublimation) (mm H2O /s) [+]   
           qflx_drain         =>    waterfluxbulk_inst%qflx_drain_col         , & ! Output: [real(r8) (:)   ] sub-surface runoff (mm H2O /s)                    
           qflx_qrgwl         =>    waterfluxbulk_inst%qflx_qrgwl_col         , & ! Output: [real(r8) (:)   ] qflx_surf at glaciers, wetlands, lakes (mm H2O /s)
           qflx_rsub_sat      =>    waterfluxbulk_inst%qflx_rsub_sat_col      , & ! Output: [real(r8) (:)   ] soil saturation excess [mm h2o/s]                 
@@ -2003,7 +2200,8 @@ contains
              dzmm(c,j) = dz(c,j)*1.e3_r8
 
              vol_ice = min(watsat(c,j), h2osoi_ice(c,j)/(dz(c,j)*denice))
-             icefrac(c,j) = min(1._r8,vol_ice/watsat(c,j))          
+             icefrac(c,j) = min(1._r8,vol_ice/watsat(c,j))
+             ice_imped(c,j)=10._r8**(-params_inst%e_ice*icefrac(c,j))
           end do
        end do
 
@@ -2012,80 +2210,298 @@ contains
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
           qflx_drain(c)    = 0._r8 
-          rsub_bot(c)      = 0._r8
           qflx_rsub_sat(c) = 0._r8
-          rsub_top(c)      = 0._r8
-          fracice_rsub(c)  = 0._r8
-       end do
-
-       ! The layer index of the first unsaturated layer, 
-       ! i.e., the layer right above the water table
-
-       do fc = 1, num_hydrologyc
-          c = filter_hydrologyc(fc)
-          jwt(c) = nlevsoi
-          ! allow jwt to equal zero when zwt is in top layer
-          do j = 1,nlevsoi
-             if(zwt(c) <= zi(c,j)) then
-                jwt(c) = j-1
-                exit
-             end if
-          enddo
-       end do
-
-       !-- Topographic runoff  -------------------------
-       do fc = 1, num_hydrologyc
-          c = filter_hydrologyc(fc)
-
-          dzsum = 0._r8
-          icefracsum = 0._r8
-          do j = max(jwt(c),1), nlevsoi
-             dzsum  = dzsum + dzmm(c,j)
-             icefracsum = icefracsum + icefrac(c,j) * dzmm(c,j)
-          end do
-          imped=10._r8**(-params_inst%e_ice*(icefracsum/dzsum))
-          !@@
-          ! baseflow is power law expression relative to bedrock layer
-          if(zwt(c) <= zi(c,nbedrock(c))) then 
-             rsub_top(c)    = imped * baseflow_scalar * tan(rpi/180._r8*col%topo_slope(c))* &
-                              (zi(c,nbedrock(c)) - zwt(c))**(params_inst%n_baseflow)
-          else
-             rsub_top(c) = 0._r8
-          endif
-
-          !--  Now remove water via rsub_top
-          rsub_top_tot = - rsub_top(c)* dtime
-
-          !should never be positive... but include for completeness
-          if(rsub_top_tot > 0.) then !rising water table
-             
-             call endrun(subgrid_index=c, subgrid_level=subgrid_level_column, &
-                  msg="RSUB_TOP IS POSITIVE in Drainage!"//errmsg(sourcefile, __LINE__))
-             
+          drainage(c)      = 0._r8
+          qflx_latflow_in(c) = 0._r8
+          qflx_latflow_out(c) = 0._r8
+          qflx_net_latflow(c) = 0._r8
+          volumetric_discharge(c)       = 0._r8
+          qflx_latflow_out_vol(c) = 0._r8
+      end do
+
+      ! The layer index of the first unsaturated layer, 
+      ! i.e., the layer right above the water table
+
+      do fc = 1, num_hydrologyc
+         c = filter_hydrologyc(fc)
+         jwt(c) = nlevsoi
+         ! allow jwt to equal zero when zwt is in top layer
+         do j = 1,nlevsoi
+            if(zwt(c) <= zi(c,j)) then
+               jwt(c) = j-1
+               exit
+            end if
+         enddo
+      end do
+
+      ! Calculate ice impedance factor (after jwt calculated)
+      do fc = 1, num_hydrologyc
+         c = filter_hydrologyc(fc)
+         dzsum = 0._r8
+         icefracsum = 0._r8
+         do j = max(jwt(c),1), nlevsoi
+            dzsum  = dzsum + dzmm(c,j)
+            icefracsum = icefracsum + icefrac(c,j) * dzmm(c,j)
+         end do
+         ice_imped_col(c)=10._r8**(-params_inst%e_ice*(icefracsum/dzsum))
+      enddo
+
+      do fc = 1, num_hydrologyc
+         c = filter_hydrologyc(fc)
+         l = col%landunit(c)
+         g = col%gridcell(c)
+         ! Hillslope columns
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+
+            ! method for calculating head gradient
+            if (head_gradient_method == kinematic) then
+               head_gradient = col%hill_slope(c)
+            else if (head_gradient_method == darcy) then
+               if (col%cold(c) /= ispval) then
+                  head_gradient = (col%hill_elev(c)-zwt(c)) &
+                       - (col%hill_elev(col%cold(c))-zwt(col%cold(c)))
+                  head_gradient = head_gradient / (col%hill_distance(c) - col%hill_distance(col%cold(c)))
+               else
+                  if(use_hillslope_routing) then
+                     stream_water_depth = stream_water_volume(l) &
+                          /lun%stream_channel_length(l)/lun%stream_channel_width(l)
+                     stream_channel_depth = lun%stream_channel_depth(l)
+                  else
+                     stream_water_depth = tdepth(g)
+                     stream_channel_depth = tdepth_bankfull(g)
+                  endif
+
+                  ! flow between channel and lowest column
+                  ! bankfull height is defined to be zero
+                  head_gradient = (col%hill_elev(c)-zwt(c)) &
+                       ! ignore overbankfull storage
+                       - min((stream_water_depth - stream_channel_depth),0._r8)
+
+                  head_gradient = head_gradient / (col%hill_distance(c))
+                  ! head_gradient cannot be negative when channel is empty
+                  if (stream_water_depth <= 0._r8) then
+                     head_gradient = max(head_gradient, 0._r8)
+                  endif
+                  ! add vertical drainage for losing streams
+                  ! (this could be a separate term from lateral flow...)
+                  if (head_gradient < 0._r8) then
+                     ! head_gradient = head_gradient - 1._r8
+                     ! adjust lateral gradient w/ k_anisotropic
+                     head_gradient = head_gradient - 1._r8/k_anisotropic
+                  endif
+               endif
+            else
+               call endrun(msg="head_gradient_method must be kinematic or darcy"//errmsg(sourcefile, __LINE__))  
+            end if
+
+            !scs: in cases of bad data, where hand differences in 
+            ! adjacent bins are very large, cap maximum head_gradient
+            ! should a warning be used instead?
+            head_gradient = min(max(head_gradient,-2._r8),2._r8)
+            
+            ! Determine source and destination columns
+            if (head_gradient >= 0._r8) then
+               c_src = c
+               c_dst = col%cold(c)
+            else
+               c_src = col%cold(c)
+               c_dst = c
+            endif
+           
+            ! Calculate transmissivity of source column
+            transmis = 0._r8
+            if(c_src /= ispval) then 
+               ! transmissivity non-zero only when saturated conditions exist
+               if(zwt(c_src) <= zi(c_src,nbedrock(c_src))) then 
+                  ! sum of layer transmissivities
+                  if (transmissivity_method == layersum) then
+                     do j = jwt(c_src)+1, nbedrock(c_src)
+                        if(j == jwt(c_src)+1) then
+                           transmis = transmis + 1.e-3_r8*ice_imped(c_src,j)*hksat(c_src,j)*(zi(c_src,j) - zwt(c_src))
+                        else
+                           if(c_dst == ispval) then 
+                              ! lowland, gaining stream
+                              ! only include layers above stream channel bottom
+                              if ((col%hill_elev(c_src)-z(c_src,j)) > (-stream_channel_depth)) then
+                                 
+                                 transmis = transmis + 1.e-3_r8*ice_imped(c_src,j)*hksat(c_src,j)*dz(c_src,j)
+                              endif
+                           else
+                              ! uplands
+                              if ((col%hill_elev(c_src)-z(c_src,j)) > (col%hill_elev(c_dst) - zwt(c_dst))) then
+                                 transmis = transmis + 1.e-3_r8*ice_imped(c_src,j)*hksat(c_src,j)*dz(c_src,j)
+                              endif
+                           endif
+                        endif
+                     end do
+                  ! constant conductivity based on shallowest saturated layer hk
+                  else if (transmissivity_method == uniform_transmissivity) then
+                     transmis = (1.e-3_r8*ice_imped(c_src,jwt(c_src)+1)*hksat(c_src,jwt(c_src)+1)) &
+                          *(zi(c_src,nbedrock(c_src)) - zwt(c_src) )
+                  else
+                     call endrun(msg="transmissivity_method must be LayerSum or Uniform"//errmsg(sourcefile, __LINE__))
+                  endif
+               endif
+            else
+               ! transmissivity of losing stream (c_src == ispval)
+               transmis = (1.e-3_r8*ice_imped(c,jwt(c)+1)*hksat(c,jwt(c)+1))*stream_water_depth
+            endif
+            ! adjust transmissivity by 'anisotropy factor'
+            transmis = k_anisotropic*transmis
+
+            ! the qflx_latflow_out_vol calculations use the
+            ! transmissivity to determine whether saturated flow
+            ! conditions exist, b/c gradients will be nonzero
+            ! even when no saturated layers are present
+            !          qflx_latflow_out_vol(c) = ice_imped(c)*transmis*col%hill_width(c)*head_gradient
+            ! include ice impedance in transmissivity
+            qflx_latflow_out_vol(c) = transmis*col%hill_width(c)*head_gradient
+
+            ! When head gradient is negative (losing stream channel), 
+            ! limit outflow by available stream channel water
+            if (use_hillslope_routing .and. (qflx_latflow_out_vol(c) < 0._r8)) then
+               available_stream_water = stream_water_volume(l)/lun%stream_channel_number(l)/nhillslope
+               if(abs(qflx_latflow_out_vol(c))*dtime > available_stream_water) then
+                  qflx_latflow_out_vol(c) = -available_stream_water/dtime
+               endif
+            endif
+
+            ! volumetric_discharge from lowest column is qflx_latflow_out_vol
+            ! scaled by total area of column in gridcell divided by column area
+            if (col%cold(c) == ispval) then
+               volumetric_discharge(c) = qflx_latflow_out_vol(c) &
+                    *(grc%area(g)*1.e6_r8*col%wtgcell(c)/col%hill_area(c))
+            endif
+
+            ! convert volumetric flow to equivalent flux
+            qflx_latflow_out(c) = 1.e3_r8*qflx_latflow_out_vol(c)/col%hill_area(c)
+
+            ! hilltop column has no inflow
+            if (col%colu(c) == ispval) then
+               qflx_latflow_in(c) = 0._r8
+            endif
+
+            ! current outflow is inflow to downhill column normalized by downhill area
+            if (col%cold(c) /= ispval) then
+               qflx_latflow_in(col%cold(c)) = qflx_latflow_in(col%cold(c)) + &
+                    1.e3_r8*qflx_latflow_out_vol(c)/col%hill_area(col%cold(c))
+            endif
+
+         else
+            ! Non-hillslope columns
+            ! baseflow is power law expression relative to bedrock layer
+            if(zwt(c) <= zi(c,nbedrock(c))) then
+               qflx_latflow_out(c) = ice_imped_col(c) * baseflow_scalar &
+                    * tan(rpi/180._r8*col%topo_slope(c))* &
+                    (zi(c,nbedrock(c)) - zwt(c))**(params_inst%n_baseflow)
+            endif
+            ! convert flux to volumetric flow
+            qflx_latflow_out_vol(c) = 1.e-3_r8*qflx_latflow_out(c)*(grc%area(g)*1.e6_r8*col%wtgcell(c))
+            volumetric_discharge(c) = qflx_latflow_out_vol(c)
+         endif
+      enddo
+
+      ! recalculate average flux for no-lateral flow case
+      if(no_lateral_flow) then
+         if (head_gradient_method /= kinematic) then
+            call endrun(msg="head_gradient_method must be kinematic for no_lateral_flow = .true.! "//errmsg(sourcefile, __LINE__))
+         endif
+         do fc = 1, num_hydrologyc
+            c = filter_hydrologyc(fc)
+            if (col%is_hillslope_column(c) .and. col%active(c)) then
+               l = col%landunit(c)
+               !need to sum all columns w/ same hillslope id for each column
+               qflx_latflow_avg(c) = 0._r8
+               larea = 0._r8
+               do c0 = lun%coli(l), lun%colf(l)
+                  if(col%hillslope_ndx(c0) == col%hillslope_ndx(c)) then
+                     qflx_latflow_avg(c) = qflx_latflow_avg(c) + qflx_latflow_out_vol(c0)
+                     larea = larea + col%hill_area(c0)
+                  endif
+               enddo
+               qflx_latflow_avg(c) = 1.e3_r8*qflx_latflow_avg(c)/larea
+            else
+               qflx_latflow_avg(c) = qflx_latflow_out(c)
+            endif
+         enddo
+      endif
+         
+      !-- Topographic runoff  -------------------------
+      do fc = 1, num_hydrologyc
+         c = filter_hydrologyc(fc)
+         
+         ! net lateral flow (positive out)
+         qflx_net_latflow(c) = qflx_latflow_out(c) - qflx_latflow_in(c)
+         if(no_lateral_flow) then
+            qflx_net_latflow(c) = qflx_latflow_avg(c)
+         endif
+         
+         !@@
+         ! baseflow 
+         if(zwt(c) <= zi(c,nbedrock(c))) then 
+            ! apply net lateral flow here
+            drainage(c) = qflx_net_latflow(c)
+         else
+            drainage(c) = 0._r8
+         endif
+         
+         !--  Now remove water via drainage
+         drainage_tot = - drainage(c) * dtime
+         
+         if(drainage_tot > 0.) then !rising water table
+            do j = jwt(c)+1,1,-1
+
+               ! ensure water is not added to frozen layers
+               if (zi(c,j) < frost_table(c)) then 
+                  ! analytical expression for specific yield
+                  s_y = watsat(c,j) &
+                       * ( 1. - (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
+                  s_y=max(s_y,params_inst%aq_sp_yield_min)
+
+                  drainage_layer=min(drainage_tot,(s_y*dz(c,j)*1.e3))
+
+                  drainage_layer=max(drainage_layer,0._r8)
+                  h2osoi_liq(c,j) = h2osoi_liq(c,j) + drainage_layer
+
+                  drainage_tot = drainage_tot - drainage_layer
+
+                  if (drainage_tot <= 0.) then 
+                     zwt(c) = zwt(c) - drainage_layer/s_y/1000._r8
+                     exit
+                  else
+                     zwt(c) = zi(c,j-1)
+                  endif
+               endif
+                  
+            enddo
+            
+            !--  remove residual drainage  --------------------------------
+            h2osfc(c) = h2osfc(c) + drainage_tot
+                    
           else ! deepening water table
              do j = jwt(c)+1, nbedrock(c)
-                ! use analytical expression for specific yield
+                ! analytical expression for specific yield
                 s_y = watsat(c,j) &
                      * ( 1. - (1.+1.e3*zwt(c)/sucsat(c,j))**(-1./bsw(c,j)))
-                s_y=max(s_y, params_inst%aq_sp_yield_min)
-                rsub_top_layer=max(rsub_top_tot,-(s_y*(zi(c,j) - zwt(c))*1.e3))
-                rsub_top_layer=min(rsub_top_layer,0._r8)
-                h2osoi_liq(c,j) = h2osoi_liq(c,j) + rsub_top_layer
-                   
-                rsub_top_tot = rsub_top_tot - rsub_top_layer
+                s_y=max(s_y,params_inst%aq_sp_yield_min)
+                
+                drainage_layer=max(drainage_tot,-(s_y*(zi(c,j) - zwt(c))*1.e3))
+                drainage_layer=min(drainage_layer,0._r8)
+                h2osoi_liq(c,j) = h2osoi_liq(c,j) + drainage_layer
 
-                if (rsub_top_tot >= 0.) then 
-                   zwt(c) = zwt(c) - rsub_top_layer/s_y/1000._r8
+                drainage_tot = drainage_tot - drainage_layer
                    
+                if (drainage_tot >= 0.) then 
+                   zwt(c) = zwt(c) - drainage_layer/s_y/1000._r8
                    exit
                 else
                    zwt(c) = zi(c,j)
                 endif
              enddo
              
-             !--  remove residual rsub_top  --------------------------------
+             !--  remove residual drainage  -----------------------
              ! make sure no extra water removed from soil column
-             rsub_top(c) = rsub_top(c) + rsub_top_tot/dtime
+             drainage(c) = drainage(c) + drainage_tot/dtime
           endif
           
           zwt(c) = max(0.0_r8,zwt(c))
@@ -2100,7 +2516,7 @@ contains
              c = filter_hydrologyc(fc)
              xsi(c)            = max(h2osoi_liq(c,j)-eff_porosity(c,j)*dzmm(c,j),0._r8)
              h2osoi_liq(c,j)   = min(eff_porosity(c,j)*dzmm(c,j), h2osoi_liq(c,j))
-             h2osoi_liq(c,j-1) = h2osoi_liq(c,j-1) + xsi(c)
+            h2osoi_liq(c,j-1) = h2osoi_liq(c,j-1) + xsi(c)
           end do
        end do
 
@@ -2173,16 +2589,16 @@ contains
           ! Instead of removing water from aquifer where it eventually
           ! shows up as excess drainage to the ocean, take it back out of 
           ! drainage
-          qflx_rsub_sat(c) = qflx_rsub_sat(c) - xs(c)/dtime
 
+          qflx_rsub_sat(c) = qflx_rsub_sat(c) - xs(c)/dtime
        end do
 
+
        do fc = 1, num_hydrologyc
           c = filter_hydrologyc(fc)
 
           ! Sub-surface runoff and drainage
-
-          qflx_drain(c) = qflx_rsub_sat(c) + rsub_top(c)
+          qflx_drain(c) = qflx_rsub_sat(c) + drainage(c)
 
           ! Set imbalance for snow capping
 
@@ -2190,6 +2606,7 @@ contains
 
        end do
 
+
        ! No drainage for urban columns (except for pervious road as computed above)
 
        do fc = 1, num_urbanc
@@ -2203,7 +2620,7 @@ contains
 
      end associate
 
-   end subroutine LateralFlowPowerLaw
+   end subroutine SubsurfaceLateralFlow
 
 !#7
    !-----------------------------------------------------------------------
diff --git a/src/biogeophys/SoilHydrologyType.F90 b/src/biogeophys/SoilHydrologyType.F90
index 4dfca0681..07ad2ca45 100644
--- a/src/biogeophys/SoilHydrologyType.F90
+++ b/src/biogeophys/SoilHydrologyType.F90
@@ -19,8 +19,6 @@ Module SoilHydrologyType
   type, public :: soilhydrology_type
 
      integer :: h2osfcflag              ! true => surface water is active (namelist)       
-     integer :: origflag                ! used to control soil hydrology properties (namelist)
-
      real(r8), pointer :: num_substeps_col   (:)    ! col adaptive timestep counter     
      ! NON-VIC
      real(r8), pointer :: frost_table_col   (:)     ! col frost table depth                    
@@ -28,7 +26,6 @@ Module SoilHydrologyType
      real(r8), pointer :: zwts_col          (:)     ! col water table depth, the shallower of the two water depths
      real(r8), pointer :: zwt_perched_col   (:)     ! col perched water table depth
      real(r8), pointer :: qcharge_col       (:)     ! col aquifer recharge rate (mm/s) 
-     real(r8), pointer :: fracice_col       (:,:)   ! col fractional impermeability (-)
      real(r8), pointer :: icefrac_col       (:,:)   ! col fraction of ice       
      real(r8), pointer :: h2osfc_thresh_col (:)     ! col level at which h2osfc "percolates"   (time constant)
      real(r8), pointer :: xs_urban_col      (:)     ! col excess soil water above urban ponding limit
@@ -121,7 +118,6 @@ contains
     allocate(this%zwts_col          (begc:endc))                 ; this%zwts_col          (:)     = nan
 
     allocate(this%qcharge_col       (begc:endc))                 ; this%qcharge_col       (:)     = nan
-    allocate(this%fracice_col       (begc:endc,nlevgrnd))        ; this%fracice_col       (:,:)   = nan
     allocate(this%icefrac_col       (begc:endc,nlevgrnd))        ; this%icefrac_col       (:,:)   = nan
     allocate(this%h2osfc_thresh_col (begc:endc))                 ; this%h2osfc_thresh_col (:)     = nan
     allocate(this%xs_urban_col      (begc:endc))                 ; this%xs_urban_col      (:)     = nan
@@ -340,16 +336,14 @@ contains
      ! !LOCAL VARIABLES:
      integer :: ierr                 ! error code
      integer :: unitn                ! unit for namelist file
-     integer :: origflag=0            !use to control soil hydraulic properties
      integer :: h2osfcflag=1          !If surface water is active or not
      character(len=32) :: subname = 'SoilHydrology_readnl'  ! subroutine name
      !-----------------------------------------------------------------------
 
-     namelist / clm_soilhydrology_inparm / h2osfcflag, origflag
+     namelist / clm_soilhydrology_inparm / h2osfcflag
 
      ! preset values
 
-     origflag = 0          
      h2osfcflag = 1        
 
      if ( masterproc )then
@@ -371,10 +365,8 @@ contains
      end if
 
      call shr_mpi_bcast(h2osfcflag, mpicom)
-     call shr_mpi_bcast(origflag,   mpicom)
 
      this%h2osfcflag = h2osfcflag
-     this%origflag   = origflag
 
    end subroutine ReadNL
 
diff --git a/src/biogeophys/SoilWaterMovementMod.F90 b/src/biogeophys/SoilWaterMovementMod.F90
index b1487e277..8b6f95391 100644
--- a/src/biogeophys/SoilWaterMovementMod.F90
+++ b/src/biogeophys/SoilWaterMovementMod.F90
@@ -575,10 +575,8 @@ contains
          zi                =>    col%zi                             , & ! Input:  [real(r8) (:,:) ]  interface level below a "z" level (m)           
          dz                =>    col%dz                             , & ! Input:  [real(r8) (:,:) ]  layer thickness (m)                             
 
-         origflag          =>    soilhydrology_inst%origflag        , & ! Input:  constant
          qcharge           =>    soilhydrology_inst%qcharge_col     , & ! Input:  [real(r8) (:)   ]  aquifer recharge rate (mm/s)                      
          zwt               =>    soilhydrology_inst%zwt_col         , & ! Input:  [real(r8) (:)   ]  water table depth (m)                             
-         fracice           =>    soilhydrology_inst%fracice_col     , & ! Input:  [real(r8) (:,:) ]  fractional impermeability (-)                   
          icefrac           =>    soilhydrology_inst%icefrac_col     , & ! Input:  [real(r8) (:,:) ]  fraction of ice                                 
          hkdepth           =>    soilhydrology_inst%hkdepth_col     , & ! Input:  [real(r8) (:)   ]  decay factor (m)                                  
 
@@ -720,22 +718,13 @@ contains
             c = filter_hydrologyc(fc)
             ! compute hydraulic conductivity based on liquid water content only
 
-            if (origflag == 1) then
-               s1 = 0.5_r8*(h2osoi_vol(c,j) + h2osoi_vol(c,min(nlevsoi, j+1))) / &
-                    (0.5_r8*(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
-            else
-               s1 = 0.5_r8*(vwc_liq(c,j) + vwc_liq(c,min(nlevsoi, j+1))) / &
-                    (0.5_r8*(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
-            endif
+            s1 = 0.5_r8*(vwc_liq(c,j) + vwc_liq(c,min(nlevsoi, j+1))) / &
+                 (0.5_r8*(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
             s1 = min(1._r8, s1)
             s2 = hksat(c,j)*s1**(2._r8*bsw(c,j)+2._r8)
 
-            ! replace fracice with impedance factor, as in zhao 97,99
-            if (origflag == 1) then
-               imped(c,j)=(1._r8-0.5_r8*(fracice(c,j)+fracice(c,min(nlevsoi, j+1))))
-            else
-               imped(c,j)=10._r8**(-params_inst%e_ice*(0.5_r8*(icefrac(c,j)+icefrac(c,min(nlevsoi, j+1)))))
-            endif
+            imped(c,j)=10._r8**(-params_inst%e_ice*(0.5_r8*(icefrac(c,j)+icefrac(c,min(nlevsoi, j+1)))))
+
             hk(c,j) = imped(c,j)*s1*s2
             dhkdw(c,j) = imped(c,j)*(2._r8*bsw(c,j)+3._r8)*s2* &
                  (1._r8/(watsat(c,j)+watsat(c,min(nlevsoi, j+1))))
@@ -751,11 +740,7 @@ contains
 
 
             ! compute matric potential and derivative based on liquid water content only
-            if (origflag == 1) then
-               s_node = max(h2osoi_vol(c,j)/watsat(c,j), 0.01_r8)
-            else
-               s_node = max(vwc_liq(c,j)/watsat(c,j), 0.01_r8)
-            endif
+            s_node = max(vwc_liq(c,j)/watsat(c,j), 0.01_r8)
             s_node = min(1.0_r8, s_node)
 
             !call soil_water_retention_curve%soil_suction(sucsat(c,j), s_node, bsw(c,j), smp(c,j), dsmpds)
@@ -765,11 +750,7 @@ contains
             !do not turn on the line below, which will cause bit to bit error, jyt, 2014 Mar 6
             !dsmpdw(c,j) = dsmpds/watsat(c,j)
 
-            if (origflag == 1) then             
-               dsmpdw(c,j) = -bsw(c,j)*smp(c,j)/(s_node*watsat(c,j))
-            else
-               dsmpdw(c,j) = -bsw(c,j)*smp(c,j)/vwc_liq(c,j)
-            endif
+            dsmpdw(c,j) = -bsw(c,j)*smp(c,j)/vwc_liq(c,j)
 
             smp_l(c,j) = smp(c,j)
             hk_l(c,j) = hk(c,j)
@@ -861,11 +842,7 @@ contains
          else ! water table is below soil column
 
             ! compute aquifer soil moisture as average of layer 10 and saturation
-            if(origflag == 1) then
-               s_node = max(0.5*(1.0_r8+h2osoi_vol(c,j)/watsat(c,j)), 0.01_r8)
-            else
-               s_node = max(0.5*((vwc_zwt(c)+vwc_liq(c,j))/watsat(c,j)), 0.01_r8)
-            endif
+            s_node = max(0.5*((vwc_zwt(c)+vwc_liq(c,j))/watsat(c,j)), 0.01_r8)
             s_node = min(1.0_r8, s_node)
 
             ! compute smp for aquifer layer
@@ -940,7 +917,7 @@ contains
             s_node = max(h2osoi_vol(c,jwt(c)+1)/watsat(c,jwt(c)+1), 0.01_r8)
             s1 = min(1._r8, s_node)
 
-            !scs: this is the expression for unsaturated hk
+            !this is the expression for unsaturated hk
             ka = imped(c,jwt(c)+1)*hksat(c,jwt(c)+1) &
                  *s1**(2._r8*bsw(c,jwt(c)+1)+3._r8)
 
@@ -953,12 +930,12 @@ contains
             smp1 = max(smpmin(c), smp(c,max(1,jwt(c))))
             wh      = smp1 - zq(c,max(1,jwt(c)))
 
-            !scs: original formulation
+            !original formulation
             if(jwt(c) == 0) then
                qcharge(c) = -ka * (wh_zwt-wh)  /((zwt(c)+1.e-3)*1000._r8)
             else
                !             qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8)
-               !scs: 1/2, assuming flux is at zwt interface, saturation deeper than zwt
+               !1/2, assuming flux is at zwt interface, saturation deeper than zwt
                qcharge(c) = -ka * (wh_zwt-wh)/((zwt(c)-z(c,jwt(c)))*1000._r8*2.0)
             endif
 
@@ -1164,6 +1141,7 @@ contains
     real(r8) :: vLiqRes(bounds%begc:bounds%endc,1:nlevsoi)   ! residual for the volumetric liquid water content (v/v)
 
     real(r8) :: dwat_temp
+    real(r8) :: over_saturation 
     !-----------------------------------------------------------------------
 
     associate(&
@@ -1177,6 +1155,7 @@ contains
          qcharge           =>    soilhydrology_inst%qcharge_col     , & ! Input:  [real(r8) (:)   ]  aquifer recharge rate (mm/s)                      
          zwt               =>    soilhydrology_inst%zwt_col         , & ! Input:  [real(r8) (:)   ]  water table depth (m)                             
 
+         watsat            =>    soilstate_inst%watsat_col          , & ! Input:  [real(r8) (:,:) ] volumetric soil water at saturation (porosity)
          smp_l             =>    soilstate_inst%smp_l_col           , & ! Input:  [real(r8) (:,:) ]  soil matrix potential [mm]                      
          hk_l              =>    soilstate_inst%hk_l_col            , & ! Input:  [real(r8) (:,:) ]  hydraulic conductivity (mm/s)                   
          h2osoi_ice        =>    waterstatebulk_inst%h2osoi_ice_col , & ! Input:  [real(r8) (:,:) ]  ice water (kg/m2)                               
@@ -1413,10 +1392,17 @@ contains
 
          end do  ! substep loop
 
-!  save number of adaptive substeps used during time step
+         !  save number of adaptive substeps used during time step
          nsubsteps(c) = nsubstep
 
-! check for negative moisture values
+!!$         ! check for over-saturated layers                                      
+!!$         do j = nlayers,2,-1
+!!$            over_saturation   = max(h2osoi_liq(c,j)-(watsat(c,j)*m_to_mm*dz(c,j)),0._r8)
+!!$            h2osoi_liq(c,j)   = min(watsat(c,j)*m_to_mm*dz(c,j), h2osoi_liq(c,j))
+!!$            h2osoi_liq(c,j-1) = h2osoi_liq(c,j-1) + over_saturation
+!!$         end do
+         
+         ! check for negative moisture values
          do j = 2, nlayers
             if(h2osoi_liq(c,j) < -1e-6_r8) then
                write(*,*) 'layer, h2osoi_liq: ', c,j,h2osoi_liq(c,j)
@@ -1494,7 +1480,7 @@ contains
     character(len=32)  :: subname = 'calculate_hydraulic_properties'     ! subroutine name   
     !-----------------------------------------------------------------------
 
-!scs: originally, associate statements selected sections rather than 
+!     originally, associate statements selected sections rather than 
 !     entire arrays, but due to pgi bug, removed array section selections
 !     using array sections allowed consistent 1d indexing throughout
     associate(&
@@ -1621,7 +1607,7 @@ contains
     real(r8) :: num, den      ! used in calculating qin, qout
     real(r8) :: dhkds1, dhkds2                                        !temporary variable
     real(r8),parameter :: m_to_mm = 1.e3_r8  !convert meters to mm
-!scs: temporarily use local variables for the following
+    ! temporarily use local variables for the following
     real(r8) :: vwc_liq_ub   ! liquid volumetric water content at upper boundary
     real(r8) :: vwc_liq_lb   ! liquid volumetric water content at lower boundary
     character(len=32)  :: subname = 'calculate_moisture_fluxes_and_derivs'     ! subroutine name   
@@ -1704,12 +1690,11 @@ contains
     dhkds1 = 0.5_r8 * dhkdw(j) / watsat(c,j)   ! derivative w.r.t. volumetric liquid water in the upper layer
     dhkds2 = 0.5_r8 * dhkdw(j) / watsat(c,j+1) ! derivative w.r.t. volumetric liquid water in the lower layer
 
-!scs: this is how zd is done
+    ! this is how zd is done
     if (zdflag == 1) then 
        dhkds1 = dhkdw(j)/(watsat(c,j)+watsat(c,min(nlevsoi, j+1)))
        dhkds2 = dhkds1
     endif
-!scs
 
     ! compute flux at the bottom of the j-th layer
     ! NOTE: hk(j) is hydraulic conductivity at the bottom of the j-th
@@ -1739,12 +1724,11 @@ contains
        !        layer interface w.r.t relative saturation at the interface
        dhkds1 = 0.5_r8 * dhkdw(j) / watsat(c,j)   ! derivative w.r.t. volumetric liquid water in the upper layer
        dhkds2 = 0.5_r8 * dhkdw(j) / watsat(c,j+1) ! derivative w.r.t. volumetric liquid water in the lower layer
-!scs: this is how zd is done
+       ! this is how zd is done
              if (zdflag == 1) then 
                 dhkds1 = dhkdw(j)/(watsat(c,j)+watsat(c,min(nlevsoi, j+1)))
                 dhkds2 = dhkds1
              endif
-!scs
           
        ! compute flux at the bottom of the j-th layer
        ! NOTE: hk(j) is hydraulic conductivity at the bottom of the j-th  layer
@@ -1801,12 +1785,12 @@ contains
              ! condition when the water table is a long way below the soil column
              dhkds1 = dhkdw(j) / watsat(c,j)
 
-!scs: this is how zd is done
+             ! this is how zd is done
              if (zdflag == 1) then 
                 dhkds1 = dhkdw(j)/(watsat(c,j)+watsat(c,min(nlevsoi, j+1)))
                 dhkds2 = dhkds1
              endif
-!scs
+
              ! compute flux
              num    = -smp(j)  ! NOTE: assume saturation at water table depth (smp=0)
              den    = m_to_mm * (zwt(c) - z(c,j))
@@ -1824,7 +1808,7 @@ contains
           
           ! compute the relative saturation at the lower boundary
           s1 = vwc_liq_lb / watsat(c,j)
-!scs: mc's original expression          s1 = (vwc_liq_lb - watres(c,j)) / (watsat(c,j) - watres(c,j))
+          ! mc's original expression          s1 = (vwc_liq_lb - watres(c,j)) / (watsat(c,j) - watres(c,j))
           s1 = min(s1, 1._r8)
           s1 = max(0.01_r8, s1)
           
diff --git a/src/biogeophys/SurfaceAlbedoMod.F90 b/src/biogeophys/SurfaceAlbedoMod.F90
index d23320d5e..6628f0fa4 100644
--- a/src/biogeophys/SurfaceAlbedoMod.F90
+++ b/src/biogeophys/SurfaceAlbedoMod.F90
@@ -261,6 +261,8 @@ contains
     use abortutils         , only : endrun
     use clm_varctl         , only : use_subgrid_fluxes, use_snicar_frc, use_fates
     use CLMFatesInterfaceMod, only : hlm_fates_interface_type
+    use landunit_varcon     , only : istsoil
+    use clm_varctl          , only : downscale_hillslope_meteorology
 
     ! !ARGUMENTS:
     type(bounds_type)      , intent(in)            :: bounds             ! bounds
@@ -305,7 +307,6 @@ contains
     real(r8) :: ws              (bounds%begp:bounds%endp)                                 ! fraction of LAI+SAI that is SAI
     real(r8) :: blai(bounds%begp:bounds%endp)                                             ! lai buried by snow: tlai - elai
     real(r8) :: bsai(bounds%begp:bounds%endp)                                             ! sai buried by snow: tsai - esai
-    real(r8) :: coszen_gcell    (bounds%begg:bounds%endg)                                 ! cosine solar zenith angle for next time step (grc)
     real(r8) :: coszen_patch    (bounds%begp:bounds%endp)                                 ! cosine solar zenith angle for next time step (patch)
     real(r8) :: rho(bounds%begp:bounds%endp,numrad)                                       ! leaf/stem refl weighted by fraction LAI and SAI
     real(r8) :: tau(bounds%begp:bounds%endp,numrad)                                       ! leaf/stem tran weighted by fraction LAI and SAI
@@ -334,6 +335,7 @@ contains
     real(r8) :: mss_cnc_aer_in_fdb     (bounds%begc:bounds%endc,-nlevsno+1:0,sno_nbr_aer) ! mass concentration of all aerosol species for feedback calculation (col,lyr,aer) [kg kg-1]
     real(r8), parameter :: mpe = 1.e-06_r8                                                ! prevents overflow for division by zero
     integer , parameter :: nband =numrad                                                  ! number of solar radiation waveband classes
+    real(r8) :: zenith_angle
     !-----------------------------------------------------------------------
 
    associate(&
@@ -369,6 +371,8 @@ contains
           vcmaxcintsha  =>    surfalb_inst%vcmaxcintsha_patch     , & ! Output:  [real(r8) (:)   ]  leaf to canopy scaling coefficient, shaded leaf vcmax
           ncan          =>    surfalb_inst%ncan_patch             , & ! Output:  [integer  (:)   ]  number of canopy layers                  
           nrad          =>    surfalb_inst%nrad_patch             , & ! Output:  [integer  (:)   ]  number of canopy layers, above snow for radiative transfer
+          azsun_grc     =>    surfalb_inst%azsun_grc              , & ! Output:  [real(r8) (:)   ]  cosine of solar zenith angle            
+          coszen_grc    =>    surfalb_inst%coszen_grc             , & ! Output:  [real(r8) (:)   ]  cosine of solar zenith angle            
           coszen_col    =>    surfalb_inst%coszen_col             , & ! Output:  [real(r8) (:)   ]  cosine of solar zenith angle            
           albgrd        =>    surfalb_inst%albgrd_col             , & ! Output:  [real(r8) (:,:) ]  ground albedo (direct)                
           albgri        =>    surfalb_inst%albgri_col             , & ! Output:  [real(r8) (:,:) ]  ground albedo (diffuse)               
@@ -426,16 +430,29 @@ contains
     ! Cosine solar zenith angle for next time step
 
     do g = bounds%begg,bounds%endg
-       coszen_gcell(g) = shr_orb_cosz (nextsw_cday, grc%lat(g), grc%lon(g), declinp1)
+       coszen_grc(g) = shr_orb_cosz (nextsw_cday, grc%lat(g), grc%lon(g), declinp1)
     end do
+    
     do c = bounds%begc,bounds%endc
        g = col%gridcell(c)
-       coszen_col(c) = coszen_gcell(g)
+       if (col%is_hillslope_column(c) .and. downscale_hillslope_meteorology) then
+          ! calculate local incidence angle based on column slope and aspect
+          zenith_angle = acos(coszen_grc(g))
+          
+          azsun_grc(g) = shr_orb_azimuth(nextsw_cday, grc%lat(g), grc%lon(g), declinp1, zenith_angle)
+          ! hill_slope is [m/m], convert to radians
+          coszen_col(c) = shr_orb_cosinc(zenith_angle,azsun_grc(g),atan(col%hill_slope(c)),col%hill_aspect(c))
+
+          if(coszen_grc(g) > 0._r8 .and. coszen_col(c) < 0._r8) coszen_col(c) = 0._r8
+
+       else
+          coszen_col(c) = coszen_grc(g)
+       endif
     end do
     do fp = 1,num_nourbanp
        p = filter_nourbanp(fp)
-       g = patch%gridcell(p)
-       coszen_patch(p) = coszen_gcell(g)
+       c = patch%column(p)
+       coszen_patch(p) = coszen_col(c)
     end do
 
     ! Initialize output because solar radiation only done if coszen > 0
diff --git a/src/biogeophys/SurfaceAlbedoType.F90 b/src/biogeophys/SurfaceAlbedoType.F90
index a8b645b84..ddb57d88f 100644
--- a/src/biogeophys/SurfaceAlbedoType.F90
+++ b/src/biogeophys/SurfaceAlbedoType.F90
@@ -16,6 +16,8 @@ module SurfaceAlbedoType
   ! !PUBLIC DATA MEMBERS:
   type, public :: surfalb_type
 
+     real(r8), pointer :: azsun_grc            (:)   ! azimuth angle of sun
+     real(r8), pointer :: coszen_grc           (:)   ! gridcell cosine of solar zenith angle
      real(r8), pointer :: coszen_col           (:)   ! col cosine of solar zenith angle
      real(r8), pointer :: albd_patch           (:,:) ! patch surface albedo (direct)   (numrad)                    
      real(r8), pointer :: albi_patch           (:,:) ! patch surface albedo (diffuse)  (numrad)                    
@@ -123,11 +125,15 @@ contains
     ! !LOCAL VARIABLES:
     integer :: begp, endp
     integer :: begc, endc
+    integer :: begg, endg
     !---------------------------------------------------------------------
 
     begp = bounds%begp; endp = bounds%endp
     begc = bounds%begc; endc = bounds%endc
+    begg = bounds%begg; endg = bounds%endg
 
+    allocate(this%azsun_grc          (begg:endg))              ; this%azsun_grc         (:)   = nan
+    allocate(this%coszen_grc         (begg:endg))              ; this%coszen_grc         (:)   = nan
     allocate(this%coszen_col         (begc:endc))              ; this%coszen_col         (:)   = nan
     allocate(this%albgrd_col         (begc:endc,numrad))       ; this%albgrd_col         (:,:) = nan
     allocate(this%albgri_col         (begc:endc,numrad))       ; this%albgri_col         (:,:) = nan
@@ -210,15 +216,27 @@ contains
     ! !LOCAL VARIABLES:
     integer :: begp, endp
     integer :: begc, endc
+    integer :: begg, endg
     character(len=cs) :: defaultoutput
     !---------------------------------------------------------------------
 
     begp = bounds%begp; endp = bounds%endp
     begc = bounds%begc; endc = bounds%endc
+    begg = bounds%begg; endg = bounds%endg
+
+    this%azsun_grc(begg:endg) = spval
+    call hist_addfld1d (fname='AZSUN', units='radians', &
+         avgflag='A', long_name='cosine of solar zenith angle', &
+         ptr_lnd=this%azsun_grc, default='inactive')
+
+    this%coszen_grc(begg:endg) = spval
+    call hist_addfld1d (fname='COSZEN_GRC', units='none', &
+         avgflag='A', long_name='cosine of solar zenith angle', &
+         ptr_lnd=this%coszen_grc, default='inactive')
 
     this%coszen_col(begc:endc) = spval
     call hist_addfld1d (fname='COSZEN', units='none', &
-         avgflag='A', long_name='cosine of solar zenith angle', &
+         avgflag='A', long_name='cosine of solar zenith angle (downscaled if downscaling is activated)', &
          ptr_col=this%coszen_col, default='inactive')
 
     this%albgrd_col(begc:endc,:) = spval
@@ -418,6 +436,11 @@ contains
     begp = bounds%begp; endp = bounds%endp
     begc = bounds%begc; endc = bounds%endc
 
+    call restartvar(ncid=ncid, flag=flag, varname='coszen_grc', xtype=ncd_double,  & 
+         dim1name='gridcell', &
+         long_name='cosine of solar zenith angle', units='unitless', &
+         interpinic_flag='interp', readvar=readvar, data=this%coszen_grc)
+
     call restartvar(ncid=ncid, flag=flag, varname='coszen', xtype=ncd_double,  & 
          dim1name='column', &
          long_name='cosine of solar zenith angle', units='unitless', &
diff --git a/src/biogeophys/SurfaceRadiationMod.F90 b/src/biogeophys/SurfaceRadiationMod.F90
index 03557c647..3fe7c9bd2 100644
--- a/src/biogeophys/SurfaceRadiationMod.F90
+++ b/src/biogeophys/SurfaceRadiationMod.F90
@@ -383,6 +383,7 @@ contains
     ! local variables
     integer           :: fp                         ! non-urban filter patch index
     integer           :: p                          ! patch index
+    integer           :: c                          ! column index
     integer           :: g                          ! gridcell index
     integer           :: iv                         ! canopy layer index
     integer,parameter :: ipar = 1                   ! The band index for PAR
@@ -390,7 +391,7 @@ contains
     associate( tlai_z  => surfalb_inst%tlai_z_patch, &    ! tlai increment for canopy layer
           fsun_z      => surfalb_inst%fsun_z_patch, &     ! sunlit fraction of canopy layer
           elai        => canopystate_inst%elai_patch, &   ! one-sided leaf area index
-          forc_solad  => atm2lnd_inst%forc_solad_grc, &   ! direct beam radiation (W/m**2)
+          forc_solad_col  => atm2lnd_inst%forc_solad_downscaled_col, &   ! direct beam radiation, column (W/m**2)
           forc_solai  => atm2lnd_inst%forc_solai_grc, &   ! diffuse radiation (W/m**2)
           fabd_sun_z  => surfalb_inst%fabd_sun_z_patch, & ! absorbed sunlit leaf direct PAR
           fabd_sha_z  => surfalb_inst%fabd_sha_z_patch, & ! absorbed shaded leaf direct PAR
@@ -440,10 +441,11 @@ contains
         ! are canopy integrated so that layer values equal big leaf values.
 
         g = patch%gridcell(p)
+        c = patch%column(p)
 
         do iv = 1, nrad(p)
-           parsun_z(p,iv) = forc_solad(g,ipar)*fabd_sun_z(p,iv) + forc_solai(g,ipar)*fabi_sun_z(p,iv)
-           parsha_z(p,iv) = forc_solad(g,ipar)*fabd_sha_z(p,iv) + forc_solai(g,ipar)*fabi_sha_z(p,iv)
+           parsun_z(p,iv) = forc_solad_col(c,ipar)*fabd_sun_z(p,iv) + forc_solai(g,ipar)*fabi_sun_z(p,iv)
+           parsha_z(p,iv) = forc_solad_col(c,ipar)*fabd_sha_z(p,iv) + forc_solai(g,ipar)*fabi_sha_z(p,iv)
         end do
 
      end do ! end of fp = 1,num_nourbanp loop
@@ -533,8 +535,8 @@ contains
      associate(                                                     &
           snl             =>    col%snl                           , & ! Input:  [integer  (:)   ] negative number of snow layers [nbr]
 
-          forc_solad      =>    atm2lnd_inst%forc_solad_grc       , & ! Input:  [real(r8) (:,:) ] direct beam radiation (W/m**2)
-          forc_solai      =>    atm2lnd_inst%forc_solai_grc       , & ! Input:  [real(r8) (:,:) ] diffuse radiation (W/m**2)
+          forc_solad_col  =>    atm2lnd_inst%forc_solad_downscaled_col     , & ! Input:  [real(r8) (:,:) ] direct beam radiation, column (W/m**2)        
+          forc_solai      =>    atm2lnd_inst%forc_solai_grc       , & ! Input:  [real(r8) (:,:) ] diffuse radiation (W/m**2)            
 
           snow_depth      =>    waterdiagnosticbulk_inst%snow_depth_col    , & ! Input:  [real(r8) (:)   ] snow height (m)
           frac_sno        =>    waterdiagnosticbulk_inst%frac_sno_col      , & ! Input:  [real(r8) (:)   ] fraction of ground covered by snow (0 to 1)
@@ -682,7 +684,7 @@ contains
 
              ! Absorbed by canopy
 
-             cad(p,ib) = forc_solad(g,ib)*fabd(p,ib)
+             cad(p,ib) = forc_solad_col(c,ib)*fabd(p,ib)
              cai(p,ib) = forc_solai(g,ib)*fabi(p,ib)
              sabv(p) = sabv(p) + cad(p,ib) + cai(p,ib)
              fsa(p)  = fsa(p)  + cad(p,ib) + cai(p,ib)
@@ -695,8 +697,8 @@ contains
 
              ! Transmitted = solar fluxes incident on ground
 
-             trd(p,ib) = forc_solad(g,ib)*ftdd(p,ib)
-             tri(p,ib) = forc_solad(g,ib)*ftid(p,ib) + forc_solai(g,ib)*ftii(p,ib)
+             trd(p,ib) = forc_solad_col(c,ib)*ftdd(p,ib)
+             tri(p,ib) = forc_solad_col(c,ib)*ftid(p,ib) + forc_solai(g,ib)*ftii(p,ib)
              ! Solar radiation absorbed by ground surface
              ! calculate absorbed solar by soil/snow separately
              absrad  = trd(p,ib)*(1._r8-albsod(c,ib)) + tri(p,ib)*(1._r8-albsoi(c,ib))
@@ -887,29 +889,30 @@ contains
        do fp = 1,num_nourbanp
           p = filter_nourbanp(fp)
           g = patch%gridcell(p)
+          c = patch%column(p)
 
           ! NDVI and reflected solar radiation
 
-          rvis = albd(p,1)*forc_solad(g,1) + albi(p,1)*forc_solai(g,1)
-          rnir = albd(p,2)*forc_solad(g,2) + albi(p,2)*forc_solai(g,2)
+          rvis = albd(p,1)*forc_solad_col(c,1) + albi(p,1)*forc_solai(g,1)
+          rnir = albd(p,2)*forc_solad_col(c,2) + albi(p,2)*forc_solai(g,2)
           fsr(p) = rvis + rnir
           if (use_SSRE) then
-             rvisSF = albdSF(p,1)*forc_solad(g,1) + albiSF(p,1)*forc_solai(g,1)
-             rnirSF = albdSF(p,2)*forc_solad(g,2) + albiSF(p,2)*forc_solai(g,2)
+             rvisSF = albdSF(p,1)*forc_solad_col(c,1) + albiSF(p,1)*forc_solai(g,1)
+             rnirSF = albdSF(p,2)*forc_solad_col(c,2) + albiSF(p,2)*forc_solai(g,2)
              fsrSF(p) = rvisSF + rnirSF
              ssre_fsr(p) = fsr(p)-fsrSF(p)
           end if
-          fsds_vis_d(p) = forc_solad(g,1)
-          fsds_nir_d(p) = forc_solad(g,2)
+          fsds_vis_d(p) = forc_solad_col(c,1)
+          fsds_nir_d(p) = forc_solad_col(c,2)
           fsds_vis_i(p) = forc_solai(g,1)
           fsds_nir_i(p) = forc_solai(g,2)
-          fsr_vis_d(p)  = albd(p,1)*forc_solad(g,1)
-          fsr_nir_d(p)  = albd(p,2)*forc_solad(g,2)
+          fsr_vis_d(p)  = albd(p,1)*forc_solad_col(c,1)
+          fsr_nir_d(p)  = albd(p,2)*forc_solad_col(c,2)
           fsr_vis_i(p)  = albi(p,1)*forc_solai(g,1)
           fsr_nir_i(p)  = albi(p,2)*forc_solai(g,2)
           if (use_SSRE) then
-             fsrSF_vis_d(p)  = albdSF(p,1)*forc_solad(g,1)
-             fsrSF_nir_d(p)  = albdSF(p,2)*forc_solad(g,2)
+             fsrSF_vis_d(p)  = albdSF(p,1)*forc_solad_col(c,1)
+             fsrSF_nir_d(p)  = albdSF(p,2)*forc_solad_col(c,2)
              fsrSF_vis_i(p)  = albiSF(p,1)*forc_solai(g,1)
              fsrSF_nir_i(p)  = albiSF(p,2)*forc_solai(g,2)
 
@@ -919,10 +922,10 @@ contains
              ssre_fsr_nir_i(p) = fsrSF_nir_i(p)-fsr_nir_i(p)
           end if
           if ( is_near_local_noon( grc%londeg(g), deltasec=nint(dtime)/2 ) )then
-             fsds_vis_d_ln(p) = forc_solad(g,1)
-             fsds_nir_d_ln(p) = forc_solad(g,2)
-             fsr_vis_d_ln(p) = albd(p,1)*forc_solad(g,1)
-             fsr_nir_d_ln(p) = albd(p,2)*forc_solad(g,2)
+             fsds_vis_d_ln(p) = forc_solad_col(c,1)
+             fsds_nir_d_ln(p) = forc_solad_col(c,2)
+             fsr_vis_d_ln(p) = albd(p,1)*forc_solad_col(c,1)
+             fsr_nir_d_ln(p) = albd(p,2)*forc_solad_col(c,2)
              fsds_vis_i_ln(p) = forc_solai(g,1)
              parveg_ln(p)     = parveg(p)
           else
@@ -935,8 +938,8 @@ contains
           end if
           if (use_SSRE) then
              if ( is_near_local_noon( grc%londeg(g), deltasec=nint(dtime)/2 ) )then
-                fsrSF_vis_d_ln(p) = albdSF(p,1)*forc_solad(g,1)
-                fsrSF_nir_d_ln(p) = albdSF(p,2)*forc_solad(g,2)
+                fsrSF_vis_d_ln(p) = albdSF(p,1)*forc_solad_col(c,1)
+                fsrSF_nir_d_ln(p) = albdSF(p,2)*forc_solad_col(c,2)
              else
                 fsrSF_vis_d_ln(p) = spval
                 fsrSF_nir_d_ln(p) = spval
@@ -946,8 +949,8 @@ contains
           ! (OPTIONAL)
           c = patch%column(p)
           if (snl(c) < 0) then
-             fsds_sno_vd(p) = forc_solad(g,1)
-             fsds_sno_nd(p) = forc_solad(g,2)
+             fsds_sno_vd(p) = forc_solad_col(c,1)
+             fsds_sno_nd(p) = forc_solad_col(c,2)
              fsds_sno_vi(p) = forc_solai(g,1)
              fsds_sno_ni(p) = forc_solai(g,2)
 
@@ -972,6 +975,7 @@ contains
        do fp = 1,num_urbanp
           p = filter_urbanp(fp)
           g = patch%gridcell(p)
+          c = patch%column(p)
 
           if(elai(p)==0.0_r8.and.fabd(p,1)>0._r8)then
              if ( local_debug ) write(iulog,*) 'absorption without LAI',elai(p),tlai(p),fabd(p,1),p
@@ -979,15 +983,15 @@ contains
 
           ! Solar incident
 
-          fsds_vis_d(p) = forc_solad(g,1)
-          fsds_nir_d(p) = forc_solad(g,2)
+          fsds_vis_d(p) = forc_solad_col(c,1)
+          fsds_nir_d(p) = forc_solad_col(c,2)    
           fsds_vis_i(p) = forc_solai(g,1)
           fsds_nir_i(p) = forc_solai(g,2)
 
           ! Determine local noon incident solar
           if ( is_near_local_noon( grc%londeg(g), deltasec=nint(dtime)/2 ) )then
-             fsds_vis_d_ln(p) = forc_solad(g,1)
-             fsds_nir_d_ln(p) = forc_solad(g,2)
+             fsds_vis_d_ln(p) = forc_solad_col(c,1)
+             fsds_nir_d_ln(p) = forc_solad_col(c,2)
              fsds_vis_i_ln(p) = forc_solai(g,1)
              parveg_ln(p)     = 0._r8
           else
@@ -1000,8 +1004,8 @@ contains
           ! Solar reflected
           ! per unit ground area (roof, road) and per unit wall area (sunwall, shadewall)
 
-          fsr_vis_d(p) = albd(p,1) * forc_solad(g,1)
-          fsr_nir_d(p) = albd(p,2) * forc_solad(g,2)
+          fsr_vis_d(p) = albd(p,1) * forc_solad_col(c,1)
+          fsr_nir_d(p) = albd(p,2) * forc_solad_col(c,2)
           fsr_vis_i(p) = albi(p,1) * forc_solai(g,1)
           fsr_nir_i(p) = albi(p,2) * forc_solai(g,2)
 
diff --git a/src/biogeophys/SurfaceWaterMod.F90 b/src/biogeophys/SurfaceWaterMod.F90
index b293dd792..562c64cc1 100644
--- a/src/biogeophys/SurfaceWaterMod.F90
+++ b/src/biogeophys/SurfaceWaterMod.F90
@@ -456,6 +456,7 @@ contains
     real(r8) :: dtime         ! land model time step (sec)
     real(r8) :: frac_infclust ! fraction of submerged area that is connected
     real(r8) :: k_wet         ! linear reservoir coefficient for h2osfc
+    real(r8),parameter :: min_hill_slope = 1e-3_r8! minimum value of hillslope for outflow
 
     character(len=*), parameter :: subname = 'QflxH2osfcSurf'
     !-----------------------------------------------------------------------
@@ -483,6 +484,10 @@ contains
        if(h2osfc(c) > h2osfc_thresh(c) .and. h2osfcflag/=0) then
           ! spatially variable k_wet
           k_wet=1.0e-4_r8 * sin((rpi/180._r8) * topo_slope(c))
+          if (col%is_hillslope_column(c)) then
+             ! require a minimum value to ensure non-zero outflow
+             k_wet = 1e-4_r8 * max(col%hill_slope(c),min_hill_slope)
+          endif
           qflx_h2osfc_surf(c) = k_wet * frac_infclust * (h2osfc(c) - h2osfc_thresh(c))
 
           qflx_h2osfc_surf(c)=min(qflx_h2osfc_surf(c),(h2osfc(c) - h2osfc_thresh(c))/dtime)
diff --git a/src/biogeophys/UrbanRadiationMod.F90 b/src/biogeophys/UrbanRadiationMod.F90
index 0b6412f2d..ccb3f196b 100644
--- a/src/biogeophys/UrbanRadiationMod.F90
+++ b/src/biogeophys/UrbanRadiationMod.F90
@@ -117,9 +117,9 @@ contains
          canyon_hwr         =>    lun%canyon_hwr                             , & ! Input:  [real(r8) (:)   ]  ratio of building height to street width          
          wtroad_perv        =>    lun%wtroad_perv                            , & ! Input:  [real(r8) (:)   ]  weight of pervious road wrt total road            
 
-         forc_solad         =>    atm2lnd_inst%forc_solad_grc                , & ! Input:  [real(r8) (:,:) ]  direct beam radiation  (vis=forc_sols , nir=forc_soll ) (W/m**2)
+         forc_solad         =>    atm2lnd_inst%forc_solad_not_downscaled_grc          , & ! Input:  [real(r8) (:,:) ]  direct beam radiation  (vis=forc_sols , nir=forc_soll ) (W/m**2)
          forc_solai         =>    atm2lnd_inst%forc_solai_grc                , & ! Input:  [real(r8) (:,:) ]  diffuse beam radiation (vis=forc_sols , nir=forc_soll ) (W/m**2)
-         forc_solar         =>    atm2lnd_inst%forc_solar_grc                , & ! Input:  [real(r8) (:)   ]  incident solar radiation (W/m**2)                 
+         forc_solar         =>    atm2lnd_inst%forc_solar_not_downscaled_grc          , & ! Input:  [real(r8) (:)   ]  incident solar radiation (W/m**2)                 
          forc_lwrad         =>    atm2lnd_inst%forc_lwrad_not_downscaled_grc , & ! Input:  [real(r8) (:)   ]  downward infrared (longwave) radiation (W/m**2)   
 
          frac_sno           =>    waterdiagnosticbulk_inst%frac_sno_col               , & ! Input:  [real(r8) (:)   ]  fraction of ground covered by snow (0 to 1)       
diff --git a/src/biogeophys/WaterDiagnosticBulkType.F90 b/src/biogeophys/WaterDiagnosticBulkType.F90
index 057062777..dd556a2df 100644
--- a/src/biogeophys/WaterDiagnosticBulkType.F90
+++ b/src/biogeophys/WaterDiagnosticBulkType.F90
@@ -16,7 +16,7 @@ module WaterDiagnosticBulkType
   use shr_log_mod    , only : errMsg => shr_log_errMsg
   use decompMod      , only : bounds_type
   use abortutils     , only : endrun
-  use clm_varctl     , only : use_cn, iulog, use_luna
+  use clm_varctl     , only : use_cn, iulog, use_luna, use_hillslope
   use clm_varpar     , only : nlevgrnd, nlevsno, nlevcan, nlevsoi
   use clm_varcon     , only : spval
   use LandunitType   , only : lun                
@@ -83,6 +83,9 @@ module WaterDiagnosticBulkType
      real(r8), pointer :: qflx_prec_intr_patch   (:)   ! patch interception of precipitation (mm H2O/s)
      real(r8), pointer :: qflx_prec_grnd_col     (:)   ! col water onto ground including canopy runoff (mm H2O/s)
 
+     ! Hillslope stream variables
+     real(r8), pointer :: stream_water_depth_lun (:)   ! landunit depth of water in the streams (m)
+
    contains
 
      ! Public interfaces
@@ -231,6 +234,7 @@ contains
     allocate(this%fdry_patch             (begp:endp))                     ; this%fdry_patch             (:)   = nan
     allocate(this%qflx_prec_intr_patch   (begp:endp))                     ; this%qflx_prec_intr_patch   (:)   = nan
     allocate(this%qflx_prec_grnd_col     (begc:endc))                     ; this%qflx_prec_grnd_col     (:)   = nan
+    allocate(this%stream_water_depth_lun (begl:endl))                     ; this%stream_water_depth_lun (:)   = nan
 
   end subroutine InitBulkAllocate
 
@@ -252,12 +256,14 @@ contains
     ! !LOCAL VARIABLES:
     integer           :: begp, endp
     integer           :: begc, endc
+    integer           :: begl, endl
     integer           :: begg, endg
     real(r8), pointer :: data2dptr(:,:), data1dptr(:) ! temp. pointers for slicing larger arrays
     !------------------------------------------------------------------------
 
     begp = bounds%begp; endp= bounds%endp
     begc = bounds%begc; endc= bounds%endc
+    begl = bounds%begl; endl= bounds%endl
     begg = bounds%begg; endg= bounds%endg
 
     this%h2osno_total_col(begc:endc) = spval
@@ -580,6 +586,14 @@ contains
          long_name=this%info%lname('interception'), &
          ptr_patch=this%qflx_prec_intr_patch, set_lake=0._r8)
 
+    if (use_hillslope) then
+       this%stream_water_depth_lun(begl:endl) = spval
+       call hist_addfld1d (fname=this%info%fname('STREAM_WATER_DEPTH'), &
+            units='m',  avgflag='A', &
+            long_name=this%info%lname('depth of water in stream channel (hillslope hydrology only)'), &
+            ptr_lunit=this%stream_water_depth_lun, l2g_scale_type='natveg',  default='inactive')
+    endif
+    
   end subroutine InitBulkHistory
   
   !-----------------------------------------------------------------------
diff --git a/src/biogeophys/WaterFluxType.F90 b/src/biogeophys/WaterFluxType.F90
index f7c55d44e..8b2c4279e 100644
--- a/src/biogeophys/WaterFluxType.F90
+++ b/src/biogeophys/WaterFluxType.F90
@@ -10,7 +10,7 @@ module WaterFluxType
   use clm_varpar     , only : nlevsno, nlevsoi
   use clm_varcon     , only : spval
   use decompMod      , only : bounds_type
-  use decompMod      , only : subgrid_level_patch, subgrid_level_column, subgrid_level_gridcell
+  use decompMod      , only : subgrid_level_patch, subgrid_level_column, subgrid_level_landunit, subgrid_level_gridcell
   use LandunitType   , only : lun                
   use ColumnType     , only : col                
   use AnnualFluxDribbler, only : annual_flux_dribbler_type, annual_flux_dribbler_gridcell
@@ -26,7 +26,7 @@ module WaterFluxType
 
      class(water_info_base_type), pointer :: info
 
-     ! water fluxes are in units or mm/s
+     ! water fluxes are in units of mm/s
 
      real(r8), pointer :: qflx_through_snow_patch  (:)   ! patch canopy throughfall of snow (mm H2O/s)
      real(r8), pointer :: qflx_through_liq_patch  (:)    ! patch canopy throughfal of liquid (rain+irrigation) (mm H2O/s)
@@ -72,6 +72,10 @@ module WaterFluxType
      real(r8), pointer :: qflx_infl_col            (:)   ! col infiltration (mm H2O /s)
      real(r8), pointer :: qflx_surf_col            (:)   ! col total surface runoff (mm H2O /s)
      real(r8), pointer :: qflx_drain_col           (:)   ! col sub-surface runoff (mm H2O /s)
+     real(r8), pointer :: qflx_latflow_in_col      (:)   ! col hillslope lateral flow input (mm/s) 
+     real(r8), pointer :: qflx_latflow_out_col     (:)   ! col hillslope lateral flow output (mm/s) 
+     real(r8), pointer :: volumetric_discharge_col (:)   ! col hillslope discharge (m3/s)
+     real(r8), pointer :: volumetric_streamflow_lun(:)   ! lun stream discharge (m3/s)
      real(r8), pointer :: qflx_drain_perched_col   (:)   ! col sub-surface runoff from perched wt (mm H2O /s)                                                                                                      
      real(r8), pointer :: qflx_top_soil_col        (:)   ! col net water input into soil from top (mm/s)
      real(r8), pointer :: qflx_floodc_col          (:)   ! col flood water flux at column level
@@ -278,6 +282,18 @@ contains
     call AllocateVar1d(var = this%qflx_drain_perched_col, name = 'qflx_drain_perched_col', &
          container = tracer_vars, &
          bounds = bounds, subgrid_level = subgrid_level_column)
+    call AllocateVar1d(var = this%qflx_latflow_in_col, name = 'qflx_latflow_in_col', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_column)
+    call AllocateVar1d(var = this%qflx_latflow_out_col, name = 'qflx_latflow_out_col', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_column)
+    call AllocateVar1d(var = this%volumetric_discharge_col, name = 'volumetric_discharge_col', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_column)
+    call AllocateVar1d(var = this%volumetric_streamflow_lun, name = 'volumetric_streamflow_lun', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_landunit)
     call AllocateVar1d(var = this%qflx_top_soil_col, name = 'qflx_top_soil_col', &
          container = tracer_vars, &
          bounds = bounds, subgrid_level = subgrid_level_column)
@@ -386,6 +402,8 @@ contains
     !
     ! !USES:
     use histFileMod , only : hist_addfld1d, hist_addfld2d, no_snow_normal
+    use clm_varctl  , only : use_hillslope, use_hillslope_routing
+
     !
     ! !ARGUMENTS:
     class(waterflux_type), intent(in) :: this
@@ -394,12 +412,14 @@ contains
     ! !LOCAL VARIABLES:
     integer           :: begp, endp
     integer           :: begc, endc
+    integer           :: begl, endl
     integer           :: begg, endg
     real(r8), pointer :: data2dptr(:,:), data1dptr(:) ! temp. pointers for slicing larger arrays
     !------------------------------------------------------------------------
 
     begp = bounds%begp; endp= bounds%endp
     begc = bounds%begc; endc= bounds%endc
+    begl = bounds%begl; endl= bounds%endl
     begg = bounds%begg; endg= bounds%endg
 
     this%qflx_through_liq_patch(begp:endp) = spval
@@ -483,6 +503,37 @@ contains
          long_name=this%info%lname('sub-surface drainage'), &
          ptr_col=this%qflx_drain_col, c2l_scale_type='urbanf')
 
+    if (use_hillslope) then
+       this%qflx_latflow_out_col(begc:endc) = spval
+       call hist_addfld1d ( &
+            fname=this%info%fname('QLATFLOWOUT'),  &
+            units='mm/s',  &
+            avgflag='A', &
+            long_name=this%info%lname('hillcol lateral outflow'), &
+            l2g_scale_type='natveg', c2l_scale_type='urbanf', &
+            ptr_col=this%qflx_latflow_out_col)
+
+       this%volumetric_discharge_col(begc:endc) = spval
+       call hist_addfld1d ( &
+            fname=this%info%fname('VOLUMETRIC_DISCHARGE'),  &
+            units='m3/s',  &
+            avgflag='A', &
+            long_name=this%info%lname('hillslope discharge from column'), &
+            l2g_scale_type='natveg', c2l_scale_type='urbanf', &
+            ptr_col=this%volumetric_discharge_col,default='inactive')
+
+       if (use_hillslope_routing) then
+          this%volumetric_streamflow_lun(begl:endl) = spval
+          call hist_addfld1d ( &
+               fname=this%info%fname('VOLUMETRIC_STREAMFLOW'),  &
+               units='m3/s',  &
+               avgflag='A', &
+               long_name=this%info%lname('volumetric streamflow from hillslope'), &
+               l2g_scale_type='natveg', &
+               ptr_lunit=this%volumetric_streamflow_lun)
+       endif
+    endif
+
     this%qflx_drain_perched_col(begc:endc) = spval
     call hist_addfld1d ( &
          fname=this%info%fname('QDRAI_PERCH'),  &
@@ -810,6 +861,8 @@ contains
     !
     ! !USES:
     use landunit_varcon, only : istsoil, istcrop
+    use clm_varctl     , only : use_hillslope_routing
+
     !
     ! !ARGUMENTS:
     class(waterflux_type), intent(in) :: this
@@ -861,9 +914,19 @@ contains
        if (lun%itype(l) == istsoil .or. lun%itype(l) == istcrop) then
           this%qflx_drain_col(c) = 0._r8
           this%qflx_surf_col(c)  = 0._r8
+          this%qflx_latflow_in_col(c)  = 0._r8
+          this%qflx_latflow_out_col(c) = 0._r8
+          this%volumetric_discharge_col(c) = 0._r8
        end if
     end do
-
+    if (use_hillslope_routing) then
+       do l = bounds%begl, bounds%endl
+          if (lun%itype(l) == istsoil .or. lun%itype(l) == istcrop) then
+             this%volumetric_streamflow_lun(l) = 0._r8
+          end if
+       end do
+    endif
+          
   end subroutine InitCold
 
   !------------------------------------------------------------------------
diff --git a/src/biogeophys/WaterStateType.F90 b/src/biogeophys/WaterStateType.F90
index cdbefa2a0..6b6f59729 100644
--- a/src/biogeophys/WaterStateType.F90
+++ b/src/biogeophys/WaterStateType.F90
@@ -12,10 +12,10 @@ module WaterStateType
   use shr_log_mod    , only : errMsg => shr_log_errMsg
   use abortutils     , only : endrun
   use decompMod      , only : bounds_type
-  use decompMod      , only : subgrid_level_patch, subgrid_level_column, subgrid_level_gridcell
+  use decompMod      , only : subgrid_level_patch, subgrid_level_column, subgrid_level_landunit, subgrid_level_gridcell
   use clm_varctl     , only : use_bedrock, use_excess_ice, iulog
   use spmdMod        , only : masterproc
-  use clm_varctl     , only : use_fates
+  use clm_varctl     , only : use_fates, use_hillslope
   use clm_varpar     , only : nlevgrnd, nlevsoi, nlevurb, nlevmaxurbgrnd, nlevsno   
   use clm_varcon     , only : spval
   use LandunitType   , only : lun                
@@ -58,6 +58,9 @@ module WaterStateType
 
      type(excessicestream_type), private :: exicestream ! stream type for excess ice initialization NUOPC only
 
+     ! Hillslope stream variables
+     real(r8), pointer :: stream_water_volume_lun(:)   ! landunit volume of water in the streams (m3)
+
    contains
 
      procedure, public  :: Init
@@ -158,6 +161,9 @@ contains
     call AllocateVar1d(var = this%dynbal_baseline_ice_col, name = 'dynbal_baseline_ice_col', &
          container = tracer_vars, &
          bounds = bounds, subgrid_level = subgrid_level_column)
+    call AllocateVar1d(var = this%stream_water_volume_lun, name = 'stream_water_volume_lun', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_landunit)
     !excess ice vars
     call AllocateVar2d(var = this%excess_ice_col, name = 'excess_ice_col', &
          container = tracer_vars, &
@@ -178,6 +184,8 @@ contains
     ! !USES:
     use histFileMod    , only : hist_addfld1d, hist_addfld2d, no_snow_normal
     use clm_varctl     , only : use_soil_moisture_streams
+    use GridcellType   , only : grc  
+
     !
     ! !ARGUMENTS:
     class(waterstate_type), intent(in) :: this
@@ -187,12 +195,14 @@ contains
     ! !LOCAL VARIABLES:
     integer           :: begp, endp
     integer           :: begc, endc
+    integer           :: begl, endl
     integer           :: begg, endg
     real(r8), pointer :: data2dptr(:,:), data1dptr(:) ! temp. pointers for slicing larger arrays
     !------------------------------------------------------------------------
 
     begp = bounds%begp; endp= bounds%endp
     begc = bounds%begc; endc= bounds%endc
+    begl = bounds%begl; endl= bounds%endl
     begg = bounds%begg; endg= bounds%endg
 
     data2dptr => this%h2osoi_liq_col(:,-nlevsno+1:0)
@@ -284,6 +294,14 @@ contains
             ptr_col=this%wa_col, l2g_scale_type='veg')
     end if
 
+    if (use_hillslope) then
+       this%stream_water_volume_lun(begl:endl) = spval
+       call hist_addfld1d (fname=this%info%fname('STREAM_WATER_VOLUME'),  units='m3',  &
+            avgflag='A', &
+            long_name=this%info%lname('volume of water in stream channel (hillslope hydrology only)'), &
+            ptr_lunit=this%stream_water_volume_lun, l2g_scale_type='natveg',  default='inactive')
+    endif
+
     ! Add excess ice fields to history
 
     if (use_excess_ice) then
@@ -345,7 +363,7 @@ contains
       this%h2osfc_col(bounds%begc:bounds%endc) = 0._r8
       this%snocan_patch(bounds%begp:bounds%endp) = 0._r8
       this%liqcan_patch(bounds%begp:bounds%endp) = 0._r8
-
+      this%stream_water_volume_lun(bounds%begl:bounds%endl) = 0._r8
 
       !--------------------------------------------
       ! Set soil water
@@ -709,6 +727,13 @@ contains
          units='kg/m2', &
          interpinic_flag='interp', readvar=readvar, data=this%dynbal_baseline_ice_col)
 
+    call restartvar(ncid=ncid, flag=flag, &
+         varname=this%info%fname('STREAM_WATER_VOLUME'), &
+         xtype=ncd_double,  &
+         dim1name='landunit', &
+         long_name=this%info%lname('water in stream channel'), &
+         units='m3', &
+         interpinic_flag='interp', readvar=readvar, data=this%stream_water_volume_lun)
     ! Restart excess ice vars
     if (.not. use_excess_ice) then
        ! no need to even define the restart vars
diff --git a/src/biogeophys/Wateratm2lndBulkType.F90 b/src/biogeophys/Wateratm2lndBulkType.F90
index 03ee7522f..4aacbe11c 100644
--- a/src/biogeophys/Wateratm2lndBulkType.F90
+++ b/src/biogeophys/Wateratm2lndBulkType.F90
@@ -30,6 +30,8 @@ module Wateratm2lndBulkType
 
      real(r8), pointer :: volrmch_grc                   (:)   ! rof volr main channel (m3)
      real(r8), pointer :: volr_grc                      (:)   ! rof volr total volume (m3)
+     real(r8), pointer :: tdepth_grc                    (:)   ! rof tributary water depth (m)
+     real(r8), pointer :: tdepthmax_grc                 (:)   ! rof tributary bankfull water depth (m)
      real(r8), pointer :: forc_rh_grc                   (:)   ! atmospheric relative humidity (%)
      real(r8) , pointer :: prec365_col                  (:)   ! col 365-day running mean of tot. precipitation (see comment in UpdateAccVars regarding why this is col-level despite other prec accumulators being patch-level)
      real(r8) , pointer :: prec60_patch                 (:)   ! patch 60-day running mean of tot. precipitation (mm/s)
@@ -117,6 +119,8 @@ contains
     begc = bounds%begc; endc= bounds%endc
     begg = bounds%begg; endg= bounds%endg
 
+    allocate(this%tdepth_grc                    (begg:endg))        ; this%tdepth_grc    (:)   = ival
+    allocate(this%tdepthmax_grc                 (begg:endg))        ; this%tdepthmax_grc (:)   = ival
     allocate(this%volr_grc                      (begg:endg))        ; this%volr_grc    (:)   = ival
     allocate(this%volrmch_grc                   (begg:endg))        ; this%volrmch_grc (:)   = ival
     allocate(this%forc_rh_grc                   (begg:endg))        ; this%forc_rh_grc (:)   = ival
@@ -154,6 +158,15 @@ contains
     begp = bounds%begp; endp= bounds%endp
     begg = bounds%begg; endg= bounds%endg
 
+    this%tdepth_grc(begg:endg) = spval
+    call hist_addfld1d (fname='TDEPTH',  units='m',  &
+         avgflag='A', long_name='tributary water depth', &
+         ptr_lnd=this%tdepth_grc, default = 'inactive')
+
+    this%tdepthmax_grc(begg:endg) = spval
+    call hist_addfld1d (fname='TDEPTHMAX',  units='m',  &
+         avgflag='A', long_name='tributary bankfull water depth', &
+         ptr_lnd=this%tdepthmax_grc, default = 'inactive')
 
     this%volr_grc(begg:endg) = spval
     call hist_addfld1d (fname=this%info%fname('VOLR'),  units='m3',  &
@@ -462,6 +475,8 @@ contains
 
     ! rof->lnd
     deallocate(this%forc_flood_grc)
+    deallocate(this%tdepth_grc)
+    deallocate(this%tdepthmax_grc)
     deallocate(this%volr_grc)
     deallocate(this%volrmch_grc)
 
diff --git a/src/biogeophys/Waterlnd2atmType.F90 b/src/biogeophys/Waterlnd2atmType.F90
index 54972e9b0..80214bebb 100644
--- a/src/biogeophys/Waterlnd2atmType.F90
+++ b/src/biogeophys/Waterlnd2atmType.F90
@@ -32,6 +32,7 @@ module Waterlnd2atmType
      real(r8), pointer :: qflx_rofliq_qsub_grc    (:)   ! rof liq -- subsurface runoff component
      real(r8), pointer :: qflx_rofliq_qgwl_grc    (:)   ! rof liq -- glacier, wetland and lakes water balance residual component
      real(r8), pointer :: qflx_rofliq_drain_perched_grc    (:)   ! rof liq -- perched water table runoff component
+     real(r8), pointer :: qflx_rofliq_stream_grc  (:)   ! rof liq -- stream channel runoff component
      real(r8), pointer :: qflx_ice_runoff_col(:)   ! rof ice forcing, col level
      real(r8), pointer :: qflx_rofice_grc    (:)   ! rof ice forcing, grc level
      real(r8), pointer :: qflx_liq_from_ice_col(:) ! liquid runoff from converted ice runoff
@@ -120,6 +121,10 @@ contains
          container = tracer_vars, &
          bounds = bounds, subgrid_level = subgrid_level_gridcell, &
          ival=ival)
+    call AllocateVar1d(var = this%qflx_rofliq_stream_grc, name = 'qflx_rofliq_stream_grc', &
+         container = tracer_vars, &
+         bounds = bounds, subgrid_level = subgrid_level_gridcell, &
+         ival=ival)
     call AllocateVar1d(var = this%qflx_ice_runoff_col, name = 'qflx_ice_runoff_col', &
          container = tracer_vars, &
          bounds = bounds, subgrid_level = subgrid_level_column, &
diff --git a/src/cpl/lilac/lnd_import_export.F90 b/src/cpl/lilac/lnd_import_export.F90
index 281666c3e..bab24ed37 100644
--- a/src/cpl/lilac/lnd_import_export.F90
+++ b/src/cpl/lilac/lnd_import_export.F90
@@ -154,11 +154,11 @@ contains
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
 
     call state_getimport(importState, 'c2l_fb_atm', 'Faxa_swvdr', bounds, &
-         output=atm2lnd_inst%forc_solad_grc(:,1), rc=rc)
+         output=atm2lnd_inst%forc_solad_not_downscaled_grc(:,1), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
 
     call state_getimport(importState, 'c2l_fb_atm', 'Faxa_swndr', bounds, &
-         output=atm2lnd_inst%forc_solad_grc(:,2), rc=rc)
+         output=atm2lnd_inst%forc_solad_not_downscaled_grc(:,2), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
 
     call state_getimport(importState, 'c2l_fb_atm', 'Faxa_swvdf', bounds, &
diff --git a/src/cpl/mct/lnd_import_export.F90 b/src/cpl/mct/lnd_import_export.F90
index 3f7e67af6..537abd49d 100644
--- a/src/cpl/mct/lnd_import_export.F90
+++ b/src/cpl/mct/lnd_import_export.F90
@@ -10,6 +10,7 @@ module lnd_import_export
   use Waterlnd2atmBulkType , only: waterlnd2atmbulk_type
   use Wateratm2lndBulkType , only: wateratm2lndbulk_type
   use clm_cpl_indices
+  use GridcellType      , only : grc
   !
   implicit none
   !===============================================================================
@@ -96,8 +97,8 @@ contains
        atm2lnd_inst%forc_topo_grc(g)                 = x2l(index_x2l_Sa_topo,i)      ! Atm surface height (m)
        atm2lnd_inst%forc_u_grc(g)                    = x2l(index_x2l_Sa_u,i)         ! forc_uxy  Atm state m/s
        atm2lnd_inst%forc_v_grc(g)                    = x2l(index_x2l_Sa_v,i)         ! forc_vxy  Atm state m/s
-       atm2lnd_inst%forc_solad_grc(g,2)              = x2l(index_x2l_Faxa_swndr,i)   ! forc_sollxy  Atm flux  W/m^2
-       atm2lnd_inst%forc_solad_grc(g,1)              = x2l(index_x2l_Faxa_swvdr,i)   ! forc_solsxy  Atm flux  W/m^2
+       atm2lnd_inst%forc_solad_not_downscaled_grc(g,2) = x2l(index_x2l_Faxa_swndr,i)   ! forc_sollxy  Atm flux  W/m^2
+       atm2lnd_inst%forc_solad_not_downscaled_grc(g,1) = x2l(index_x2l_Faxa_swvdr,i)   ! forc_solsxy  Atm flux  W/m^2
        atm2lnd_inst%forc_solai_grc(g,2)              = x2l(index_x2l_Faxa_swndf,i)   ! forc_solldxy Atm flux  W/m^2
        atm2lnd_inst%forc_solai_grc(g,1)              = x2l(index_x2l_Faxa_swvdf,i)   ! forc_solsdxy Atm flux  W/m^2
 
diff --git a/src/cpl/nuopc/lnd_import_export.F90 b/src/cpl/nuopc/lnd_import_export.F90
index 5ed5ff76d..d1deec0f0 100644
--- a/src/cpl/nuopc/lnd_import_export.F90
+++ b/src/cpl/nuopc/lnd_import_export.F90
@@ -9,7 +9,7 @@ module lnd_import_export
   use NUOPC_Model             , only : NUOPC_ModelGet
   use shr_kind_mod            , only : r8 => shr_kind_r8, cx=>shr_kind_cx, cxx=>shr_kind_cxx, cs=>shr_kind_cs
   use shr_sys_mod             , only : shr_sys_abort
-  use clm_varctl              , only : iulog
+  use clm_varctl              , only : iulog, use_hillslope_routing
   use clm_time_manager        , only : get_nstep
   use decompmod               , only : bounds_type, get_proc_bounds
   use lnd2atmType             , only : lnd2atm_type
@@ -99,6 +99,8 @@ module lnd_import_export
   character(*), parameter :: Flrr_flood          = 'Flrr_flood'
   character(*), parameter :: Flrr_volr           = 'Flrr_volr'
   character(*), parameter :: Flrr_volrmch        = 'Flrr_volrmch'
+  character(*), parameter :: Sr_tdepth           = 'Sr_tdepth'
+  character(*), parameter :: Sr_tdepth_max       = 'Sr_tdepth_max'
   character(*), parameter :: Sg_ice_covered_elev = 'Sg_ice_covered_elev'
   character(*), parameter :: Sg_topo_elev        = 'Sg_topo_elev'
   character(*), parameter :: Flgg_hflx_elev      = 'Flgg_hflx_elev'
@@ -388,6 +390,8 @@ contains
        call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_flood   )
        call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_volr    )
        call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_volrmch )
+       call fldlist_add(fldsToLnd_num, fldsToLnd, Sr_tdepth )
+       call fldlist_add(fldsToLnd_num, fldsToLnd, Sr_tdepth_max )
     end if
 
     if (glc_present) then
@@ -549,9 +553,9 @@ contains
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
     call state_getimport_1d(importState, Faxa_lwdn , atm2lnd_inst%forc_lwrad_not_downscaled_grc(begg:), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
-    call state_getimport_1d(importState, Faxa_swvdr, atm2lnd_inst%forc_solad_grc(begg:,1), rc=rc)
+    call state_getimport_1d(importState, Faxa_swvdr, atm2lnd_inst%forc_solad_not_downscaled_grc(begg:,1), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
-    call state_getimport_1d(importState, Faxa_swndr, atm2lnd_inst%forc_solad_grc(begg:,2), rc=rc)
+    call state_getimport_1d(importState, Faxa_swndr, atm2lnd_inst%forc_solad_not_downscaled_grc(begg:,2), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
     call state_getimport_1d(importState, Faxa_swvdf, atm2lnd_inst%forc_solai_grc(begg:,1), rc=rc)
     if (ChkErr(rc,__LINE__,u_FILE_u)) return
@@ -608,6 +612,20 @@ contains
        wateratm2lndbulk_inst%volrmch_grc(:) = 0._r8
     end if
 
+    if (fldchk(importState, Sr_tdepth)) then
+       call state_getimport_1d(importState, Sr_tdepth, wateratm2lndbulk_inst%tdepth_grc(begg:), rc=rc)
+       if (ChkErr(rc,__LINE__,u_FILE_u)) return
+    else
+       wateratm2lndbulk_inst%tdepth_grc(:) = 0._r8
+    end if
+
+    if (fldchk(importState, Sr_tdepth_max)) then
+       call state_getimport_1d(importState, Sr_tdepth_max, wateratm2lndbulk_inst%tdepthmax_grc(begg:), rc=rc)
+       if (ChkErr(rc,__LINE__,u_FILE_u)) return
+    else
+       wateratm2lndbulk_inst%tdepthmax_grc(:) = 0._r8
+    end if
+
     !--------------------------
     ! Derived quantities for required fields
     ! and corresponding error checks
@@ -890,7 +908,11 @@ contains
        ! subsurface runoff is the sum of qflx_drain and qflx_perched_drain
        do g = begg, endg
           data1d(g) = waterlnd2atmbulk_inst%qflx_rofliq_qsub_grc(g) + &
-                      waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(g)
+               waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(g)
+          if(use_hillslope_routing) then
+             data1d(g) = data1d(g) + &
+                  waterlnd2atmbulk_inst%qflx_rofliq_stream_grc(g)
+          endif
        end do
        call state_setexport_1d(exportState, Flrl_rofsub, data1d(begg:),  init_spval=.true., rc=rc)
        if (ChkErr(rc,__LINE__,u_FILE_u)) return
diff --git a/src/cpl/utils/lnd_import_export_utils.F90 b/src/cpl/utils/lnd_import_export_utils.F90
index 4b7941da5..1b40cb0e6 100644
--- a/src/cpl/utils/lnd_import_export_utils.F90
+++ b/src/cpl/utils/lnd_import_export_utils.F90
@@ -76,8 +76,11 @@ contains
 
        atm2lnd_inst%forc_wind_grc(g) = sqrt(atm2lnd_inst%forc_u_grc(g)**2 + atm2lnd_inst%forc_v_grc(g)**2)
 
-       atm2lnd_inst%forc_solar_grc(g) = atm2lnd_inst%forc_solad_grc(g,1) + atm2lnd_inst%forc_solai_grc(g,1) + &
-                                        atm2lnd_inst%forc_solad_grc(g,2) + atm2lnd_inst%forc_solai_grc(g,2)
+       atm2lnd_inst%forc_solar_not_downscaled_grc(g) = &
+              atm2lnd_inst%forc_solad_not_downscaled_grc(g,1) &
+            + atm2lnd_inst%forc_solai_grc(g,1) &
+            + atm2lnd_inst%forc_solad_not_downscaled_grc(g,2) &
+            + atm2lnd_inst%forc_solai_grc(g,2)
 
        wateratm2lndbulk_inst%forc_rain_not_downscaled_grc(g)  = forc_rainc(g) + forc_rainl(g)
        wateratm2lndbulk_inst%forc_snow_not_downscaled_grc(g)  = forc_snowc(g) + forc_snowl(g)
@@ -118,8 +121,8 @@ contains
           call shr_sys_abort( subname//&
                ' ERROR: Longwave down sent from the atmosphere model is negative or zero' )
        end if
-       if ( (atm2lnd_inst%forc_solad_grc(g,1) < 0.0_r8) .or. &
-            (atm2lnd_inst%forc_solad_grc(g,2) < 0.0_r8) .or. &
+       if ( (atm2lnd_inst%forc_solad_not_downscaled_grc(g,1) < 0.0_r8) .or. &
+            (atm2lnd_inst%forc_solad_not_downscaled_grc(g,2) < 0.0_r8) .or. &
             (atm2lnd_inst%forc_solai_grc(g,1) < 0.0_r8) .or. &
             (atm2lnd_inst%forc_solai_grc(g,2) < 0.0_r8) ) then
           call shr_sys_abort( subname//&
@@ -141,6 +144,7 @@ contains
   !=============================================================================
 
   subroutine check_for_nans(array, fname, begg, direction)
+    use GridcellType    , only : grc                
 
     ! input/output variables
     real(r8)         , intent(in) :: array(:)
@@ -159,7 +163,7 @@ contains
        write(iulog,*) 'Which are NaNs = ', isnan(array)
        do i = 1, size(array)
           if (isnan(array(i))) then
-             write(iulog,*) "NaN found in field ", trim(fname), ' at gridcell index ',begg+i-1
+             write(iulog,*) "NaN found in field ", trim(fname), ' at gridcell index/lon/lat: ',begg+i-1,grc%londeg(begg+i-1),grc%latdeg(begg+i-1)
           end if
        end do
        call shr_sys_abort(' ERROR: One or more of the CTSM cap '//direction//' fields are NaN ' )
diff --git a/src/main/ColumnType.F90 b/src/main/ColumnType.F90
index 5f57b3ed2..7461032ca 100644
--- a/src/main/ColumnType.F90
+++ b/src/main/ColumnType.F90
@@ -68,8 +68,20 @@ module ColumnType
      real(r8), pointer :: z_lake               (:,:) ! layer depth for lake (m)
      real(r8), pointer :: lakedepth            (:)   ! variable lake depth (m)                             
      integer , pointer :: nbedrock             (:)   ! variable depth to bedrock index
+     ! hillslope hydrology variables
+     integer,  pointer :: col_ndx              (:)   ! column index of column (hillslope hydrology)
+     integer,  pointer :: colu                 (:)   ! column index of uphill column (hillslope hydrology)
+     integer,  pointer :: cold                 (:)   ! column index of downhill column (hillslope hydrology)
+     integer,  pointer :: hillslope_ndx        (:)   ! hillslope identifier
+     real(r8), pointer :: hill_elev            (:)   ! mean elevation of column relative to stream channel (m)
+     real(r8), pointer :: hill_slope           (:)   ! mean along-hill slope (m/m)
+     real(r8), pointer :: hill_area            (:)   ! mean surface area (m2)
+     real(r8), pointer :: hill_width           (:)   ! across-hill width of bottom boundary of column (m)
+     real(r8), pointer :: hill_distance        (:)   ! along-hill distance of column from bottom of hillslope (m)
+     real(r8), pointer :: hill_aspect          (:)   ! azimuth angle of column wrt to north, positive to east (radians)
 
      ! other column characteristics
+     logical , pointer :: is_hillslope_column(:)     ! true if this column is a hillslope element
      logical , pointer :: hydrologically_active(:)   ! true if this column is a hydrologically active type
      logical , pointer :: urbpoi               (:)   ! true=>urban point
 
@@ -130,13 +142,22 @@ contains
     allocate(this%lakedepth   (begc:endc))                     ; this%lakedepth   (:)   = spval  
     allocate(this%dz_lake     (begc:endc,nlevlak))             ; this%dz_lake     (:,:) = nan
     allocate(this%z_lake      (begc:endc,nlevlak))             ; this%z_lake      (:,:) = nan
-
+    allocate(this%col_ndx    (begc:endc))                      ; this%col_ndx(:) = ispval  
+    allocate(this%colu       (begc:endc))                      ; this%colu   (:) = ispval  
+    allocate(this%cold       (begc:endc))                      ; this%cold   (:) = ispval  
+    allocate(this%hillslope_ndx(begc:endc))                    ; this%hillslope_ndx (:) = ispval  
+    allocate(this%hill_elev(begc:endc))                        ; this%hill_elev     (:) = spval  
+    allocate(this%hill_slope(begc:endc))                       ; this%hill_slope    (:) = spval  
+    allocate(this%hill_area(begc:endc))                        ; this%hill_area     (:) = spval  
+    allocate(this%hill_width(begc:endc))                       ; this%hill_width    (:) = spval  
+    allocate(this%hill_distance(begc:endc))                    ; this%hill_distance (:) = spval  
+    allocate(this%hill_aspect(begc:endc))                      ; this%hill_aspect (:) = spval  
     allocate(this%nbedrock   (begc:endc))                      ; this%nbedrock   (:)   = ispval  
     allocate(this%levgrnd_class(begc:endc,nlevmaxurbgrnd))     ; this%levgrnd_class(:,:) = ispval
     allocate(this%micro_sigma (begc:endc))                     ; this%micro_sigma (:)   = nan
     allocate(this%topo_slope  (begc:endc))                     ; this%topo_slope  (:)   = nan
     allocate(this%topo_std    (begc:endc))                     ; this%topo_std    (:)   = nan
-
+    allocate(this%is_hillslope_column(begc:endc))              ; this%is_hillslope_column(:) = .false.
     allocate(this%hydrologically_active(begc:endc))            ; this%hydrologically_active(:) = .false.
     allocate(this%urbpoi      (begc:endc))                     ; this%urbpoi      (:)   = .false.
 
@@ -174,9 +195,19 @@ contains
     deallocate(this%topo_std   )
     deallocate(this%nbedrock   )
     deallocate(this%levgrnd_class)
+    deallocate(this%is_hillslope_column)
     deallocate(this%hydrologically_active)
-    deallocate(this%urbpoi)
-
+    deallocate(this%col_ndx    )
+    deallocate(this%colu       )
+    deallocate(this%cold       )
+    deallocate(this%hillslope_ndx)
+    deallocate(this%hill_elev    )
+    deallocate(this%hill_slope   )
+    deallocate(this%hill_area    )
+    deallocate(this%hill_width   )
+    deallocate(this%hill_distance)
+    deallocate(this%hill_aspect  )
+    deallocate(this%urbpoi       )
   end subroutine Clean
 
   !-----------------------------------------------------------------------
diff --git a/src/main/LandunitType.F90 b/src/main/LandunitType.F90
index 22770d233..3a5c68c4f 100644
--- a/src/main/LandunitType.F90
+++ b/src/main/LandunitType.F90
@@ -32,6 +32,7 @@ module LandunitType
      integer , pointer :: coli         (:) ! beginning column index per landunit
      integer , pointer :: colf         (:) ! ending column index for each landunit
      integer , pointer :: ncolumns     (:) ! number of columns for each landunit
+     integer , pointer :: nhillslopes  (:) ! number of hillslopes for each landunit
      integer , pointer :: patchi       (:) ! beginning patch index for each landunit
      integer , pointer :: patchf       (:) ! ending patch index for each landunit
      integer , pointer :: npatches     (:) ! number of patches for each landunit
@@ -52,6 +53,13 @@ module LandunitType
      real(r8), pointer :: z_0_town     (:) ! urban landunit momentum roughness length (m)
      real(r8), pointer :: z_d_town     (:) ! urban landunit displacement height (m)
 
+     ! hillslope variables
+     real(r8), pointer :: stream_channel_depth   (:) ! stream channel bankfull depth (m)
+     real(r8), pointer :: stream_channel_width   (:) ! stream channel bankfull width (m)
+     real(r8), pointer :: stream_channel_length  (:) ! stream channel length (m)
+     real(r8), pointer :: stream_channel_slope   (:) ! stream channel slope (m/m)
+     real(r8), pointer :: stream_channel_number  (:) ! number of channels in landunit
+
    contains
 
      procedure, public :: Init    ! Allocate and initialize
@@ -82,6 +90,7 @@ contains
     allocate(this%coli         (begl:endl)); this%coli      (:) = ispval
     allocate(this%colf         (begl:endl)); this%colf      (:) = ispval
     allocate(this%ncolumns     (begl:endl)); this%ncolumns  (:) = ispval
+    allocate(this%nhillslopes  (begl:endl)); this%nhillslopes(:) = ispval
     allocate(this%patchi       (begl:endl)); this%patchi    (:) = ispval
     allocate(this%patchf       (begl:endl)); this%patchf    (:) = ispval
     allocate(this%npatches     (begl:endl)); this%npatches  (:) = ispval
@@ -102,6 +111,13 @@ contains
     allocate(this%z_0_town     (begl:endl)); this%z_0_town     (:) = nan
     allocate(this%z_d_town     (begl:endl)); this%z_d_town     (:) = nan
 
+    ! Hillslope variables initialized in HillslopeHydrologyMod
+    allocate(this%stream_channel_depth(begl:endl));  this%stream_channel_depth   (:) = nan
+    allocate(this%stream_channel_width(begl:endl));  this%stream_channel_width   (:) = nan
+    allocate(this%stream_channel_length(begl:endl)); this%stream_channel_length  (:) = nan
+    allocate(this%stream_channel_slope(begl:endl));  this%stream_channel_slope   (:) = nan
+    allocate(this%stream_channel_number(begl:endl)); this%stream_channel_number  (:) = nan
+
   end subroutine Init
 
   !------------------------------------------------------------------------
@@ -119,6 +135,7 @@ contains
     deallocate(this%coli         )
     deallocate(this%colf         )
     deallocate(this%ncolumns     )
+    deallocate(this%nhillslopes  )
     deallocate(this%patchi       )
     deallocate(this%patchf       )
     deallocate(this%npatches     )
@@ -134,7 +151,11 @@ contains
     deallocate(this%wtlunit_roof )
     deallocate(this%z_0_town     )
     deallocate(this%z_d_town     )
-
+    deallocate(this%stream_channel_depth)
+    deallocate(this%stream_channel_width)
+    deallocate(this%stream_channel_length)
+    deallocate(this%stream_channel_slope)
+    deallocate(this%stream_channel_number)
   end subroutine Clean
 
 end module LandunitType
diff --git a/src/main/TopoMod.F90 b/src/main/TopoMod.F90
index e14762cc2..b081c7748 100644
--- a/src/main/TopoMod.F90
+++ b/src/main/TopoMod.F90
@@ -13,8 +13,9 @@ module TopoMod
   use LandunitType   , only : lun
   use glc2lndMod     , only : glc2lnd_type
   use glcBehaviorMod , only : glc_behavior_type
-  use landunit_varcon, only : istice
+  use landunit_varcon, only : istice, istsoil
   use filterColMod   , only : filter_col_type, col_filter_from_logical_array_active_only
+  use clm_varctl     , only : use_hillslope, downscale_hillslope_meteorology
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -139,8 +140,14 @@ contains
           ! For other landunits, arbitrarily initialize topo_col to 0 m; for landunits
           ! where this matters, this will get overwritten in the run loop by values sent
           ! from CISM
-          this%topo_col(c) = 0._r8
-          this%needs_downscaling_col(c) = .false.
+          if (col%is_hillslope_column(c) .and. downscale_hillslope_meteorology) then
+             this%topo_col(c) = col%hill_elev(c)
+             this%needs_downscaling_col(c) = .true.
+          else
+             this%topo_col(c) = 0._r8
+             this%needs_downscaling_col(c) = .false.
+          endif
+
        end if
     end do
 
@@ -218,7 +225,9 @@ contains
     !
     ! !LOCAL VARIABLES:
     integer :: begc, endc
-    integer :: c, g
+    integer :: c, l, g
+    real(r8), allocatable :: mean_hillslope_elevation(:)
+    real(r8):: mhe_norm
 
     character(len=*), parameter :: subname = 'UpdateTopo'
     !-----------------------------------------------------------------------
@@ -240,18 +249,48 @@ contains
          this%topo_col(begc:endc), &
          this%needs_downscaling_col(begc:endc))
 
-    ! For any point that isn't downscaled, set its topo value to the atmosphere's
-    ! topographic height. This shouldn't matter, but is useful if topo_col is written to
-    ! the history file.
-    !
+    ! calculate area-weighted mean hillslope elevation on each landunit
+    if (use_hillslope) then
+       allocate(mean_hillslope_elevation(bounds%begl:bounds%endl))
+       mean_hillslope_elevation(:) = 0._r8
+       do l = bounds%begl, bounds%endl
+          mhe_norm = 0._r8
+          do c = lun%coli(l), lun%colf(l)
+             if (col%is_hillslope_column(c)) then
+                mean_hillslope_elevation(l) = mean_hillslope_elevation(l) &
+                     + col%hill_elev(c)*col%hill_area(c)
+                mhe_norm = mhe_norm + col%hill_area(c)
+             endif
+          enddo
+          if (mhe_norm > 0) then
+             mean_hillslope_elevation(l) = mean_hillslope_elevation(l)/mhe_norm
+          endif
+       enddo
+    endif
+       
     ! This could operate over a filter like 'allc' in order to just operate over active
     ! points, but I'm not sure that would speed things up much, and would require passing
     ! in this additional filter.
+
     do c = bounds%begc, bounds%endc
        if (.not. this%needs_downscaling_col(c)) then
+          ! For any point that isn't already set to be downscaled, set its topo value to the
+          ! atmosphere's topographic height. This is important for the hillslope block
+          ! below. For non-hillslope columns, this shouldn't matter, but is useful if
+          ! topo_col is written to the history file.
           g = col%gridcell(c)
           this%topo_col(c) = atm_topo(g)
        end if
+       ! If needs_downscaling_col was already set, then that implies
+       ! that topo_col was previously set by update_glc2lnd_topo.
+       ! In that case, topo_col should be used as a starting point,
+       ! rather than the atmosphere's topo value.
+       if (col%is_hillslope_column(c) .and. downscale_hillslope_meteorology) then
+          l = col%landunit(c)
+          this%topo_col(c) =  this%topo_col(c) &
+               + (col%hill_elev(c) - mean_hillslope_elevation(l))
+          this%needs_downscaling_col(c) = .true.
+       endif
     end do
 
     call glc_behavior%update_glc_classes(bounds, this%topo_col(begc:endc))
diff --git a/src/main/atm2lndMod.F90 b/src/main/atm2lndMod.F90
index 11e05f149..b35c6ae86 100644
--- a/src/main/atm2lndMod.F90
+++ b/src/main/atm2lndMod.F90
@@ -18,12 +18,14 @@ module atm2lndMod
   use decompMod      , only : bounds_type, subgrid_level_gridcell, subgrid_level_column
   use atm2lndType    , only : atm2lnd_type
   use TopoMod        , only : topo_type
+  use SurfaceAlbedoType, only : surfalb_type
   use filterColMod   , only : filter_col_type
   use LandunitType   , only : lun                
   use ColumnType     , only : col
   use landunit_varcon, only : istice
   use WaterType      , only : water_type
   use Wateratm2lndBulkType, only : wateratm2lndbulk_type
+
   !
   ! !PUBLIC TYPES:
   implicit none
@@ -46,6 +48,9 @@ module atm2lndMod
   private :: build_normalization              ! Compute normalization factors so that downscaled fields are conservative
   private :: check_downscale_consistency      ! Check consistency of downscaling
 
+  private :: downscale_hillslope_solar         ! Downscale incoming direct solar radiation based on local slope and aspect.
+  private :: downscale_hillslope_precipitation ! Downscale precipitation based on local topographic height.
+
   character(len=*), parameter, private :: sourcefile = &
        __FILE__
   !-----------------------------------------------------------------------
@@ -91,7 +96,7 @@ contains
 
   !-----------------------------------------------------------------------
   subroutine downscale_forcings(bounds, &
-       topo_inst, atm2lnd_inst, wateratm2lndbulk_inst, eflx_sh_precip_conversion)
+       topo_inst, atm2lnd_inst, surfalb_inst, wateratm2lndbulk_inst, eflx_sh_precip_conversion)
     !
     ! !DESCRIPTION:
     ! Downscale atmospheric forcing fields from gridcell to column.
@@ -111,12 +116,14 @@ contains
     !
     ! !USES:
     use clm_varcon      , only : rair, cpair, grav
+    use clm_varctl      , only : use_hillslope,downscale_hillslope_meteorology
     use QsatMod         , only : Qsat
     !
     ! !ARGUMENTS:
     type(bounds_type)  , intent(in)    :: bounds  
     class(topo_type)   , intent(in)    :: topo_inst
     type(atm2lnd_type) , intent(inout) :: atm2lnd_inst
+    class(surfalb_type)   , intent(in)    :: surfalb_inst
     type(wateratm2lndbulk_type) , intent(inout) :: wateratm2lndbulk_inst
     real(r8)           , intent(out)   :: eflx_sh_precip_conversion(bounds%begc:) ! sensible heat flux from precipitation conversion (W/m**2) [+ to atm]
     !
@@ -143,6 +150,8 @@ contains
 
          ! Gridcell-level metadata:
          forc_topo_g  => atm2lnd_inst%forc_topo_grc                , & ! Input:  [real(r8) (:)]  atmospheric surface height (m)
+         forc_rain_g  => wateratm2lndbulk_inst%forc_rain_not_downscaled_grc , & ! Input:  [real(r8) (:)]  rain rate [mm/s]
+         forc_snow_g  => wateratm2lndbulk_inst%forc_snow_not_downscaled_grc , & ! Input:  [real(r8) (:)]  snow rate [mm/s]
 
          ! Column-level metadata:
          topo_c       => topo_inst%topo_col                        , & ! Input:  [real(r8) (:)] column surface height (m)
@@ -153,13 +162,19 @@ contains
          forc_q_g     => wateratm2lndbulk_inst%forc_q_not_downscaled_grc    , & ! Input:  [real(r8) (:)]  atmospheric specific humidity (kg/kg)   
          forc_pbot_g  => atm2lnd_inst%forc_pbot_not_downscaled_grc , & ! Input:  [real(r8) (:)]  atmospheric pressure (Pa)               
          forc_rho_g   => atm2lnd_inst%forc_rho_not_downscaled_grc  , & ! Input:  [real(r8) (:)]  atmospheric density (kg/m**3)           
-         
+         forc_solad_g => atm2lnd_inst%forc_solad_not_downscaled_grc               , & ! Input:  [real(r8) (:)]  gridcell direct incoming solar radiation
+         forc_solar_g => atm2lnd_inst%forc_solar_not_downscaled_grc, & ! Input:  [real(r8) (:)]  gridcell direct incoming solar radiation
+
          ! Column-level downscaled fields:
+         forc_rain_c  => wateratm2lndbulk_inst%forc_rain_downscaled_col    , & ! Output: [real(r8) (:)]  rain rate [mm/s]
+         forc_snow_c  => wateratm2lndbulk_inst%forc_snow_downscaled_col    , & ! Output: [real(r8) (:)]  snow rate [mm/s]
+         forc_q_c     => wateratm2lndbulk_inst%forc_q_downscaled_col       , & ! Output: [real(r8) (:)]  atmospheric specific humidity (kg/kg)   
          forc_t_c     => atm2lnd_inst%forc_t_downscaled_col        , & ! Output: [real(r8) (:)]  atmospheric temperature (Kelvin)        
          forc_th_c    => atm2lnd_inst%forc_th_downscaled_col       , & ! Output: [real(r8) (:)]  atmospheric potential temperature (Kelvin)
-         forc_q_c     => wateratm2lndbulk_inst%forc_q_downscaled_col        , & ! Output: [real(r8) (:)]  atmospheric specific humidity (kg/kg)   
          forc_pbot_c  => atm2lnd_inst%forc_pbot_downscaled_col     , & ! Output: [real(r8) (:)]  atmospheric pressure (Pa)               
-         forc_rho_c   => atm2lnd_inst%forc_rho_downscaled_col        & ! Output: [real(r8) (:)]  atmospheric density (kg/m**3)           
+         forc_rho_c   => atm2lnd_inst%forc_rho_downscaled_col      , & ! Output: [real(r8) (:)]  atmospheric density (kg/m**3)           
+         forc_solad_c => atm2lnd_inst%forc_solad_downscaled_col    , & ! Output:  [real(r8) (:)]  column direct incoming solar radiation
+         forc_solar_c => atm2lnd_inst%forc_solar_downscaled_col      & ! Output:  [real(r8) (:)]  column total incoming solar radiation
          )
       
       ! Initialize column forcing (needs to be done for ALL active columns)
@@ -167,11 +182,15 @@ contains
          if (col%active(c)) then
             g = col%gridcell(c)
 
+            forc_rain_c(c)  = forc_rain_g(g)
+            forc_snow_c(c)  = forc_snow_g(g)
             forc_t_c(c)     = forc_t_g(g)
             forc_th_c(c)    = forc_th_g(g)
             forc_q_c(c)     = forc_q_g(g)
             forc_pbot_c(c)  = forc_pbot_g(g)
             forc_rho_c(c)   = forc_rho_g(g)
+            forc_solar_c(c) = forc_solar_g(g)
+            forc_solad_c(c,1:numrad) = forc_solad_g(g,1:numrad)
          end if
       end do
 
@@ -247,6 +266,12 @@ contains
 
       end do
 
+      ! adjust hillslope precpitation before repartitioning rain/snow
+      if(use_hillslope .and. downscale_hillslope_meteorology) then
+         call downscale_hillslope_solar(bounds, atm2lnd_inst, surfalb_inst)
+         call downscale_hillslope_precipitation(bounds, topo_inst, atm2lnd_inst, wateratm2lndbulk_inst)
+      endif
+
       call partition_precip(bounds, atm2lnd_inst, wateratm2lndbulk_inst, &
            eflx_sh_precip_conversion(bounds%begc:bounds%endc))
 
@@ -312,10 +337,6 @@ contains
     SHR_ASSERT_ALL_FL((ubound(eflx_sh_precip_conversion) == (/bounds%endc/)), sourcefile, __LINE__)
 
     associate(&
-         ! Gridcell-level non-downscaled fields:
-         forc_rain_g  => wateratm2lndbulk_inst%forc_rain_not_downscaled_grc , & ! Input:  [real(r8) (:)]  rain rate [mm/s]
-         forc_snow_g  => wateratm2lndbulk_inst%forc_snow_not_downscaled_grc , & ! Input:  [real(r8) (:)]  snow rate [mm/s]
-         
          ! Column-level downscaled fields:
          forc_t_c                  => atm2lnd_inst%forc_t_downscaled_col                , & ! Input:  [real(r8) (:)]  atmospheric temperature (Kelvin)        
          forc_rain_c               => wateratm2lndbulk_inst%forc_rain_downscaled_col    , & ! Output: [real(r8) (:)]  rain rate [mm/s]
@@ -328,8 +349,6 @@ contains
     do c = bounds%begc,bounds%endc
        if (col%active(c)) then
           g = col%gridcell(c)
-          forc_rain_c(c)  = forc_rain_g(g)
-          forc_snow_c(c)  = forc_snow_g(g)
           rain_to_snow_conversion_c(c) = 0._r8
           snow_to_rain_conversion_c(c) = 0._r8
           eflx_sh_precip_conversion(c) = 0._r8
@@ -719,4 +738,250 @@ contains
 
   end subroutine check_downscale_consistency
 
+  subroutine downscale_hillslope_solar(bounds, atm2lnd_inst, surfalb_inst)
+    !
+    ! !DESCRIPTION:
+    ! Downscale incoming direct solar radiation based on local slope and aspect.
+    !
+    ! This is currently applied over columns
+    !
+    ! USES
+    use clm_varpar    , only : numrad
+
+    ! !ARGUMENTS:
+    type(bounds_type)  , intent(in)    :: bounds  
+    type(surfalb_type) , intent(in)    :: surfalb_inst
+    type(atm2lnd_type) , intent(inout) :: atm2lnd_inst
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: c,l,g,n      ! indices
+    real(r8) :: norm(numrad)
+    real(r8) :: sum_solar(bounds%begg:bounds%endg,numrad)
+    real(r8) :: sum_wtgcell(bounds%begg:bounds%endg)
+    real(r8) :: illum_frac(bounds%begg:bounds%endg)
+    real(r8), parameter :: illumination_threshold = 0.05
+    logical  :: checkConservation = .true.
+
+    character(len=*), parameter :: subname = 'downscale_hillslope_solar'
+    !-----------------------------------------------------------------------
+    
+    associate(&
+         ! Gridcell-level fields:
+         forc_solai_grc  =>    atm2lnd_inst%forc_solai_grc , & ! Input:  [real(r8) (:)]  gridcell indirect incoming solar radiation
+         forc_solad_grc  =>    atm2lnd_inst%forc_solad_not_downscaled_grc , & ! Input:  [real(r8) (:)]  gridcell direct incoming solar radiation
+         coszen_grc      =>    surfalb_inst%coszen_grc     , & ! Input:  [real(r8) (:)]  cosine of solar zenith angle            
+         
+         ! Column-level fields:
+         coszen_col                 =>    surfalb_inst%coszen_col                , & ! Input:   [real(r8) (:)]  cosine of solar zenith angle            
+         forc_solar_col  =>    atm2lnd_inst%forc_solar_downscaled_col , & ! Output:  [real(r8) (:)]  column total incoming solar radiation
+         forc_solad_col  =>    atm2lnd_inst%forc_solad_downscaled_col   & ! Output:  [real(r8) (:)]  column direct incoming solar radiation
+         )
+      
+      ! Initialize column forcing
+      sum_solar(bounds%begg:bounds%endg,1:numrad) = 0._r8
+      sum_wtgcell(bounds%begg:bounds%endg) = 0._r8
+      illum_frac(bounds%begg:bounds%endg)  = 0._r8
+      do c = bounds%begc,bounds%endc
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+            g = col%gridcell(c)
+            if (coszen_grc(g) > 0._r8) then
+               forc_solad_col(c,1:numrad)  = forc_solad_grc(g,1:numrad)*(coszen_col(c)/coszen_grc(g))
+               if (coszen_col(c) > 0._r8) then
+                  illum_frac(g) = illum_frac(g) + col%wtgcell(c)
+               endif
+            endif
+            
+            sum_solar(g,1:numrad) = sum_solar(g,1:numrad) + col%wtgcell(c)*forc_solad_col(c,1:numrad)
+            sum_wtgcell(g) = sum_wtgcell(g) + col%wtgcell(c)
+         end if
+      end do
+      
+      ! Calculate illuminated fraction of gridcell
+      do g = bounds%begg,bounds%endg
+         if (sum_wtgcell(g) > 0._r8) then
+            illum_frac(g) = illum_frac(g)/sum_wtgcell(g)
+         endif
+      enddo
+      
+      ! Normalize column level solar
+      do c = bounds%begc,bounds%endc
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+            g = col%gridcell(c)
+            do n = 1,numrad
+               ! absorbed energy is solar flux x area landunit (sum_wtgcell)
+               if(sum_solar(g,n) > 0._r8 .and. illum_frac(g) > illumination_threshold) then
+                  norm(n) = sum_wtgcell(g)*forc_solad_grc(g,n)/sum_solar(g,n)
+                  forc_solad_col(c,n)  = forc_solad_col(c,n)*norm(n)
+               else
+                  forc_solad_col(c,n)  = forc_solad_grc(g,n)
+               endif
+            enddo
+            forc_solar_col(c) = sum(forc_solad_col(c,1:numrad))+sum(forc_solai_grc(g,1:numrad))
+         end if
+         
+      end do
+
+      ! check conservation
+      if(checkConservation)  then
+         sum_solar(bounds%begg:bounds%endg,1:numrad) = 0._r8
+         sum_wtgcell(bounds%begg:bounds%endg)   = 0._r8
+         ! Calculate normalization (area-weighted solar flux)
+         do c = bounds%begc,bounds%endc
+            if (col%is_hillslope_column(c) .and. col%active(c)) then
+               g = col%gridcell(c)
+               do n = 1,numrad
+                  sum_solar(g,n) = sum_solar(g,n) + col%wtgcell(c)*forc_solad_col(c,n)
+               enddo
+               sum_wtgcell(g)    = sum_wtgcell(g) + col%wtgcell(c)
+            end if
+         end do
+         do g = bounds%begg,bounds%endg
+            do n = 1,numrad
+               if(abs(sum_solar(g,n) - sum_wtgcell(g)*forc_solad_grc(g,n)) > 1.e-6) then
+                  write(iulog,*) 'downscaled solar not conserved', g, n, sum_solar(g,n), sum_wtgcell(g)*forc_solad_grc(g,n)
+                  call endrun(subgrid_index=g, subgrid_level=subgrid_level_gridcell, &
+                       msg=' ERROR: Energy conservation error downscaling solar'//&
+                       errMsg(sourcefile, __LINE__))
+               endif
+            enddo
+         enddo
+      endif
+
+
+    end associate
+
+  end subroutine downscale_hillslope_solar
+
+  !-----------------------------------------------------------------------
+  subroutine downscale_hillslope_precipitation(bounds, &
+       topo_inst, atm2lnd_inst, wateratm2lndbulk_inst)
+    !
+    ! !DESCRIPTION:
+    ! Downscale precipitation from gridcell to column.
+    !
+    ! Downscaling is done based on the difference between each CLM column's elevation and
+    ! the atmosphere's surface elevation (which is the elevation at which the atmospheric
+    ! forcings are valid).
+    !
+    ! !USES:
+    use clm_varcon      , only : rair, cpair, grav
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)  , intent(in)    :: bounds  
+    class(topo_type)   , intent(in)    :: topo_inst
+    type(atm2lnd_type) , intent(in) :: atm2lnd_inst
+    type(wateratm2lndbulk_type) , intent(inout) :: wateratm2lndbulk_inst
+    !
+    ! !LOCAL VARIABLES:
+    integer :: g, l, c, fc         ! indices
+
+    ! temporaries for topo downscaling
+    real(r8) :: precip_anom, topo_anom
+    real(r8) :: norm_rain(bounds%begg:bounds%endg)
+    real(r8) :: norm_snow(bounds%begg:bounds%endg)
+    real(r8) :: sum_wt(bounds%begg:bounds%endg)
+    real(r8), parameter :: rain_scalar = 1.5e-3_r8        ! (1/m)
+    real(r8), parameter :: snow_scalar = 1.5e-3_r8        ! (1/m)
+    logical  :: checkConservation = .true.
+    character(len=*), parameter :: subname = 'downscale_hillslope_precipitation'
+    !-----------------------------------------------------------------------
+
+    associate(&
+         ! Gridcell-level metadata:
+         forc_topo_g  => atm2lnd_inst%forc_topo_grc                         , & ! Input:  [real(r8) (:)]  atmospheric surface height (m)
+         forc_rain_g  => wateratm2lndbulk_inst%forc_rain_not_downscaled_grc , & ! Input:  [real(r8) (:)]  rain rate [mm/s]
+         forc_snow_g  => wateratm2lndbulk_inst%forc_snow_not_downscaled_grc , & ! Input:  [real(r8) (:)]  snow rate [mm/s]         
+         ! Column-level metadata:
+         topo_c       => topo_inst%topo_col                                 , & ! Input:  [real(r8) (:)] column surface height (m)
+         
+         ! Column-level downscaled fields:
+         forc_rain_c  => wateratm2lndbulk_inst%forc_rain_downscaled_col     , & ! Output: [real(r8) (:)]  rain rate [mm/s]
+         forc_snow_c  => wateratm2lndbulk_inst%forc_snow_downscaled_col       & ! Output: [real(r8) (:)]  snow rate [mm/s]
+         )
+      
+      ! Redistribute precipitation based on departure
+      ! of column elevation from mean elevation
+
+      do c = bounds%begc,bounds%endc
+         g = col%gridcell(c)
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+
+            ! spatially uniform normalization, but separate rain/snow
+            topo_anom = max(-1._r8,(topo_c(c) - forc_topo_g(g))*rain_scalar) ! rain
+            precip_anom = forc_rain_g(g) * topo_anom
+            forc_rain_c(c) = forc_rain_c(c) + precip_anom
+
+            topo_anom = max(-1._r8,(topo_c(c) - forc_topo_g(g))*snow_scalar) ! snow
+            precip_anom = forc_snow_g(g) * topo_anom
+            forc_snow_c(c) = forc_snow_c(c) + precip_anom
+
+         end if
+      end do
+
+      ! Initialize arrays of total landunit precipitation
+      norm_rain(bounds%begg:bounds%endg) = 0._r8
+      norm_snow(bounds%begg:bounds%endg) = 0._r8
+      sum_wt(bounds%begg:bounds%endg)    = 0._r8
+      ! Calculate normalization (area-weighted average precipitation)
+      do c = bounds%begc,bounds%endc
+         g = col%gridcell(c)
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+            norm_rain(g) = norm_rain(g) + col%wtgcell(c)*forc_rain_c(c)
+            norm_snow(g) = norm_snow(g) + col%wtgcell(c)*forc_snow_c(c)
+            sum_wt(g)    = sum_wt(g) + col%wtgcell(c)
+         end if
+      end do
+      do g = bounds%begg,bounds%endg
+         if(sum_wt(g) > 0._r8) then
+            norm_rain(g) = norm_rain(g) / sum_wt(g)
+            norm_snow(g) = norm_snow(g) / sum_wt(g)
+         endif
+      enddo
+
+      ! Normalize column precipitation to conserve gridcell average 
+      do c = bounds%begc,bounds%endc
+         g = col%gridcell(c)
+         if (col%is_hillslope_column(c) .and. col%active(c)) then
+            if (norm_rain(g) > 0._r8) then 
+               forc_rain_c(c) = forc_rain_c(c) * forc_rain_g(g) / norm_rain(g)
+            else
+               forc_rain_c(c) = forc_rain_g(g)
+            endif
+            if (norm_snow(g) > 0._r8) then 
+               forc_snow_c(c) = forc_snow_c(c) * forc_snow_g(g) / norm_snow(g)
+            else
+               forc_snow_c(c) = forc_snow_g(g)
+            endif
+         end if
+      end do
+
+      ! check conservation
+      if(checkConservation)  then
+         norm_rain(bounds%begg:bounds%endg) = 0._r8
+         norm_snow(bounds%begg:bounds%endg) = 0._r8
+         sum_wt(bounds%begg:bounds%endg)   = 0._r8
+         ! Calculate normalization (area-weighted average precipitation)
+         do c = bounds%begc,bounds%endc
+            g = col%gridcell(c)
+            if (col%is_hillslope_column(c) .and. col%active(c)) then
+               norm_rain(g) = norm_rain(g) + col%wtgcell(c)*forc_rain_c(c)
+               norm_snow(g) = norm_snow(g) + col%wtgcell(c)*forc_snow_c(c)
+               sum_wt(g)    = sum_wt(g) + col%wtgcell(c)
+            end if
+         end do
+         do g = bounds%begg,bounds%endg
+            if(abs(norm_rain(g) - sum_wt(g)*forc_rain_g(g)) > 1.e-6) then
+               write(iulog,*) 'rain not conserved', g, norm_rain(g), sum_wt(g)*forc_rain_g(g)
+            endif
+            if(abs(norm_snow(g) - sum_wt(g)*forc_snow_g(g)) > 1.e-6) then
+               write(iulog,*) 'snow not conserved', g, norm_snow(g), sum_wt(g)*forc_snow_g(g)
+            endif
+         enddo
+      endif
+            
+    end associate
+
+  end subroutine downscale_hillslope_precipitation
+
+
 end module atm2lndMod
diff --git a/src/main/atm2lndType.F90 b/src/main/atm2lndType.F90
index 53013caf2..b99e0c8ba 100644
--- a/src/main/atm2lndType.F90
+++ b/src/main/atm2lndType.F90
@@ -80,9 +80,10 @@ module atm2lndType
      real(r8), pointer :: forc_vp_grc                   (:)   => null() ! atmospheric vapor pressure (Pa)
      real(r8), pointer :: forc_pco2_grc                 (:)   => null() ! CO2 partial pressure (Pa)
      real(r8), pointer :: forc_pco2_240_patch           (:)   => null() ! 10-day mean CO2 partial pressure (Pa)
-     real(r8), pointer :: forc_solad_grc                (:,:) => null() ! direct beam radiation (numrad) (vis=forc_sols , nir=forc_soll )
+     real(r8), pointer :: forc_solad_not_downscaled_grc (:,:) => null() ! direct beam radiation (numrad) (vis=forc_sols , nir=forc_soll )
      real(r8), pointer :: forc_solai_grc                (:,:) => null() ! diffuse radiation (numrad) (vis=forc_solsd, nir=forc_solld)
-     real(r8), pointer :: forc_solar_grc                (:)   => null() ! incident solar radiation
+     real(r8), pointer :: forc_solar_not_downscaled_grc (:)   => null() ! incident solar radiation
+     real(r8), pointer :: forc_solar_downscaled_col     (:)   => null() ! incident solar radiation
      real(r8), pointer :: forc_ndep_grc                 (:)   => null() ! nitrogen deposition rate (gN/m2/s)
      real(r8), pointer :: forc_pc13o2_grc               (:)   => null() ! C13O2 partial pressure (Pa)
      real(r8), pointer :: forc_po2_grc                  (:)   => null() ! O2 partial pressure (Pa)
@@ -104,7 +105,7 @@ module atm2lndType
      real(r8), pointer :: forc_pbot_downscaled_col      (:)   => null() ! downscaled atm pressure (Pa)
      real(r8), pointer :: forc_rho_downscaled_col       (:)   => null() ! downscaled atm density (kg/m**3)
      real(r8), pointer :: forc_lwrad_downscaled_col     (:)   => null() ! downscaled atm downwrd IR longwave radiation (W/m**2)
-
+     real(r8), pointer :: forc_solad_downscaled_col     (:,:) => null() ! direct beam radiation (numrad) (vis=forc_sols , nir=forc_soll )
 
      ! time averaged quantities
      real(r8) , pointer :: fsd24_patch                  (:)   => null() ! patch 24hr average of direct beam radiation
@@ -475,9 +476,9 @@ contains
     allocate(this%forc_hgt_q_grc                (begg:endg))        ; this%forc_hgt_q_grc                (:)   = ival
     allocate(this%forc_vp_grc                   (begg:endg))        ; this%forc_vp_grc                   (:)   = ival
     allocate(this%forc_pco2_grc                 (begg:endg))        ; this%forc_pco2_grc                 (:)   = ival
-    allocate(this%forc_solad_grc                (begg:endg,numrad)) ; this%forc_solad_grc                (:,:) = ival
+    allocate(this%forc_solad_not_downscaled_grc (begg:endg,numrad)) ; this%forc_solad_not_downscaled_grc (:,:) = ival
     allocate(this%forc_solai_grc                (begg:endg,numrad)) ; this%forc_solai_grc                (:,:) = ival
-    allocate(this%forc_solar_grc                (begg:endg))        ; this%forc_solar_grc                (:)   = ival
+    allocate(this%forc_solar_not_downscaled_grc (begg:endg))        ; this%forc_solar_not_downscaled_grc (:)   = ival
     allocate(this%forc_ndep_grc                 (begg:endg))        ; this%forc_ndep_grc                 (:)   = ival
     allocate(this%forc_pc13o2_grc               (begg:endg))        ; this%forc_pc13o2_grc               (:)   = ival
     allocate(this%forc_po2_grc                  (begg:endg))        ; this%forc_po2_grc                  (:)   = ival
@@ -503,6 +504,8 @@ contains
     allocate(this%forc_th_downscaled_col        (begc:endc))        ; this%forc_th_downscaled_col        (:)   = ival
     allocate(this%forc_rho_downscaled_col       (begc:endc))        ; this%forc_rho_downscaled_col       (:)   = ival
     allocate(this%forc_lwrad_downscaled_col     (begc:endc))        ; this%forc_lwrad_downscaled_col     (:)   = ival
+    allocate(this%forc_solad_downscaled_col     (begc:endc,numrad)) ; this%forc_solad_downscaled_col     (:,:) = ival
+    allocate(this%forc_solar_downscaled_col     (begc:endc))        ; this%forc_solar_downscaled_col     (:)   = ival
 
     allocate(this%fsd24_patch                   (begp:endp))        ; this%fsd24_patch                   (:)   = nan
     allocate(this%fsd240_patch                  (begp:endp))        ; this%fsd240_patch                  (:)   = nan
@@ -555,24 +558,25 @@ contains
          avgflag='A', long_name='atmospheric surface height', &
          ptr_lnd=this%forc_topo_grc)
 
+    this%forc_solar_not_downscaled_grc(begg:endg) = spval
+    call hist_addfld1d (fname='FSDS_from_atm', units='W/m^2',  &
+         avgflag='A', long_name='atmospheric incident solar radiation received from atmosphere (pre-downscaling)', &
+         ptr_lnd=this%forc_solar_not_downscaled_grc)
+
+    this%forc_o3_grc(begg:endg) = spval
     call hist_addfld1d (fname='ATM_O3', units='mol/mol', &
          avgflag='A', long_name='atmospheric ozone partial pressure', &
          ptr_lnd=this%forc_o3_grc, default = 'inactive')
 
-    this%forc_solar_grc(begg:endg) = spval
-    call hist_addfld1d (fname='FSDS', units='W/m^2',  &
-         avgflag='A', long_name='atmospheric incident solar radiation', &
-         ptr_lnd=this%forc_solar_grc)
-
     this%forc_pco2_grc(begg:endg) = spval
     call hist_addfld1d (fname='PCO2', units='Pa',  &
          avgflag='A', long_name='atmospheric partial pressure of CO2', &
          ptr_lnd=this%forc_pco2_grc)
 
-    this%forc_solar_grc(begg:endg) = spval
+    this%forc_solar_not_downscaled_grc(begg:endg) = spval
     call hist_addfld1d (fname='SWdown', units='W/m^2',  &
          avgflag='A', long_name='atmospheric incident solar radiation', &
-         ptr_gcell=this%forc_solar_grc, default='inactive')
+         ptr_gcell=this%forc_solar_not_downscaled_grc, default='inactive')
 
     if (use_lch4) then
        this%forc_pch4_grc(begg:endg) = spval
@@ -586,42 +590,46 @@ contains
          avgflag='A', long_name='atmospheric air temperature received from atmosphere (pre-downscaling)', &
          ptr_gcell=this%forc_t_not_downscaled_grc, default='inactive')
 
+    this%forc_solar_downscaled_col(begc:endc) = spval
+    call hist_addfld1d (fname='FSDS', units='W/m^2',  &
+         avgflag='A', long_name='atmospheric incident solar radiation (downscaled for glacier and hillslope columns)', &
+         ptr_col=this%forc_solar_downscaled_col)
+
     this%forc_t_downscaled_col(begc:endc) = spval
     call hist_addfld1d (fname='TBOT', units='K',  &
-         avgflag='A', long_name='atmospheric air temperature (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric air temperature (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_t_downscaled_col)
     call hist_addfld1d (fname='Tair', units='K', &
-         avgflag='A', long_name='atmospheric air temperature (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric air temperature (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_t_downscaled_col, default='inactive')
 
     this%forc_pbot_downscaled_col(begc:endc) = spval
     call hist_addfld1d (fname='PBOT', units='Pa',  &
-         avgflag='A', long_name='atmospheric pressure at surface (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric pressure at surface (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_pbot_downscaled_col)
     call hist_addfld1d (fname='PSurf', units='Pa',  &
-         avgflag='A', long_name='atmospheric pressure at surface (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric pressure at surface (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_pbot_downscaled_col, default='inactive')
 
     this%forc_lwrad_downscaled_col(begc:endc) = spval
     call hist_addfld1d (fname='FLDS', units='W/m^2',  &
-         avgflag='A', long_name='atmospheric longwave radiation (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric longwave radiation (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_lwrad_downscaled_col)
     call hist_addfld1d (fname='LWdown', units='W/m^2',  &
-         avgflag='A', long_name='atmospheric longwave radiation (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric longwave radiation (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_lwrad_downscaled_col, default='inactive')
 
     call hist_addfld1d (fname='FLDS_ICE', units='W/m^2',  &
          avgflag='A', &
-         long_name='atmospheric longwave radiation (downscaled to columns in glacier regions) (ice landunits only)', &
+         long_name='atmospheric longwave radiation (downscaled for glacier and hillslope columns) (ice landunits only)', &
          ptr_col=this%forc_lwrad_downscaled_col, l2g_scale_type='ice', &
          default='inactive')
 
     this%forc_th_downscaled_col(begc:endc) = spval
     call hist_addfld1d (fname='THBOT', units='K',  &
-         avgflag='A', long_name='atmospheric air potential temperature (downscaled to columns in glacier regions)', &
+         avgflag='A', long_name='atmospheric air potential temperature (downscaled for glacier and hillslope columns)', &
          ptr_col=this%forc_th_downscaled_col)
 
-
     ! Time averaged quantities
     this%fsi24_patch(begp:endp) = spval
     call hist_addfld1d (fname='FSI24', units='K',  &
@@ -858,7 +866,7 @@ contains
     ! Accumulate and extract forc_solad24 & forc_solad240
     do p = begp,endp
        g = patch%gridcell(p)
-       rbufslp(p) = this%forc_solad_grc(g,1)
+       rbufslp(p) = this%forc_solad_not_downscaled_grc(g,1)
     end do
     call update_accum_field  ('FSD240', rbufslp               , nstep)
     call extract_accum_field ('FSD240', this%fsd240_patch     , nstep)
@@ -997,9 +1005,9 @@ contains
     deallocate(this%forc_hgt_q_grc)
     deallocate(this%forc_vp_grc)
     deallocate(this%forc_pco2_grc)
-    deallocate(this%forc_solad_grc)
+    deallocate(this%forc_solad_not_downscaled_grc)
     deallocate(this%forc_solai_grc)
-    deallocate(this%forc_solar_grc)
+    deallocate(this%forc_solar_not_downscaled_grc)
     deallocate(this%forc_ndep_grc)
     deallocate(this%forc_pc13o2_grc)
     deallocate(this%forc_po2_grc)
@@ -1020,6 +1028,8 @@ contains
     deallocate(this%forc_th_downscaled_col)
     deallocate(this%forc_rho_downscaled_col)
     deallocate(this%forc_lwrad_downscaled_col)
+    deallocate(this%forc_solad_downscaled_col)
+    deallocate(this%forc_solar_downscaled_col)
 
     deallocate(this%fsd24_patch)
     deallocate(this%fsd240_patch)
diff --git a/src/main/clm_driver.F90 b/src/main/clm_driver.F90
index 33e9412ba..1cd0a9bea 100644
--- a/src/main/clm_driver.F90
+++ b/src/main/clm_driver.F90
@@ -511,7 +511,7 @@ contains
             atm_topo = atm2lnd_inst%forc_topo_grc(bounds_clump%begg:bounds_clump%endg))
 
        call downscale_forcings(bounds_clump, &
-            topo_inst, atm2lnd_inst, water_inst%wateratm2lndbulk_inst, &
+            topo_inst, atm2lnd_inst, surfalb_inst, water_inst%wateratm2lndbulk_inst, &
             eflx_sh_precip_conversion = energyflux_inst%eflx_sh_precip_conversion_col(bounds_clump%begc:bounds_clump%endc))
 
        call set_atm2lnd_water_tracers(bounds_clump, &
@@ -1087,12 +1087,12 @@ contains
 
        call t_startf('hydro2_drainage')
 
-       call HydrologyDrainage(bounds_clump,                   &
+       call HydrologyDrainage(bounds_clump,                    &
             filter(nc)%num_nolakec, filter(nc)%nolakec,       &
             filter(nc)%num_hydrologyc, filter(nc)%hydrologyc, &
             filter(nc)%num_urbanc, filter(nc)%urbanc,         &
             filter(nc)%num_do_smb_c, filter(nc)%do_smb_c,     &
-            atm2lnd_inst, glc2lnd_inst, temperature_inst,     &
+            glc2lnd_inst, temperature_inst,     &
             soilhydrology_inst, soilstate_inst, water_inst%waterstatebulk_inst, &
             water_inst%waterdiagnosticbulk_inst, water_inst%waterbalancebulk_inst, &
             water_inst%waterfluxbulk_inst, water_inst%wateratm2lndbulk_inst, &
diff --git a/src/main/clm_initializeMod.F90 b/src/main/clm_initializeMod.F90
index 077a25b79..3e1715f90 100644
--- a/src/main/clm_initializeMod.F90
+++ b/src/main/clm_initializeMod.F90
@@ -14,10 +14,10 @@ module clm_initializeMod
   use clm_varctl            , only : use_fates_sp, use_fates_bgc, use_fates
   use clm_varctl            , only : is_cold_start
   use clm_varctl            , only : iulog
-  use clm_varctl            , only : use_lch4, use_cn, use_cndv, use_c13, use_c14
+  use clm_varctl            , only : use_lch4, use_cn, use_cndv, use_c13, use_c14, nhillslope
   use clm_varctl            , only : use_soil_moisture_streams
   use clm_instur            , only : wt_lunit, urban_valid, wt_nat_patch, wt_cft, fert_cft
-  use clm_instur            , only : irrig_method, wt_glc_mec, topo_glc_mec, haslake, pct_urban_max
+  use clm_instur            , only : irrig_method, wt_glc_mec, topo_glc_mec, haslake, ncolumns_hillslope, pct_urban_max
   use perf_mod              , only : t_startf, t_stopf
   use readParamsMod         , only : readParameters
   use ncdio_pio             , only : file_desc_t
@@ -64,7 +64,9 @@ contains
     use UrbanParamsType      , only: IsSimpleBuildTemp
     use dynSubgridControlMod , only: dynSubgridControl_init
     use SoilBiogeochemDecompCascadeConType , only : decomp_cascade_par_init
-    use CropReprPoolsMod         , only: crop_repr_pools_init
+    use CropReprPoolsMod     , only: crop_repr_pools_init
+    use HillslopeHydrologyMod, only: hillslope_properties_init
+    
     !
     ! !ARGUMENTS
     integer, intent(in) :: dtime    ! model time step (seconds)
@@ -114,7 +116,8 @@ contains
     if (masterproc) call control_print()
     call dynSubgridControl_init(NLFilename)
     call crop_repr_pools_init()
-
+    call hillslope_properties_init(NLFilename)
+    
     call t_stopf('clm_init1')
 
   end subroutine initialize1
@@ -135,6 +138,7 @@ contains
     use clm_varctl                    , only : finidat, finidat_interp_source, finidat_interp_dest, fsurdat
     use clm_varctl                    , only : use_cn, use_fates
     use clm_varctl                    , only : use_crop, ndep_from_cpl, fates_spitfire_mode
+    use clm_varctl                    , only : use_hillslope
     use clm_varorb                    , only : eccen, mvelpp, lambm0, obliqr
     use clm_varctl                    , only : use_cropcal_streams
     use landunit_varcon               , only : landunit_varcon_init, max_lunit, numurbl
@@ -175,9 +179,11 @@ contains
     use CNSharedParamsMod             , only : CNParamsSetSoilDepth
     use NutrientCompetitionFactoryMod , only : create_nutrient_competition_method
     use FATESFireFactoryMod           , only : scalar_lightning
+    use HillslopeHydrologyMod         , only : InitHillslope
+    
     !
     ! !ARGUMENTS
-    integer, intent(in) :: ni, nj                ! global grid sizes
+    integer, intent(in) :: ni, nj         ! global grid sizes
     !
     ! !LOCAL VARIABLES:
     integer            :: c,g,i,j,k,l,n,p ! indices
@@ -235,6 +241,9 @@ contains
     allocate (wt_glc_mec   (begg:endg, maxpatch_glc     ))
     allocate (topo_glc_mec (begg:endg, maxpatch_glc     ))
     allocate (haslake      (begg:endg                      ))
+    if(use_hillslope) then 
+       allocate (ncolumns_hillslope  (begg:endg            ))
+    endif
     allocate (pct_urban_max(begg:endg, numurbl             ))
     allocate (wt_nat_patch (begg:endg, surfpft_lb:surfpft_ub ))
 
@@ -292,6 +301,11 @@ contains
     ! Set global seg maps for gridcells, landlunits, columns and patches
     call decompInit_glcp(ni, nj, glc_behavior)
 
+    if(use_hillslope) then
+       ! Initialize hillslope properties
+       call InitHillslope(bounds_proc, fsurdat)
+    endif
+
     ! Set filters
     call allocFilters()
 
@@ -317,6 +331,7 @@ contains
     ! end of the run for error checking, pct_urban_max is kept through the end of the run
     ! for reweighting in subgridWeights.
     deallocate (wt_lunit, wt_cft, wt_glc_mec, haslake)
+    if(use_hillslope)  deallocate (ncolumns_hillslope)
 
     ! Determine processor bounds and clumps for this processor
     call get_proc_bounds(bounds_proc)
diff --git a/src/main/clm_instMod.F90 b/src/main/clm_instMod.F90
index 1ca450b48..7f2e3c1d1 100644
--- a/src/main/clm_instMod.F90
+++ b/src/main/clm_instMod.F90
@@ -200,6 +200,11 @@ contains
     use SoilWaterRetentionCurveFactoryMod  , only : create_soil_water_retention_curve
     use decompMod                          , only : get_proc_bounds
     use BalanceCheckMod                    , only : GetBalanceCheckSkipSteps
+
+    use clm_varctl                         , only : use_hillslope
+    use HillslopeHydrologyMod              , only : SetHillslopeSoilThickness
+    use initVerticalMod                    , only : setSoilLayerClass
+
     !
     ! !ARGUMENTS    
     type(bounds_type), intent(in) :: bounds  ! processor bounds
@@ -268,6 +273,14 @@ contains
          urbanparams_inst%thick_wall(begl:endl), &
          urbanparams_inst%thick_roof(begl:endl))
 
+    ! Set hillslope column bedrock values
+    if(use_hillslope) then
+       call SetHillslopeSoilThickness(bounds,fsurdat, &
+            soil_depth_lowland_in=8.5_r8,&
+            soil_depth_upland_in =2.0_r8)
+       call setSoilLayerClass(bounds)
+    endif
+
     !-----------------------------------------------
     ! Set cold-start values for snow levels, snow layers and snow interfaces 
     !-----------------------------------------------
diff --git a/src/main/clm_varctl.F90 b/src/main/clm_varctl.F90
index 6e89f0952..b616d45aa 100644
--- a/src/main/clm_varctl.F90
+++ b/src/main/clm_varctl.F90
@@ -152,6 +152,12 @@ module clm_varctl
   ! true => separate crop landunit is not created by default
   logical, public :: create_crop_landunit = .false.     
   
+  ! number of hillslopes per landunit
+  integer, public :: nhillslope = 0
+
+  ! maximum number of hillslope columns per landunit
+  integer, public :: max_columns_hillslope = 1
+
   ! do not irrigate by default
   logical, public :: irrigate = .false.            
 
@@ -372,6 +378,14 @@ module clm_varctl
   real(r8), public :: soil_layerstruct_userdefined(99) = rundef
   integer, public :: soil_layerstruct_userdefined_nlevsoi = iundef
 
+  !----------------------------------------------------------
+  ! hillslope hydrology switch
+  !----------------------------------------------------------
+
+  logical, public :: use_hillslope = .false. ! true => use multi-column hillslope hydrology
+  logical, public :: downscale_hillslope_meteorology = .false. ! true => downscale meteorological forcing in hillslope model
+  logical, public :: use_hillslope_routing = .false. ! true => use surface water routing in hillslope hydrology
+
   !----------------------------------------------------------
   !excess ice physics switch
   !----------------------------------------------------------
diff --git a/src/main/clm_varsur.F90 b/src/main/clm_varsur.F90
index d360941d2..dfb935748 100644
--- a/src/main/clm_varsur.F90
+++ b/src/main/clm_varsur.F90
@@ -45,13 +45,17 @@ module clm_instur
 
   ! subgrid glacier_mec sfc elevation
   real(r8), pointer :: topo_glc_mec(:,:) 
-  
+
   ! whether we have lake to initialise in each grid cell
   logical , pointer :: haslake(:)
+
+  ! subgrid hillslope hydrology constituents
+  integer, pointer :: ncolumns_hillslope(:) 
   
   ! whether we have urban to initialize in each grid cell
   ! (second dimension goes 1:numurbl)
   real(r8), pointer :: pct_urban_max(:,:)
+
   !-----------------------------------------------------------------------
 
 end module clm_instur
diff --git a/src/main/controlMod.F90 b/src/main/controlMod.F90
index deb8c044d..582adb778 100644
--- a/src/main/controlMod.F90
+++ b/src/main/controlMod.F90
@@ -45,7 +45,7 @@ module controlMod
   use SoilBiogeochemLittVertTranspMod  , only: som_adv_flux, max_depth_cryoturb
   use SoilBiogeochemVerticalProfileMod , only: surfprof_exp
   use SoilBiogeochemNitrifDenitrifMod  , only: no_frozen_nitrif_denitrif
-  use SoilHydrologyMod                 , only: soilHydReadNML
+  use SoilHydrologyMod                 , only: soilHydReadNML,hillslope_hydrology_ReadNML
   use CNFireFactoryMod                 , only: CNFireReadNML
   use CanopyFluxesMod                  , only: CanopyFluxesReadNML
   use shr_drydep_mod                   , only: n_drydep
@@ -255,6 +255,11 @@ contains
 
     namelist /clm_inparm/ use_biomass_heat_storage
 
+    namelist /clm_inparm/ use_hillslope
+
+    namelist /clm_inparm/ downscale_hillslope_meteorology
+
+    namelist /clm_inparm/ use_hillslope_routing
 
     namelist /clm_inparm/ use_hydrstress
 
@@ -572,6 +577,9 @@ contains
     end if
 
     call soilHydReadNML(   NLFilename )
+    if ( use_hillslope ) then
+       call hillslope_hydrology_ReadNML(   NLFilename )
+    endif
 
     if( use_cn ) then
        call CNFireReadNML(             NLFilename )
@@ -811,6 +819,11 @@ contains
 
     call mpi_bcast (use_biomass_heat_storage, 1, MPI_LOGICAL, 0, mpicom, ier)
 
+    call mpi_bcast (use_hillslope, 1, MPI_LOGICAL, 0, mpicom, ier)
+
+    call mpi_bcast (downscale_hillslope_meteorology, 1, MPI_LOGICAL, 0, mpicom, ier)
+
+    call mpi_bcast (use_hillslope_routing, 1, MPI_LOGICAL, 0, mpicom, ier)
 
     call mpi_bcast (use_hydrstress, 1, MPI_LOGICAL, 0, mpicom, ier)
 
@@ -1060,6 +1073,7 @@ contains
     write(iulog,'(a,d20.10)') '   Max snow depth (mm) =', h2osno_max
 
     write(iulog,'(a,i8)') '   glc number of elevation classes =', maxpatch_glc
+
     if (glc_do_dynglacier) then
        write(iulog,*) '   glc CLM glacier areas and topography WILL evolve dynamically'
     else
@@ -1092,6 +1106,9 @@ contains
     end if
 
     write(iulog,*) '   land-ice albedos      (unitless 0-1)   = ', albice
+    write(iulog,*) '   hillslope hydrology    = ', use_hillslope
+    write(iulog,*) '   downscale hillslope meteorology    = ', downscale_hillslope_meteorology
+    write(iulog,*) '   hillslope routing      = ', use_hillslope_routing
     write(iulog,*) '   pre-defined soil layer structure = ', soil_layerstruct_predefined
     write(iulog,*) '   user-defined soil layer structure = ', soil_layerstruct_userdefined
     write(iulog,*) '   user-defined number of soil layers = ', soil_layerstruct_userdefined_nlevsoi
diff --git a/src/main/histFileMod.F90 b/src/main/histFileMod.F90
index c72117b09..19591710b 100644
--- a/src/main/histFileMod.F90
+++ b/src/main/histFileMod.F90
@@ -16,7 +16,7 @@ module histFileMod
   use clm_varctl     , only : iulog, use_fates, compname, use_cn, use_crop
   use clm_varcon     , only : spval, ispval
   use clm_varcon     , only : grlnd, nameg, namel, namec, namep
-  use decompMod      , only : get_proc_bounds, get_proc_global, bounds_type, get_global_index_array
+  use decompMod      , only : get_proc_bounds, get_proc_global, bounds_type, get_global_index, get_global_index_array
   use decompMod      , only : subgrid_level_gridcell, subgrid_level_landunit, subgrid_level_column
   use GridcellType   , only : grc
   use LandunitType   , only : lun
@@ -2328,6 +2328,7 @@ contains
     use landunit_varcon , only : max_lunit
     use clm_varctl      , only : caseid, ctitle, fsurdat, finidat, paramfile
     use clm_varctl      , only : version, hostname, username, conventions, source
+    use clm_varctl      , only : use_hillslope,nhillslope,max_columns_hillslope
     use domainMod       , only : ldomain
     use fileutils       , only : get_filename
     !
@@ -2465,6 +2466,10 @@ contains
     call ncd_defdim(lnfid, 'ltype', max_lunit, dimid)
     call ncd_defdim(lnfid, 'nlevcan',nlevcan, dimid)
     call ncd_defdim(lnfid, 'nvegwcs',nvegwcs, dimid)
+    if (use_hillslope) then
+       call ncd_defdim(lnfid, 'nhillslope',nhillslope, dimid)
+       call ncd_defdim(lnfid, 'max_columns_hillslope',max_columns_hillslope, dimid)
+    endif
     call ncd_defdim(lnfid, 'mxsowings' , mxsowings , dimid)
     call ncd_defdim(lnfid, 'mxharvests' , mxharvests , dimid)
     call htape_add_ltype_metadata(lnfid)
@@ -2486,7 +2491,6 @@ contains
     call ncd_defdim(lnfid, 'scale_type_string_length', scale_type_strlen, dimid)
     call ncd_defdim( lnfid, 'levdcmp', nlevdecomp_full, dimid)
 
-
     if(use_fates)then
        call ncd_defdim(lnfid, 'fates_levscag', nlevsclass * nlevage, dimid)
        call ncd_defdim(lnfid, 'fates_levscagpf', nlevsclass * nlevage * numpft_fates, dimid)
@@ -2727,6 +2731,7 @@ contains
          'lake', &  ! ZLAKE
          'lake'  &  ! DZLAKE
          ]
+
     !-----------------------------------------------------------------------
 
     SHR_ASSERT_ALL_FL((ubound(watsat_col)   == (/bounds%endc, nlevmaxurbgrnd/)), sourcefile, __LINE__)
@@ -3021,7 +3026,8 @@ contains
     !
     ! !USES:
     use clm_varpar      , only : nlevsoi
-    use clm_varcon      , only : zsoi, zlak, secspday, isecspday, isecsphr, isecspmin
+    use clm_varctl      , only : use_hillslope
+    use clm_varcon      , only : zsoi, zlak, secspday, isecspday, isecsphr, isecspmin, ispval
     use domainMod       , only : ldomain, lon1d, lat1d
     use clm_time_manager, only : get_nstep, get_curr_date, get_curr_time
     use clm_time_manager, only : get_ref_date, get_calendar, NO_LEAP_C, GREGORIAN_C
@@ -3075,7 +3081,7 @@ contains
     !
     integer :: sec_hist_nhtfrq            ! hist_nhtfrq converted to seconds
     ! !LOCAL VARIABLES:
-    integer :: vid,n,i,j,m                ! indices
+    integer :: vid,n,i,j,m,c              ! indices
     integer :: nstep                      ! current step
     integer :: mcsec                      ! seconds of current date
     integer :: mdcur                      ! current day
@@ -3101,6 +3107,9 @@ contains
     real(r8), pointer :: histo(:,:)       ! temporary
     integer :: status
     real(r8) :: zsoi_1d(1)
+    type(bounds_type) :: bounds
+    integer :: ier                        ! error status
+    integer, pointer :: icarr(:)          ! temporary
     character(len=*),parameter :: subname = 'htape_timeconst'
     !-----------------------------------------------------------------------
 
@@ -3108,6 +3117,9 @@ contains
     !***     Time constant grid variables only on first time-sample of file ***
     !-------------------------------------------------------------------------------
 
+    call get_proc_bounds(bounds)
+
+
     if (tape(t)%ntimes == 1) then
        if (mode == 'define') then
           call ncd_defvar(varname='levgrnd', xtype=tape(t)%ncprec, &
@@ -3122,6 +3134,36 @@ contains
           call ncd_defvar(varname='levdcmp', xtype=tape(t)%ncprec, dim1name='levdcmp', &
                long_name='coordinate levels for soil decomposition variables', units='m', ncid=nfid(t))
 
+          if(use_hillslope .and. .not.tape(t)%dov2xy)then
+             call ncd_defvar(varname='hslp_distance', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column distance', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_width', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column width', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_area', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column area', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_elev', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column elevation', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_slope', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column slope', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_aspect', xtype=ncd_double, &
+                  dim1name=namec, long_name='hillslope column aspect', &
+                  units='m', ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_index', xtype=ncd_int, &
+                  dim1name=namec, long_name='hillslope index', &
+                  ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_cold', xtype=ncd_int, &
+                  dim1name=namec, long_name='hillslope downhill column index', &
+                  ncid=nfid(t))             
+             call ncd_defvar(varname='hslp_colu', xtype=ncd_int, &
+                  dim1name=namec, long_name='hillslope uphill column index', &
+                  ncid=nfid(t))             
+          end if
+
           if(use_fates)then
 
              call ncd_defvar(varname='fates_levscls', xtype=tape(t)%ncprec, dim1name='fates_levscls', &
@@ -3208,6 +3250,44 @@ contains
              zsoi_1d(1) = 1._r8
              call ncd_io(varname='levdcmp', data=zsoi_1d, ncid=nfid(t), flag='write')
           end if
+
+          if (use_hillslope .and. .not.tape(t)%dov2xy) then             
+             call ncd_io(varname='hslp_distance' , data=col%hill_distance, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_width' , data=col%hill_width, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_area' , data=col%hill_area, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_elev' , data=col%hill_elev, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_slope' , data=col%hill_slope, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_aspect' , data=col%hill_aspect, dim1name=namec, ncid=nfid(t), flag='write')
+             call ncd_io(varname='hslp_index' , data=col%hillslope_ndx, dim1name=namec, ncid=nfid(t), flag='write')
+
+             ! write global indices rather than local indices
+             allocate(icarr(bounds%begc:bounds%endc),stat=ier)
+             if (ier /= 0) then
+                call endrun(msg=' allocation error of icarr'//errMsg(sourcefile, __LINE__))
+             end if
+
+             do c = bounds%begc,bounds%endc
+                if (col%cold(c) /= ispval) then 
+                   icarr(c)= get_global_index(subgrid_index=col%cold(c), subgrid_level=subgrid_level_column)
+                else
+                   icarr(c)= col%cold(c)
+                endif
+             enddo
+             
+             call ncd_io(varname='hslp_cold' , data=icarr, dim1name=namec, ncid=nfid(t), flag='write')
+
+             do c = bounds%begc,bounds%endc
+                if (col%colu(c) /= ispval) then 
+                   icarr(c)= get_global_index(subgrid_index=col%colu(c), subgrid_level=subgrid_level_column)
+                else
+                   icarr(c)= col%colu(c)
+                endif
+             enddo
+
+             call ncd_io(varname='hslp_colu' , data=icarr, dim1name=namec, ncid=nfid(t), flag='write')
+             deallocate(icarr)
+          endif
+
           if(use_fates)then
              call ncd_io(varname='fates_scmap_levscag',data=fates_hdim_scmap_levscag, ncid=nfid(t), flag='write')
              call ncd_io(varname='fates_agmap_levscag',data=fates_hdim_agmap_levscag, ncid=nfid(t), flag='write')
@@ -3758,6 +3838,9 @@ contains
           call ncd_defvar(varname='cols1d_active', xtype=ncd_log, dim1name=namec, &
                long_name='true => do computations on this column', ifill_value=0, ncid=ncid)
 
+          call ncd_defvar(varname='cols1d_nbedrock', xtype=ncd_int, dim1name=namec, &
+               long_name='column bedrock depth index', ifill_value=ispval, ncid=ncid)
+
           ! Define patch info
 
           call ncd_defvar(varname='pfts1d_lon', xtype=ncd_double, dim1name=namep, &
@@ -3905,6 +3988,7 @@ contains
        call ncd_io(varname='cols1d_itype_lunit', data=icarr    , dim1name=namec, ncid=ncid, flag='write')
 
        call ncd_io(varname='cols1d_active' , data=col%active  , dim1name=namec, ncid=ncid, flag='write')
+       call ncd_io(varname='cols1d_nbedrock', data=col%nbedrock , dim1name=namec, ncid=ncid, flag='write')
 
        ! Write patch info
 
@@ -4100,7 +4184,7 @@ contains
              call htape_timeconst(t, mode='define')
 
              ! Define 3D time-constant field variables on first history tapes
-             if ( do_3Dtconst) then
+             if ( do_3Dtconst .and. t == 1) then
                 call htape_timeconst3D(t, &
                      bounds, watsat_col, sucsat_col, bsw_col, hksat_col, &
                      cellsand_col, cellclay_col, mode='define')
@@ -4120,7 +4204,7 @@ contains
           call htape_timeconst(t, mode='write')
 
           ! Write 3D time constant history variables to first history tapes
-          if ( do_3Dtconst .and. tape(t)%ntimes == 1 )then
+          if ( do_3Dtconst .and. t == 1 .and. tape(t)%ntimes == 1 )then
              call htape_timeconst3D(t, &
                   bounds, watsat_col, sucsat_col, bsw_col, hksat_col, &
                   cellsand_col, cellclay_col, mode='write')
@@ -4574,7 +4658,6 @@ contains
 
        start(1)=1
 
-
        !
        ! Add history namelist data to each history restart tape
        !
diff --git a/src/main/initGridCellsMod.F90 b/src/main/initGridCellsMod.F90
index 99303c32d..987611f5f 100644
--- a/src/main/initGridCellsMod.F90
+++ b/src/main/initGridCellsMod.F90
@@ -11,7 +11,7 @@ module initGridCellsMod
   ! these modules (or the two modules should be combined into one).
   !
   ! !USES:
-#include "shr_assert.h"
+#include "shr_assert.h"  
   use shr_kind_mod   , only : r8 => shr_kind_r8
   use shr_log_mod    , only : errMsg => shr_log_errMsg
   use spmdMod        , only : masterproc,iam
@@ -216,7 +216,7 @@ contains
     integer , intent(inout) :: pi                ! patch index
     !
     ! !LOCAL VARIABLES:
-    integer  :: m                                ! index
+    integer  :: m,ci2                            ! index
     integer  :: npatches                         ! number of patches in landunit
     integer  :: ncols
     integer  :: nlunits
@@ -224,6 +224,7 @@ contains
     integer  :: ncols_added                      ! number of columns actually added
     integer  :: nlunits_added                    ! number of landunits actually added
     real(r8) :: wtlunit2gcell                    ! landunit weight in gridcell
+    real(r8) :: wtcol2lunit                      ! column weight in landunit
     real(r8) :: p_wt                             ! patch weight (0-1)
     !------------------------------------------------------------------------
 
@@ -240,31 +241,37 @@ contains
     if (nlunits > 0) then
        call add_landunit(li=li, gi=gi, ltype=ltype, wtgcell=wtlunit2gcell)
        nlunits_added = nlunits_added + 1
-       
-       ! Assume one column on the landunit
-       call add_column(ci=ci, li=li, ctype=1, wtlunit=1.0_r8)
-       ncols_added = ncols_added + 1
-
-       ! For FATES: the total number of patches may not match what is in the surface
-       ! file, and therefor the weighting can't be used. The weightings in
-       ! wt_nat_patch may be meaningful (like with fixed biogeography), but they
-       ! they need a mapping table to connect to the allocated patches (in fates)
-       ! so the wt_nat_patch array is not applicable to these area weights
-       ! A subsequent call, via the clmfates interface will update these weights
-       ! by using said mapping table
-       
-       do m = natpft_lb,natpft_ub
-          if (natveg_patch_exists(gi, m)) then
-             if(use_fates .and. .not.use_fates_sp)then
-                p_wt = 1.0_r8/real(natpft_size,r8)
-             else
-                p_wt = wt_nat_patch(gi,m)
+
+       ! Potentially create multiple columns (e.g., for hillslope hydrology), but each
+       ! with the same PFT breakdown.
+       !
+       ! Set column weight arbitrarily for now. If we have multiple columns because we're
+       ! using hillslope hydrology, then col%wtlunit will be modified in InitHillslope.
+       wtcol2lunit = 1.0_r8/real(ncols,r8)
+       do ci2 = 1,ncols
+          call add_column(ci=ci, li=li, ctype=1, wtlunit=wtcol2lunit)
+          ncols_added = ncols_added + 1
+
+          ! For FATES: the total number of patches may not match what is in the surface
+          ! file, and therefor the weighting can't be used. The weightings in
+          ! wt_nat_patch may be meaningful (like with fixed biogeography), but they
+          ! they need a mapping table to connect to the allocated patches (in fates)
+          ! so the wt_nat_patch array is not applicable to these area weights
+          ! A subsequent call, via the clmfates interface will update these weights
+          ! by using said mapping table
+
+          do m = natpft_lb,natpft_ub
+             if (natveg_patch_exists(gi, m)) then
+                if(use_fates .and. .not.use_fates_sp)then
+                   p_wt = 1.0_r8/real(natpft_size,r8)
+                else
+                   p_wt = wt_nat_patch(gi,m)
+                end if
+                call add_patch(pi=pi, ci=ci, ptype=m, wtcol=p_wt)
+                npatches_added = npatches_added + 1
              end if
-             call add_patch(pi=pi, ci=ci, ptype=m, wtcol=p_wt)
-             npatches_added = npatches_added + 1
-          end if
+          end do
        end do
-
     end if
 
     SHR_ASSERT_FL(nlunits_added == nlunits, sourcefile, __LINE__)
diff --git a/src/main/initVerticalMod.F90 b/src/main/initVerticalMod.F90
index 1bf79706f..92788a460 100644
--- a/src/main/initVerticalMod.F90
+++ b/src/main/initVerticalMod.F90
@@ -40,7 +40,8 @@ module initVerticalMod
   public :: initVertical
   public :: find_soil_layer_containing_depth
   public :: readParams
-
+  public :: setSoilLayerClass
+  
   ! !PRIVATE MEMBER FUNCTIONS:
   private :: hasBedrock  ! true if the given column type includes bedrock layers
   type, private :: params_type
@@ -80,9 +81,75 @@ contains
 
   end subroutine readParams
 
+    !------------------------------------------------------------------------
+  subroutine setSoilLayerClass(bounds)
+
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds
+    !
+    ! LOCAL VARAIBLES:
+    integer               :: c,l,j             ! indices
+
+    ! Possible values for levgrnd_class. The important thing is that, for a given column,
+    ! layers that are fundamentally different (e.g., soil vs bedrock) have different
+    ! values. This information is used in the vertical interpolation in init_interp.
+    !
+    ! IMPORTANT: These values should not be changed lightly. e.g., try to avoid changing
+    ! the values assigned to LEVGRND_CLASS_STANDARD, LEVGRND_CLASS_DEEP_BEDROCK, etc.  The
+    ! problem with changing these is that init_interp expects that layers with a value of
+    ! (e.g.) 1 on the source file correspond to layers with a value of 1 on the
+    ! destination file. So if you change the values of these constants, you either need to
+    ! adequately inform users of this change, or build in some translation mechanism in
+    ! init_interp (such as via adding more metadata to the restart file on the meaning of
+    ! these different values).
+    !
+    ! The distinction between "shallow" and "deep" bedrock is not made explicitly
+    ! elsewhere. But, since these classes have somewhat different behavior, they are
+    ! distinguished explicitly here.
+    integer, parameter :: LEVGRND_CLASS_STANDARD        = 1
+    integer, parameter :: LEVGRND_CLASS_DEEP_BEDROCK    = 2
+    integer, parameter :: LEVGRND_CLASS_SHALLOW_BEDROCK = 3
+
+    character(len=*), parameter :: subname = 'setSoilLayerClass'
+
+    ! ------------------------------------------------------------------------
+    ! Set classes of layers
+    ! ------------------------------------------------------------------------
+
+    do c = bounds%begc, bounds%endc
+       l = col%landunit(c)
+       if (hasBedrock(col_itype=col%itype(c), lun_itype=lun%itype(l))) then
+          ! NOTE(wjs, 2015-10-17) We are assuming that points with bedrock have both
+          ! "shallow" and "deep" bedrock. Currently, this is not true for lake columns:
+          ! lakes do not distinguish between "shallow" bedrock and "normal" soil.
+          ! However, that was just due to an oversight that is supposed to be corrected
+          ! soon; so to keep things simple we assume that any point with bedrock
+          ! potentially has both shallow and deep bedrock.
+          col%levgrnd_class(c, 1:col%nbedrock(c)) = LEVGRND_CLASS_STANDARD
+          if (col%nbedrock(c) < nlevsoi) then
+             col%levgrnd_class(c, (col%nbedrock(c) + 1) : nlevsoi) = LEVGRND_CLASS_SHALLOW_BEDROCK
+          end if
+          col%levgrnd_class(c, (nlevsoi + 1) : nlevmaxurbgrnd) = LEVGRND_CLASS_DEEP_BEDROCK
+       else
+          col%levgrnd_class(c, 1:nlevmaxurbgrnd) = LEVGRND_CLASS_STANDARD
+       end if
+    end do
+
+    do j = 1, nlevmaxurbgrnd
+       do c = bounds%begc, bounds%endc
+          if (col%z(c,j) == spval) then
+             col%levgrnd_class(c,j) = ispval
+          end if
+       end do
+    end do
+
+  end subroutine setSoilLayerClass
+    
   !------------------------------------------------------------------------
   subroutine initVertical(bounds, glc_behavior, thick_wall, thick_roof)
-    use clm_varcon, only : zmin_bedrock
+    use clm_varcon           , only : zmin_bedrock
+
     !
     ! !ARGUMENTS:
     type(bounds_type)   , intent(in)    :: bounds
@@ -91,7 +158,7 @@ contains
     real(r8)            , intent(in)    :: thick_roof(bounds%begl:)
     !
     ! LOCAL VARAIBLES:
-    integer               :: c,l,g,i,j,lev     ! indices 
+    integer               :: c,l,g,i,j,lev     ! indices
     type(file_desc_t)     :: ncid              ! netcdf id
     logical               :: readvar 
     integer               :: dimid             ! dimension id
@@ -115,27 +182,6 @@ contains
     integer               :: begc, endc
     integer               :: begl, endl
     integer               :: jmin_bedrock
-
-    ! Possible values for levgrnd_class. The important thing is that, for a given column,
-    ! layers that are fundamentally different (e.g., soil vs bedrock) have different
-    ! values. This information is used in the vertical interpolation in init_interp.
-    !
-    ! IMPORTANT: These values should not be changed lightly. e.g., try to avoid changing
-    ! the values assigned to LEVGRND_CLASS_STANDARD, LEVGRND_CLASS_DEEP_BEDROCK, etc.  The
-    ! problem with changing these is that init_interp expects that layers with a value of
-    ! (e.g.) 1 on the source file correspond to layers with a value of 1 on the
-    ! destination file. So if you change the values of these constants, you either need to
-    ! adequately inform users of this change, or build in some translation mechanism in
-    ! init_interp (such as via adding more metadata to the restart file on the meaning of
-    ! these different values).
-    !
-    ! The distinction between "shallow" and "deep" bedrock is not made explicitly
-    ! elsewhere. But, since these classes have somewhat different behavior, they are
-    ! distinguished explicitly here.
-    integer, parameter :: LEVGRND_CLASS_STANDARD        = 1
-    integer, parameter :: LEVGRND_CLASS_DEEP_BEDROCK    = 2
-    integer, parameter :: LEVGRND_CLASS_SHALLOW_BEDROCK = 3
-
     character(len=*), parameter :: subname = 'initVertical'
     !------------------------------------------------------------------------
 
@@ -224,7 +270,7 @@ contains
              dzsoi(j) = soil_layerstruct_userdefined(j)
           end do
        else if (soil_layerstruct_predefined == '49SL_10m') then
-          !scs: 10 meter soil column, nlevsoi set to 49 in clm_varpar
+          ! 10 meter soil column, nlevsoi set to 49 in clm_varpar
           do j = 1, 10
              dzsoi(j) = 1.e-2_r8     ! 10-mm layers
           enddo
@@ -639,36 +685,11 @@ contains
        end if
     end do
 
-    ! ------------------------------------------------------------------------
+    ! ----------------------------------------------
     ! Set classes of layers
-    ! ------------------------------------------------------------------------
+    ! ----------------------------------------------
 
-    do c = bounds%begc, bounds%endc
-       l = col%landunit(c)
-       if (hasBedrock(col_itype=col%itype(c), lun_itype=lun%itype(l))) then
-          ! NOTE(wjs, 2015-10-17) We are assuming that points with bedrock have both
-          ! "shallow" and "deep" bedrock. Currently, this is not true for lake columns:
-          ! lakes do not distinguish between "shallow" bedrock and "normal" soil.
-          ! However, that was just due to an oversight that is supposed to be corrected
-          ! soon; so to keep things simple we assume that any point with bedrock
-          ! potentially has both shallow and deep bedrock.
-          col%levgrnd_class(c, 1:col%nbedrock(c)) = LEVGRND_CLASS_STANDARD
-          if (col%nbedrock(c) < nlevsoi) then
-             col%levgrnd_class(c, (col%nbedrock(c) + 1) : nlevsoi) = LEVGRND_CLASS_SHALLOW_BEDROCK
-          end if
-          col%levgrnd_class(c, (nlevsoi + 1) : nlevmaxurbgrnd) = LEVGRND_CLASS_DEEP_BEDROCK
-       else
-          col%levgrnd_class(c, 1:nlevmaxurbgrnd) = LEVGRND_CLASS_STANDARD
-       end if
-    end do
-
-    do j = 1, nlevmaxurbgrnd
-       do c = bounds%begc, bounds%endc
-          if (col%z(c,j) == spval) then
-             col%levgrnd_class(c,j) = ispval
-          end if
-       end do
-    end do
+    call setSoilLayerClass(bounds)
 
     !-----------------------------------------------
     ! Read in topographic index and slope
@@ -707,7 +728,14 @@ contains
     do c = begc,endc
        ! microtopographic parameter, units are meters (try smooth function of slope)
        slope0 = params_inst%slopemax**(1._r8/params_inst%slopebeta)
-       col%micro_sigma(c) = (col%topo_slope(c) + slope0)**(params_inst%slopebeta)
+
+       if (col%is_hillslope_column(c)) then
+          
+          col%micro_sigma(c) = (atan(col%hill_slope(c)) + slope0)**(params_inst%slopebeta)
+       else
+          col%micro_sigma(c) = (col%topo_slope(c) + slope0)**(params_inst%slopebeta)
+       endif
+
     end do
 
     call ncd_pio_closefile(ncid)
diff --git a/src/main/lnd2atmMod.F90 b/src/main/lnd2atmMod.F90
index 27769a69d..5d1b1086b 100644
--- a/src/main/lnd2atmMod.F90
+++ b/src/main/lnd2atmMod.F90
@@ -15,7 +15,7 @@ module lnd2atmMod
   use clm_varctl           , only : iulog, use_lch4
   use shr_drydep_mod       , only : n_drydep
   use decompMod            , only : bounds_type
-  use subgridAveMod        , only : p2g, c2g
+  use subgridAveMod        , only : p2g, c2g, l2g
   use filterColMod         , only : filter_col_type, col_filter_from_logical_array
   use lnd2atmType          , only : lnd2atm_type
   use atm2lndType          , only : atm2lnd_type
@@ -159,6 +159,7 @@ contains
     !
     ! !USES:
     use ch4varcon  , only : ch4offline
+    use clm_varctl , only : use_hillslope_routing
     !
     ! !ARGUMENTS:
     type(bounds_type)           , intent(in)    :: bounds
@@ -179,8 +180,11 @@ contains
     real(r8)                    , intent(in)    :: net_carbon_exchange_grc( bounds%begg: )  ! net carbon exchange between land and atmosphere, positive for source (gC/m2/s)
     !
     ! !LOCAL VARIABLES:
-    integer  :: c, g  ! indices
+    integer  :: c, l, g  ! indices
     real(r8) :: eflx_sh_ice_to_liq_grc(bounds%begg:bounds%endg) ! sensible heat flux generated from the ice to liquid conversion, averaged to gridcell
+    real(r8), allocatable :: qflx_surf_col_to_rof(:)          ! surface runoff that is sent directly to rof
+    real(r8), allocatable :: qflx_drain_col_to_rof(:)         ! drainagec that is sent directly to rof
+    real(r8), allocatable :: qflx_drain_perched_col_to_rof(:) ! perched drainage that is sent directly to rof
     real(r8), parameter :: amC   = 12.0_r8 ! Atomic mass number for Carbon
     real(r8), parameter :: amO   = 16.0_r8 ! Atomic mass number for Oxygen
     real(r8), parameter :: amCO2 = amC + 2.0_r8*amO ! Atomic mass number for CO2
@@ -336,15 +340,80 @@ contains
     ! lnd -> rof
     !----------------------------------------------------
 
-    call c2g( bounds, &
-         water_inst%waterfluxbulk_inst%qflx_surf_col (bounds%begc:bounds%endc), &
-         water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsur_grc   (bounds%begg:bounds%endg), &
-         c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
+    if(use_hillslope_routing) then
+       ! streamflow is volume/time, so sum over landunits (do not weight)
+       water_inst%waterlnd2atmbulk_inst%qflx_rofliq_stream_grc(bounds%begg:bounds%endg) = 0._r8
+       do l = bounds%begl, bounds%endl
+          if(lun%active(l)) then
+             g = lun%gridcell(l)
+             water_inst%waterlnd2atmbulk_inst%qflx_rofliq_stream_grc(g) = &
+                  water_inst%waterlnd2atmbulk_inst%qflx_rofliq_stream_grc(g) &
+                  +  water_inst%waterfluxbulk_inst%volumetric_streamflow_lun(l) &
+                  *1e3_r8/(grc%area(g)*1.e6_r8)
+          endif
+       enddo
+
+       ! If hillslope routing is used, exclude inputs to stream channel from gridcell averages to avoid double counting
+       allocate( &
+            qflx_surf_col_to_rof(bounds%begc:bounds%endc), &
+            qflx_drain_col_to_rof(bounds%begc:bounds%endc), &
+            qflx_drain_perched_col_to_rof(bounds%begc:bounds%endc))
+
+       qflx_surf_col_to_rof(bounds%begc:bounds%endc)  = 0._r8
+       qflx_drain_col_to_rof(bounds%begc:bounds%endc) = 0._r8
+       qflx_drain_perched_col_to_rof(bounds%begc:bounds%endc) = 0._r8
+       
+       do c = bounds%begc, bounds%endc
+          ! Exclude hillslope columns from gridcell average
+          ! hillslope runoff is sent to stream rather than directly
+          ! to rof, and is accounted for in qflx_rofliq_stream_grc
+          if (col%active(c) .and. .not. col%is_hillslope_column(c)) then
+             qflx_surf_col_to_rof(c) = qflx_surf_col_to_rof(c) &
+                  + water_inst%waterfluxbulk_inst%qflx_surf_col(c)
+             qflx_drain_col_to_rof(c) = qflx_drain_col_to_rof(c) &
+                  + water_inst%waterfluxbulk_inst%qflx_drain_col(c)
+             qflx_drain_perched_col_to_rof(c) = &
+                  qflx_drain_perched_col_to_rof(c) &
+                  + water_inst%waterfluxbulk_inst%qflx_drain_perched_col(c)
+          endif
+       enddo
+          
+       call c2g( bounds, &
+            qflx_surf_col_to_rof  (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsur_grc   (bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity')
+       
+       call c2g( bounds, &
+            qflx_drain_col_to_rof (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsub_grc   (bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity')
+       
+       call c2g( bounds, &
+            qflx_drain_perched_col_to_rof (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity')
+       
+       deallocate(qflx_surf_col_to_rof,qflx_drain_col_to_rof, &
+            qflx_drain_perched_col_to_rof)
+
+    else
+    
+       call c2g( bounds, &
+            water_inst%waterfluxbulk_inst%qflx_surf_col (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsur_grc   (bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
+       
+       call c2g( bounds, &
+            water_inst%waterfluxbulk_inst%qflx_drain_col (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsub_grc   (bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
+       
+       call c2g( bounds, &
+            water_inst%waterfluxbulk_inst%qflx_drain_perched_col (bounds%begc:bounds%endc), &
+            water_inst%waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(bounds%begg:bounds%endg), &
+            c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
 
-    call c2g( bounds, &
-         water_inst%waterfluxbulk_inst%qflx_drain_col (bounds%begc:bounds%endc), &
-         water_inst%waterlnd2atmbulk_inst%qflx_rofliq_qsub_grc   (bounds%begg:bounds%endg), &
-         c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
+    endif
 
     do c = bounds%begc, bounds%endc
        if (col%active(c)) then
@@ -382,13 +451,7 @@ contains
          water_inst%waterlnd2atmbulk_inst%qflx_rofliq_grc(g) - &
          water_inst%waterfluxbulk_inst%qflx_liq_dynbal_grc(g)
     enddo
-
-    call c2g( bounds, &
-         water_inst%waterfluxbulk_inst%qflx_drain_perched_col (bounds%begc:bounds%endc), &
-         water_inst%waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(bounds%begg:bounds%endg), &
-         c2l_scale_type= 'urbanf', l2g_scale_type='unity' )
-
-
+    
     call c2g( bounds, &
          water_inst%waterfluxbulk_inst%qflx_sfc_irrig_col (bounds%begc:bounds%endc), &
          water_inst%waterlnd2atmbulk_inst%qirrig_grc(bounds%begg:bounds%endg), &
diff --git a/src/main/lnd2glcMod.F90 b/src/main/lnd2glcMod.F90
index 34f50266a..27fa7639d 100644
--- a/src/main/lnd2glcMod.F90
+++ b/src/main/lnd2glcMod.F90
@@ -20,7 +20,7 @@ module lnd2glcMod
   use decompMod       , only : get_proc_bounds, bounds_type, subgrid_level_column
   use domainMod       , only : ldomain
   use clm_varpar      , only : maxpatch_glc
-  use clm_varctl      , only : iulog
+  use clm_varctl      , only : iulog, use_hillslope
   use clm_varcon      , only : spval, tfrz
   use column_varcon   , only : col_itype_to_ice_class
   use landunit_varcon , only : istice, istsoil
@@ -204,7 +204,16 @@ contains
       ! Make sure we haven't already assigned the coupling fields for this point
       ! (this could happen, for example, if there were multiple columns in the
       ! istsoil landunit, which we aren't prepared to handle)
-      if (fields_assigned(g,n)) then
+      !
+      ! BUG(wjs, 2022-07-17, ESCOMP/CTSM#204) We have a known bug in the handling of bare
+      ! land fluxes when we potentially have multiple vegetated columns in a grid cell.
+      ! The most common configuration where this is the case is when use_hillslope is
+      ! true. In order to allow hillslope hydrology runs to work for now, we are
+      ! bypassing this error check when use_hillslope is true - under the assumption
+      ! that, for now, people aren't going to be interested in SMB in a run with
+      ! hillslope hydrology. Once we resolve ESCOMP/CTSM#204, we should remove the '.and.
+      ! .not. use_hillslope' part of this conditional.
+      if (fields_assigned(g,n) .and. .not. use_hillslope) then
          write(iulog,*) subname//' ERROR: attempt to assign coupling fields twice for the same index.'
          write(iulog,*) 'One possible cause is having multiple columns in the istsoil landunit,'
          write(iulog,*) 'which this routine cannot handle.'
diff --git a/src/main/subgridAveMod.F90 b/src/main/subgridAveMod.F90
index c5ce4a4a9..68431582c 100644
--- a/src/main/subgridAveMod.F90
+++ b/src/main/subgridAveMod.F90
@@ -100,6 +100,70 @@ module subgridAveMod
 
 contains
 
+  !-----------------------------------------------------------------------
+  subroutine set_c2l_scale (bounds, c2l_scale_type, scale_c2l)
+    !
+    ! !DESCRIPTION:
+    ! Set scale_c2l for different c2l_scale_type values
+    !
+    ! !ARGUMENTS:
+    type(bounds_type), intent(in) :: bounds        
+    character(len=*), intent(in) :: c2l_scale_type ! scale factor type for averaging (see note at top of module)
+    real(r8), intent(out) :: scale_c2l(bounds%begc:bounds%endc)     ! scale factor for column->landunit mapping
+
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: c,l                       ! indices
+    !------------------------------------------------------------------------
+
+    ! Enforce expected array sizes
+    SHR_ASSERT_ALL_FL((ubound(scale_c2l) == (/bounds%endc/)), sourcefile, __LINE__)
+
+    if (c2l_scale_type == 'unity') then
+       do c = bounds%begc,bounds%endc
+          scale_c2l(c) = 1.0_r8
+       end do
+    else if (c2l_scale_type == 'urbanf') then
+       do c = bounds%begc,bounds%endc
+          l = col%landunit(c) 
+          if (lun%urbpoi(l)) then
+             if (col%itype(c) == icol_sunwall) then
+                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
+             else if (col%itype(c) == icol_shadewall) then
+                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
+             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
+                scale_c2l(c) = 3.0_r8
+             else if (col%itype(c) == icol_roof) then
+                scale_c2l(c) = 1.0_r8
+             end if
+          else
+             scale_c2l(c) = 1.0_r8
+          end if
+       end do
+    else if (c2l_scale_type == 'urbans') then
+       do c = bounds%begc,bounds%endc
+          l = col%landunit(c) 
+          if (lun%urbpoi(l)) then
+             if (col%itype(c) == icol_sunwall) then
+                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
+             else if (col%itype(c) == icol_shadewall) then
+                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
+             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
+                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
+             else if (col%itype(c) == icol_roof) then
+                scale_c2l(c) = 1.0_r8
+             end if
+          else
+             scale_c2l(c) = 1.0_r8
+          end if
+       end do
+    else
+       write(iulog,*)'set_c2l_scale: scale type ',c2l_scale_type,' not supported'
+       call endrun(msg=errMsg(sourcefile, __LINE__))
+    end if
+
+  end subroutine set_c2l_scale
+    
   !-----------------------------------------------------------------------
   subroutine p2c_1d (bounds, parr, carr, p2c_scale_type)
     !
@@ -310,48 +374,7 @@ contains
     SHR_ASSERT_ALL_FL((ubound(parr) == (/bounds%endp/)), sourcefile, __LINE__)
     SHR_ASSERT_ALL_FL((ubound(larr) == (/bounds%endl/)), sourcefile, __LINE__)
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'p2l_1d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     if (p2c_scale_type == 'unity') then
        do p = bounds%begp,bounds%endp
@@ -418,48 +441,7 @@ contains
     SHR_ASSERT_ALL_FL((ubound(parr) == (/bounds%endp, num2d/)), sourcefile, __LINE__)
     SHR_ASSERT_ALL_FL((ubound(larr) == (/bounds%endl, num2d/)), sourcefile, __LINE__)
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'p2l_2d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     if (p2c_scale_type == 'unity') then
        do p = bounds%begp,bounds%endp
@@ -532,48 +514,7 @@ contains
     call build_scale_l2g(bounds, l2g_scale_type, &
          scale_l2g(bounds%begl:bounds%endl))
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'p2g_1d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     if (p2c_scale_type == 'unity') then
        do p = bounds%begp,bounds%endp
@@ -648,48 +589,7 @@ contains
     call build_scale_l2g(bounds, l2g_scale_type, &
          scale_l2g(bounds%begl:bounds%endl))
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'p2g_2d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     if (p2c_scale_type == 'unity') then
        do p = bounds%begp,bounds%endp
@@ -770,48 +670,7 @@ contains
        l_include_inactive = .false.
     end if
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'c2l_1d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     larr(bounds%begl : bounds%endl) = spval
     sumwt(bounds%begl : bounds%endl) = 0._r8
@@ -866,48 +725,7 @@ contains
     SHR_ASSERT_ALL_FL((ubound(carr) == (/bounds%endc, num2d/)), sourcefile, __LINE__)
     SHR_ASSERT_ALL_FL((ubound(larr) == (/bounds%endl, num2d/)), sourcefile, __LINE__)
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'c2l_2d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)    
 
     larr(bounds%begl : bounds%endl, :) = spval
     do j = 1,num2d
@@ -968,48 +786,7 @@ contains
     call build_scale_l2g(bounds, l2g_scale_type, &
          scale_l2g(bounds%begl:bounds%endl))
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'c2l_1d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)
 
     garr(bounds%begg : bounds%endg) = spval
     sumwt(bounds%begg : bounds%endg) = 0._r8
@@ -1070,48 +847,7 @@ contains
     call build_scale_l2g(bounds, l2g_scale_type, &
          scale_l2g(bounds%begl:bounds%endl))
 
-    if (c2l_scale_type == 'unity') then
-       do c = bounds%begc,bounds%endc
-          scale_c2l(c) = 1.0_r8
-       end do
-    else if (c2l_scale_type == 'urbanf') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = 3.0 * lun%canyon_hwr(l) 
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0_r8
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else if (c2l_scale_type == 'urbans') then
-       do c = bounds%begc,bounds%endc
-          l = col%landunit(c) 
-          if (lun%urbpoi(l)) then
-             if (col%itype(c) == icol_sunwall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_shadewall) then
-                scale_c2l(c) = (3.0 * lun%canyon_hwr(l)) / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_road_perv .or. col%itype(c) == icol_road_imperv) then
-                scale_c2l(c) = 3.0 / (2.*lun%canyon_hwr(l) + 1.)
-             else if (col%itype(c) == icol_roof) then
-                scale_c2l(c) = 1.0_r8
-             end if
-          else
-             scale_c2l(c) = 1.0_r8
-          end if
-       end do
-    else
-       write(iulog,*)'c2g_2d error: scale type ',c2l_scale_type,' not supported'
-       call endrun(msg=errMsg(sourcefile, __LINE__))
-    end if
+    call set_c2l_scale (bounds, c2l_scale_type, scale_c2l)
 
     garr(bounds%begg : bounds%endg,:) = spval
     do j = 1,num2d
diff --git a/src/main/subgridMod.F90 b/src/main/subgridMod.F90
index 7020f42be..2116d9c5d 100644
--- a/src/main/subgridMod.F90
+++ b/src/main/subgridMod.F90
@@ -75,6 +75,8 @@ contains
     ! atm_topo is arbitrary for the sake of getting these counts. We don't have a true
     ! atm_topo value at the point of this call, so use 0.
     real(r8), parameter :: atm_topo = 0._r8
+
+
     !------------------------------------------------------------------------------
 
     npatches = 0
@@ -85,6 +87,11 @@ contains
     call subgrid_get_info_natveg(gi, npatches_temp, ncols_temp, nlunits_temp)
     call accumulate_counters()
 
+    ! call this after natveg call because we allocate space for
+    ! FATES cohorts based on the number of naturally vegetated columns
+    ! and nothing else
+    call subgrid_get_info_cohort(gi, ncols_temp, ncohorts)
+
     call subgrid_get_info_urban_tbd(gi, npatches_temp, ncols_temp, nlunits_temp)
     call accumulate_counters()
 
@@ -107,8 +114,6 @@ contains
     call subgrid_get_info_crop(gi, npatches_temp, ncols_temp, nlunits_temp)
     call accumulate_counters()
    
-    call subgrid_get_info_cohort(gi,ncohorts)
-
   contains
     subroutine accumulate_counters
       ! Accumulate running sums of patches, columns and landunits.
@@ -131,6 +136,8 @@ contains
     !
     ! !USES
     use clm_varpar, only : natpft_lb, natpft_ub
+    use clm_instur, only : ncolumns_hillslope
+    use clm_varctl, only : use_hillslope
     !
     ! !ARGUMENTS:
     integer, intent(in)  :: gi        ! grid cell index
@@ -154,9 +161,16 @@ contains
     end do
 
     if (npatches > 0) then
-       ! Assume that the vegetated landunit has one column
-       ncols = 1
        nlunits = 1
+       if(use_hillslope) then 
+          ! ensure ncols is > 0
+          ncols = max(ncolumns_hillslope(gi),1)
+       else
+          ncols = 1
+       endif
+       ! Assume that each PFT present in the grid cell is present in every column
+       npatches = ncols*npatches
+
     else
        ! As noted in natveg_patch_exists, we expect a naturally vegetated landunit in
        ! every grid cell. This means that npatches should be at least 1 in every grid
@@ -220,7 +234,7 @@ contains
 
   ! -----------------------------------------------------------------------------
 
-  subroutine subgrid_get_info_cohort(gi, ncohorts)
+  subroutine subgrid_get_info_cohort(gi, ncols, ncohorts)
     !
     ! !DESCRIPTION:
     ! Obtain cohort counts per each gridcell.
@@ -230,6 +244,7 @@ contains
     !
     ! !ARGUMENTS:
     integer, intent(in)  :: gi        ! grid cell index
+    integer, intent(in)  :: ncols     ! number of nat veg columns in this grid cell
     integer, intent(out) :: ncohorts  ! number of cohorts in this grid cell
     !
     ! !LOCAL VARIABLES:
@@ -248,11 +263,10 @@ contains
     ! restart vector will just be a little sparse.
     ! -------------------------------------------------------------------------
     
-    ncohorts = fates_maxElementsPerSite
+    ncohorts = ncols*fates_maxElementsPerSite
     
  end subroutine subgrid_get_info_cohort
 
-
   !-----------------------------------------------------------------------
   subroutine subgrid_get_info_urban_tbd(gi, npatches, ncols, nlunits)
     !
diff --git a/src/main/surfrdMod.F90 b/src/main/surfrdMod.F90
index 78c9d8492..3935b170d 100644
--- a/src/main/surfrdMod.F90
+++ b/src/main/surfrdMod.F90
@@ -721,7 +721,7 @@ contains
     ! Determine weight arrays for non-dynamic landuse mode
     !
     ! !USES:
-    use clm_varctl      , only : create_crop_landunit, use_fates, n_dom_pfts
+    use clm_varctl      , only : create_crop_landunit, use_fates, n_dom_pfts, use_hillslope
     use clm_varpar      , only : natpft_lb, natpft_ub, natpft_size, cft_size, cft_lb, cft_ub
     use clm_instur      , only : wt_lunit, wt_nat_patch, wt_cft, fert_cft
     use landunit_varcon , only : istsoil, istcrop
@@ -814,7 +814,12 @@ contains
                ' must also have a separate crop landunit, and vice versa)'//&
                errMsg(sourcefile, __LINE__))
     end if
-    
+
+    ! Obtain hillslope hydrology information and modify pft weights
+    if(use_hillslope) then 
+       call surfrd_hillslope(begg, endg, ncid, ns)
+    endif
+
     ! Convert from percent to fraction
     wt_lunit(begg:endg,istsoil) = wt_lunit(begg:endg,istsoil) / 100._r8
     wt_lunit(begg:endg,istcrop) = wt_lunit(begg:endg,istcrop) / 100._r8
@@ -882,6 +887,130 @@ contains
   end subroutine surfrd_veg_dgvm
 
   !-----------------------------------------------------------------------
+  subroutine surfrd_hillslope(begg, endg, ncid, ns)
+    !
+    ! !DESCRIPTION:
+    ! Determine number of hillslopes and columns for hillslope hydrology mode
+    !
+    ! !USES:
+    use clm_instur, only : ncolumns_hillslope, wt_nat_patch
+    use clm_varctl, only : nhillslope,max_columns_hillslope
+    use clm_varpar, only : natpft_size, natpft_lb
+    use ncdio_pio,  only : ncd_inqdid, ncd_inqdlen
+    use pftconMod , only : noveg
+    use HillslopeHydrologyMod, only : pft_distribution_method, pft_from_file, pft_uniform_dominant_pft, pft_lowland_dominant_pft, pft_lowland_upland
+    use array_utils, only: find_k_max_indices
+    
+    !
+    ! !ARGUMENTS:
+    integer, intent(in) :: begg, endg
+    type(file_desc_t),intent(inout) :: ncid   ! netcdf id
+    integer          ,intent(in)    :: ns     ! domain size
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: g, nh, m, n                       ! index
+    integer  :: dimid,varid                    ! netCDF id's
+    integer  :: ier                            ! error status	
+    integer, allocatable  :: max_indices(:)    ! largest weight pft indices
+    logical  :: readvar                        ! is variable on dataset
+    integer,pointer :: arrayl(:)               ! local array (needed because ncd_io expects a pointer)
+    character(len=32) :: subname = 'surfrd_hillslope'  ! subroutine name
+    !-----------------------------------------------------------------------
+
+    ! number of hillslopes per landunit
+    call ncd_inqdid(ncid,'nhillslope',dimid,readvar) 
+    if (.not. readvar) then
+       call endrun( msg=' ERROR: nhillslope not on surface data file'//errMsg(sourcefile, __LINE__))
+    else
+       call ncd_inqdlen(ncid,dimid,nh)
+       nhillslope = nh
+    endif
+    ! maximum number of columns per landunit
+    call ncd_inqdid(ncid,'nmaxhillcol',dimid,readvar) 
+    if (.not. readvar) then
+       call endrun( msg=' ERROR: nmaxhillcol not on surface data file'//errMsg(sourcefile, __LINE__))
+    else
+       call ncd_inqdlen(ncid,dimid,nh)
+       max_columns_hillslope = nh
+    endif
+    ! actual number of columns per landunit
+    allocate(arrayl(begg:endg))
+    call ncd_io(ncid=ncid, varname='nhillcolumns', flag='read', data=arrayl, &
+         dim1name=grlnd, readvar=readvar)
+    if (.not. readvar) then
+       call endrun( msg=' ERROR: nhillcolumns not on surface data file'//errMsg(sourcefile, __LINE__))
+    else
+       ncolumns_hillslope(begg:endg) = arrayl(begg:endg)
+    endif
+    deallocate(arrayl)
+
+    ! pft_from_file and pft_lowland_upland assume that 1 pft
+    ! will exist on each hillslope column.  In prepration, set one
+    ! pft weight to 100 and the rest to 0.  The vegetation type
+    ! (patch%itype) will be reassigned when initHillslope is called later.
+    if(pft_distribution_method == pft_from_file .or. &
+         pft_distribution_method == pft_lowland_upland) then
+       do g = begg, endg
+          ! If hillslopes will be used in a gridcell, modify wt_nat_patch, otherwise use original patch distribution
+          if(ncolumns_hillslope(g) > 0) then
+             ! First patch gets 100% weight; all other natural patches are zeroed out
+             wt_nat_patch(g,:)         = 0._r8
+             wt_nat_patch(g,natpft_lb) = 100._r8
+          endif
+       enddo
+    endif
+
+    ! pft_uniform_dominant_pft uses the patch with the
+    ! largest weight for all hillslope columns in the gridcell
+    if (pft_distribution_method == pft_uniform_dominant_pft) then
+       allocate(max_indices(1))
+       do g = begg, endg
+          ! If hillslopes will be used in a gridcell, modify wt_nat_patch,
+          ! otherwise use original patch distribution
+          if(ncolumns_hillslope(g) > 0) then
+
+             call find_k_max_indices(wt_nat_patch(g,:),natpft_lb,1,max_indices)
+             wt_nat_patch(g,:) = 0._r8
+             wt_nat_patch(g,max_indices(1)) = 100._r8
+             
+          endif
+       enddo
+       deallocate(max_indices)
+    endif
+
+    ! pft_lowland_dominant_pft uses the two patches with the
+    ! largest weights for the hillslope columns in the gridcell
+    if (pft_distribution_method == pft_lowland_dominant_pft) then
+       allocate(max_indices(2))
+       do g = begg, endg
+          ! If hillslopes will be used in a gridcell, modify wt_nat_patch, otherwise use original patch distribution
+          if(ncolumns_hillslope(g) > 0) then
+             
+             ! Preserve the relative weights of the largest and
+             ! next largest weights using arbitrarily chosen values
+             ! (i.e. 1 should be larger than 2) that sum to 100.
+             ! This will minimize memory usage while still allowing
+             ! HillslopeDominantLowlandPft to pick out the two largest patch types.
+
+             call find_k_max_indices(wt_nat_patch(g,:),natpft_lb,2,max_indices)
+             ! check that 2nd index weight is non-zero
+             if (wt_nat_patch(g,max_indices(2)) > 0._r8) then
+                wt_nat_patch(g,:) = 0._r8
+                wt_nat_patch(g,max_indices(1)) = 75._r8
+                wt_nat_patch(g,max_indices(2)) = 25._r8
+             else
+                ! if only one pft exists, set its weight to 100 per cent
+                wt_nat_patch(g,:) = 0._r8
+                wt_nat_patch(g,max_indices(1)) = 100._r8
+             endif
+                
+          endif
+       enddo
+       deallocate(max_indices)
+    endif
+
+  end subroutine surfrd_hillslope
+
   subroutine surfrd_lakemask(begg, endg)
     !
     ! !DESCRIPTION:
diff --git a/src/main/test/atm2lnd_test/test_downscale_forcings.pf b/src/main/test/atm2lnd_test/test_downscale_forcings.pf
index d688ad809..ddd097d16 100644
--- a/src/main/test/atm2lnd_test/test_downscale_forcings.pf
+++ b/src/main/test/atm2lnd_test/test_downscale_forcings.pf
@@ -9,6 +9,7 @@ module test_downscale_forcings
   use unittestSimpleSubgridSetupsMod
   use unittestArrayMod
   use atm2lndType, only : atm2lnd_type, atm2lnd_params_type
+  use SurfaceAlbedoType, only : surfalb_type
   use Wateratm2lndBulkType, only : wateratm2lndbulk_type
   use WaterInfoBulkType, only : water_info_bulk_type
   use TopoMod, only : topo_type
@@ -25,6 +26,7 @@ module test_downscale_forcings
   @TestCase
   type, extends(TestCase) :: TestDownscaleForcings
      type(atm2lnd_type) :: atm2lnd_inst
+     type(surfalb_type) :: surfalb_inst
      type(wateratm2lndbulk_type) :: wateratm2lndbulk_inst
      type(topo_type_always_downscale) :: topo_inst
      real(r8), allocatable :: eflx_sh_precip_conversion(:)
@@ -204,8 +206,13 @@ contains
     class(TestDownscaleForcings), intent(inout) :: this
 
     this%eflx_sh_precip_conversion = col_array()
-    call downscale_forcings(bounds, this%topo_inst, &
-         this%atm2lnd_inst, this%wateratm2lndbulk_inst, &
+    call downscale_forcings(bounds, &
+         this%topo_inst, &
+         this%atm2lnd_inst, &
+         ! Currently surfalb_inst is only used for hillslope downscaling; we need to pass
+         ! it to satisfy the interface but we haven't bothered setting it up
+         this%surfalb_inst, &
+         this%wateratm2lndbulk_inst, &
          this%eflx_sh_precip_conversion)
   end subroutine call_downscale_forcings
 
diff --git a/src/main/test/atm2lnd_test/test_partition_precip.pf b/src/main/test/atm2lnd_test/test_partition_precip.pf
index 48c12c3f3..56febc1b3 100644
--- a/src/main/test/atm2lnd_test/test_partition_precip.pf
+++ b/src/main/test/atm2lnd_test/test_partition_precip.pf
@@ -5,6 +5,7 @@ module test_partition_precip
   use funit
   use atm2lndMod
   use atm2lndType
+  use ColumnType, only : col
   use shr_kind_mod, only : r8 => shr_kind_r8
   use unittestSubgridMod
   use unittestSimpleSubgridSetupsMod
@@ -64,6 +65,7 @@ contains
 
     logical :: l_repartition_rain_snow
     type(atm2lnd_params_type) :: atm2lnd_params
+    integer :: c, g
 
     if (present(repartition_rain_snow)) then
        l_repartition_rain_snow = repartition_rain_snow
@@ -89,6 +91,15 @@ contains
     this%wateratm2lndbulk_inst%forc_rain_not_downscaled_grc(bounds%begg:bounds%endg) = rain(:)
     this%wateratm2lndbulk_inst%forc_snow_not_downscaled_grc(bounds%begg:bounds%endg) = snow(:)
     this%atm2lnd_inst%forc_t_downscaled_col(bounds%begc:bounds%endc) = temperature(:)
+
+    ! In the production code, column-level versions of forc_rain and forc_snow are
+    ! initialized to the gridcell-level versions prior to the call to partition_precip; do
+    ! that here
+    do c = bounds%begc, bounds%endc
+       g = col%gridcell(c)
+       this%wateratm2lndbulk_inst%forc_rain_downscaled_col(c) = this%wateratm2lndbulk_inst%forc_rain_not_downscaled_grc(g)
+       this%wateratm2lndbulk_inst%forc_snow_downscaled_col(c) = this%wateratm2lndbulk_inst%forc_snow_not_downscaled_grc(g)
+    end do
   end subroutine set_inputs
 
   @Test
diff --git a/src/utils/clmfates_interfaceMod.F90 b/src/utils/clmfates_interfaceMod.F90
index 48dc3297c..53b8e4bd1 100644
--- a/src/utils/clmfates_interfaceMod.F90
+++ b/src/utils/clmfates_interfaceMod.F90
@@ -2080,7 +2080,7 @@ module CLMFatesInterfaceMod
 
      call t_startf('fates_wrapsunfrac')
 
-      associate( forc_solad => atm2lnd_inst%forc_solad_grc, &
+      associate( forc_solad => atm2lnd_inst%forc_solad_not_downscaled_grc, &
                  forc_solai => atm2lnd_inst%forc_solai_grc, &
                  fsun       => canopystate_inst%fsun_patch, &
                  laisun     => canopystate_inst%laisun_patch, &
